# 周洋主讲面试题

[TOC]

## volatile是什么

volatile是JVM提供的**轻量级**的同步机制，有三大特性

1. 保证可见性
2. 不保证原子性
3. 禁止指令重排（保证有序性）

## JMM内存模型

JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定：

1. 线程解锁前，必须把共享变量的值刷新回主内存
2. 线程加锁前，必须读取主内存的最新值到自己的工作内存
3. 加锁解锁是同一把锁

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![1619347442594](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202104/25/184404-956520.png)

以上这种某一个线程对共享变量的修改后，然后对其他的线程可见，就叫做可见性。

### 可见性

- 通过前面对JMM的介绍，我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
- 这就可能存在一个线程AAA修改了共享变量X的值但还未写回主内存时，另外一个线程BBB又对主内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题

**可见性代码验证说明**

~~~ java
/**
 * 假设是主物理内存
 */
class MyData {

    //volatile int number = 0;
     int number = 0;

    public void addTo60() {
        this.number = 60;
    }
}


/**
 * 验证volatile的可见性
 * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰
 */
public class VolatileDemo {

    public static void main(String[] args) {
        // 资源类
        MyData myData = new MyData();

        // AAA线程 实现了Runnable接口的，lambda表达式
        new Thread(() -> {

            System.out.println(Thread.currentThread().getName() + "\t come in");

            // 线程睡眠3秒，假设在进行运算
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 修改number的值
            myData.addTo60();

            // 输出修改后的值
            System.out.println(Thread.currentThread().getName() + "\t update number value:" + myData.number);

        }, "AAA").start();

        // main线程就一直在这里等待循环，直到number的值不等于零,但是不可能为0，因为aaa线程对值的修改对main线程是不可见的
//        如果给number添加volatile关键字，就保证了其可见性
        while(myData.number == 0) {}

        // 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环
        // 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了
        System.out.println(Thread.currentThread().getName() + "\t mission is over");
    }
}
~~~

由于没有`volatile`修饰`MyData`类的成员变量`number`，`main`线程将会卡在`while(myData.number == 0) {}`，不能正常结束。若想正确结束，用`volatile`修饰`MyData`类的成员变量`number`。

**volatile类比**

没有volatile修饰变量效果，相当于A同学拷贝了老师同一课件，A同学对课件进一步的总结归纳，形成自己的课件，这就与老师的课件不同了。

有volatile修饰变量效果，相当于A同学拷贝了老师同一课件，A同学对课件进一步的总结归纳，形成自己的课件，并且与老师分享，老师认可A同学修改后的课件，并用它来作下一届的课件。

### 原子性

