## Flink内存管理

### JVM自动内存管理优缺点

优点：JVM降低了程序员对内存管理的门槛，JVM可以对代码进行深度优化

缺点：但同时也使得程序员把管理内存的主动权交给了JVM

### 自主内存管理

Flink选择自主内存管理，即回收部分JVM进程内存管理的主动权，原因：JVM内存管理在大数据场景下有诸多问题。

#### JVM内存管理的不足

**有效数据密度低**

Java对象在内存中的存储主要包含：对象头、实例数据、对齐填充部分。

![1637582576160](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202111/22/200257-289206.png)

例如，boolean占1byte，但是在内存中数据存储不是连续的，而是按照8byte的整数倍进行存储的，就会进行填充，造成数据密度低。

**垃圾回收**

在大数据场景下，内存不可控，如果出现需要消耗大量内存进行计算的场景，当产生海量Java对象，一旦出现Full GC，GC耗时可能甚至达到分钟级，直接影响集群的心跳等。

**OOM问题影响稳定性**

例如，OutOfMemoryException在分布式框架中经常会遇到，分布式框架的健壮性和稳定性都会收到影响。

缓存未命中问题

CPU的L1、L2、L3的多级缓存理论基础来自于程序局部性原理：

- 空间局部性：被CPU访问的数据，CPU短期内还要访问

- 时间局部性：被CPU访问的数据附近的数据，CPU短期内还要访问

但是，Java堆对象的存储并不连续。CPU空转是计算机性能之殇。

#### 自主内存管理

在Flink中Java对象的有效信息被序列化，在内存中连续存储，保存在预分配的内存块上，内存块叫作**MemorySegment**，即内存分配的最小单元。很多运算可以直接操作序列化的二进制数据，而不需要反序列化。

MemorySegment可以在堆上：Java byte数组；也可以在堆外：ByteBuffer。

#### 堆外内存 VS 堆内内存

**堆外内存的优势：**

- 避免GC和内存溢出

- 高效的IO操作。堆外内存写磁盘IO或网络IO是zero-copy(零拷贝)

- 堆外内存是进程间共享的。JVM进程崩溃不会丢失数据，可以用来故障恢复

**堆外内存的劣势：**

- 堆上内存的使用、监控、调试简单。

- 短生命周期的MemorySegment的分配，堆内内存开销更小。

- Flink的部分操作在堆外内存比堆内内存慢。

> Flink在计算中采用了DBMS的Sort和Join算法，直接操作二进制数据，避免反复序列化。