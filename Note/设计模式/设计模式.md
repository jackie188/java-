# 设计模式

<!-- TOC -->

- [设计模式](#设计模式)
  - [设计模式的目的](#设计模式的目的)
  - [设计模式的七大原则](#设计模式的七大原则)
    - [单一职责原则（Single Responsibility Principle，SRP）](#单一职责原则single-responsibility-principlesrp)
      - [基本介绍](#基本介绍)
      - [案例说明](#案例说明)
      - [单一职责原则注意事项](#单一职责原则注意事项)
    - [接口隔离原则(Interface Segregation Principle)](#接口隔离原则interface-segregation-principle)
      - [基本介绍](#基本介绍-1)
      - [案例说明](#案例说明-1)
      - [接口隔离原则的优点](#接口隔离原则的优点)
    - [依赖倒转原则](#依赖倒转原则)
      - [基本介绍](#基本介绍-2)
      - [案例说明](#案例说明-2)
      - [依赖关系传递的三种方式和应用案例](#依赖关系传递的三种方式和应用案例)
      - [依赖倒转原则细节](#依赖倒转原则细节)
    - [里式替换原则](#里式替换原则)
      - [oo中继承性的思考](#oo中继承性的思考)
      - [基本介绍](#基本介绍-3)
      - [案例演示](#案例演示)
    - [开闭原则](#开闭原则)
      - [基本介绍](#基本介绍-4)
      - [案例说明](#案例说明-3)
      - [改进思路](#改进思路)
    - [迪米特法则](#迪米特法则)
      - [基本介绍](#基本介绍-5)
      - [应用案例](#应用案例)
      - [迪米特法则细节](#迪米特法则细节)
    - [合成复用原则（Composite Reuse Principle）](#合成复用原则composite-reuse-principle)
      - [基本介绍](#基本介绍-6)
    - [设计模式的核心思想](#设计模式的核心思想)
  - [UML类图](#uml类图)
    - [UML基本介绍](#uml基本介绍)
    - [UML图分类](#uml图分类)
    - [类图—依赖关系（Dependence）](#类图依赖关系dependence)
    - [类图—泛化关系 (generalization）](#类图泛化关系-generalization)
    - [类图—实现关系（Implementation）](#类图实现关系implementation)
    - [类图—关联关系（Association）](#类图关联关系association)
    - [类图—聚合关系（Aggregation）](#类图聚合关系aggregation)
    - [类图—组合关系（Composition）](#类图组合关系composition)
  - [设计模式](#设计模式-1)
    - [设计模式介绍](#设计模式介绍)
    - [设计模式的分类](#设计模式的分类)
    - [单例设计模式](#单例设计模式)
      - [单例设计模式的介绍](#单例设计模式的介绍)
      - [单例模式的实现](#单例模式的实现)
        - [饿汉式（静态常量）](#饿汉式静态常量)
        - [饿汉式（静态代码块）](#饿汉式静态代码块)
        - [懒汉式（线程不安全）](#懒汉式线程不安全)
        - [懒汉式（线程安全1）](#懒汉式线程安全1)
        - [懒汉式（线程安全2）](#懒汉式线程安全2)
        - [双重检查](#双重检查)
        - [静态内部类](#静态内部类)
        - [枚举](#枚举)
        - [单例模式在jdk源码中的分析](#单例模式在jdk源码中的分析)
      - [单例模式注意事项](#单例模式注意事项)
      - [单例模式的应用场景](#单例模式的应用场景)
      - [单例模式优缺点分析](#单例模式优缺点分析)
    - [简单工厂模式](#简单工厂模式)
      - [传统方式解决](#传统方式解决)
      - [简单工厂介绍](#简单工厂介绍)
      - [工厂方法模式](#工厂方法模式)
      - [工厂方法介绍](#工厂方法介绍)
      - [抽象工厂模式](#抽象工厂模式)
    - [原型模式](#原型模式)
      - [克隆羊](#克隆羊)
      - [传统解决方式](#传统解决方式)
      - [原型模式介绍](#原型模式介绍)
      - [浅拷贝](#浅拷贝)
      - [深拷贝](#深拷贝)
      - [原型模型优缺点](#原型模型优缺点)
      - [原型模型应用场景](#原型模型应用场景)
    - [建造者模式](#建造者模式)
      - [需求](#需求)
      - [传统方式解决盖房子](#传统方式解决盖房子)
      - [建造者模式的基本介绍](#建造者模式的基本介绍)
      - [建造者模式的基本角色](#建造者模式的基本角色)
      - [建造者模式实现盖房子](#建造者模式实现盖房子)
      - [建造者模式在jdk源码中的分析](#建造者模式在jdk源码中的分析)
      - [建造者模式的注意细节](#建造者模式的注意细节)
      - [建造者模式的优缺点](#建造者模式的优缺点)
      - [建造者模式应用场景](#建造者模式应用场景)
    - [适配器模式](#适配器模式)
      - [基本介绍](#基本介绍-7)
      - [工作原理](#工作原理)
      - [模式的结构](#模式的结构)
      - [类适配器](#类适配器)
      - [对象适配器](#对象适配器)
      - [接口适配器模式](#接口适配器模式)
      - [适配器模式的注意细节](#适配器模式的注意细节)
      - [优缺点](#优缺点)
      - [应用场景](#应用场景)
    - [桥接模式](#桥接模式)
      - [问题引入](#问题引入)
      - [桥接模式](#桥接模式-1)
      - [桥接模式的实现](#桥接模式的实现)
      - [使用桥接模式解决手机问题](#使用桥接模式解决手机问题)
      - [桥接模式在JDBC源码包中的应用](#桥接模式在jdbc源码包中的应用)
      - [桥接模式注意事项](#桥接模式注意事项)
      - [应用场景](#应用场景-1)
    - [装饰器模式](#装饰器模式)
      - [星巴克咖啡订单项目（咖啡馆）](#星巴克咖啡订单项目咖啡馆)
      - [方案一](#方案一)
      - [方案二](#方案二)
      - [装饰器模式定义](#装饰器模式定义)
      - [装饰器模式原理](#装饰器模式原理)
      - [装饰器模式解决星巴克咖啡问题](#装饰器模式解决星巴克咖啡问题)
      - [装饰器在jdk源码中的分析](#装饰器在jdk源码中的分析)
      - [装饰器模式的优缺点](#装饰器模式的优缺点)
      - [装饰器模式的应用场景](#装饰器模式的应用场景)
    - [组合模式](#组合模式)
      - [问题引入](#问题引入-1)
      - [组合模式基本介绍](#组合模式基本介绍)
      - [组合模式类图](#组合模式类图)
      - [组合模式解决学校院系展示的 应用实例](#组合模式解决学校院系展示的-应用实例)
      - [组合模式在 JDK 集合的源码分析](#组合模式在-jdk-集合的源码分析)
      - [应用场景](#应用场景-2)
      - [优缺点](#优缺点-1)
      - [使用注意细节](#使用注意细节)
    - [外观模式](#外观模式)
      - [情景引入](#情景引入)
      - [传统方法解决](#传统方法解决)
      - [外观模式基本介绍](#外观模式基本介绍)
      - [外观模式的结构与实现](#外观模式的结构与实现)
      - [外观模式解决影院管理](#外观模式解决影院管理)
      - [外观模式注意事项](#外观模式注意事项)
      - [外观模式的优缺点](#外观模式的优缺点)
      - [应用场景](#应用场景-3)
    - [享元模式](#享元模式)
      - [问题引入](#问题引入-2)
      - [传统方法解决](#传统方法解决-1)
      - [享元模式的基本介绍](#享元模式的基本介绍)
      - [享元模式的结构实现](#享元模式的结构实现)
      - [享元模式解决网站展现项目](#享元模式解决网站展现项目)
      - [享元模式在 JDK-Interger 的应用源码分析](#享元模式在-jdk-interger-的应用源码分析)
      - [享元模式优点及应用场景](#享元模式优点及应用场景)
      - [使用享元模式注意细节](#使用享元模式注意细节)
    - [代理模式](#代理模式)
      - [什么是代理](#什么是代理)
      - [代理模式特点](#代理模式特点)
      - [静态代理](#静态代理)
        - [什么是静态代理](#什么是静态代理)
        - [应用实例](#应用实例)
        - [类图分析](#类图分析)
        - [静态代理优缺点](#静态代理优缺点)
      - [动态代理](#动态代理)
        - [什么是动态代理](#什么是动态代理)
        - [JDK 中生成代理对象的 API](#jdk-中生成代理对象的-api)
        - [应用实例](#应用实例-1)
      - [几种常见的代理模式变体](#几种常见的代理模式变体)

<!-- /TOC -->

## 设计模式的目的

编写软件过程中，程序员面临着来自**耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的挑战，设计模式是为了让程序(软件)，具有更好：

- 代码重用性 (即：相同功能的代码，不用多次编写)
- 可读性 (即：编程规范性,  便于其他程序员的阅读和理解)
- 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)
- 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
- 使程序呈现高内聚，低耦合的特性

## 设计模式的七大原则

> - 单一职责原则
> - 接口隔离原则
> - 依赖倒转(倒置)原则
> - 里氏替换原则
> - 开闭原则
> - 迪米特法则
> - 合成复用原则

**符号含义**

![1609229771025](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/161612-623711.png)

### 单一职责原则（Single Responsibility Principle，SRP）

#### 基本介绍

对类来说的，即一个类应该只负责一项职责（但是并不是说一个类中只有一个方法,一个类只负责一项工作，比如某一个类设计只用于负责订单处理，不考虑其他的）。如类 A负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 `A` 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 `A1`，`A2`，也就是分成两个类。

该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 

1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2.  当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

#### 案例说明

**代码演示**

~~~ java
package rzf.qq.com.partendesign;

public class SingleResponability {
    public static void main(String[] args) {
        Vehicle v=new Vehicle();
        v.run("摩托车");
        v.run("火车");
        v.run("飞机");

    }
}
//在方式 1 的 run 方法中，违反了单一职责原则
//解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可

class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle+"在公路上跑");
    }
}
//输出结果
摩托车在公路上跑
火车在公路上跑
飞机在公路上跑//很明显不是很符合
~~~

- 在方式 1 的` run `方法中，违反了单一职责原则
- 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可

**改进一**（类级别的单一职责）

- 解决方式是把交通工具进行分类。

~~~ java
public class SingleResponability {
    public static void main(String[] args) {
        RoadVehicle v=new RoadVehicle();
        v.run("摩托车");
        v.run("火车");
        AirVehicle v1=new AirVehicle();
        v1.run("飞机");

    }
}

//1，这样做符合单一职责模式
//2,这样做开销很大，因为需要修改客户端，也就是主函数里面的内容要修改
//3，还可以对方式二进行修改

class RoadVehicle{
    public void run(String vehicle){
        System.out.println(vehicle+"在公路上跑");
    }
}

class AirVehicle{
    public void run(String vehicle){
        System.out.println(vehicle+"在天上飞");
    }
}
~~~

- 这样做符合单一职责模式
- 这样做开销很大，因为需要修改客户端，也就是主函数里面的内容要修改
- 还可以对方式二进行修改，如下改进二

**改进二**（方法级别的单一职责）

~~~ java
public class SingleResponability {
    public static void main(String[] args) {
       Vehicle v=new Vehicle();
       v.runAir("飞机");
       v.runRoad("火车");
       v.runWater("轮船");

    }
}

class Vehicle{
    public void runRoad(String vehicle){
        System.out.println(vehicle+"在地上运行");
    }
    public void runAir(String vehicle){
        System.out.println(vehicle+"在天上运行");
    }
    public void runWater(String vehicle){
        System.out.println(vehicle+"在水里运行");
    }

}
~~~

- 这种修改没有对原来的类做很大的修改，只是增加方法。
- 这里虽然没有在类级别上遵循单一职责，但是在方法层面仍然遵循单一职责。
- 单一职责总的来说就是各司其职，互不影响。

#### 单一职责原则注意事项

1. 降低类的复杂度（使用类来化解，不要使用很多的条件判断），一个类只负责一项职责。

2. 提高类的可读性，可维护性

3. 降低变更引起的风险（比如需要修改地上运行的工具，对其他类没有什么影响）
4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则（一标准情况下是要分成两个；类来分别处理）；只有类中方法数量足够少，可以在方法级别保持单一职责原则
5. 使用单一职责模式也就是防止方法中出现很多`if–else`条件判断，这样的话耦合度很高。

### 接口隔离原则(Interface Segregation Principle)

#### 基本介绍

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上，以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 

-  单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
-  单一职责原则主要是约束类，它针对的是程序中的**实现和细节**；接口隔离原则主要约束**接口，主要针对抽象和程序整体框架的构建。**
-  接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

**案例类图**

![1608369574964](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/19/171936-655943.png)

- 类 `A `通过接口` Interface1` 依赖类` B`，类` C `通过接口` Interface1 `依赖类` D`，如果接口` Interface1` 对于类 `A `和类 `C`来说不是最小接口，那么类` B` 和类` D `必须去实现他们不需要的方法。
- 按隔离原则应当这样处理：
  - 将接口 **`Interface1`** 拆分为独立的几个接口**(**这里我们拆分成 **3** 个接口**)**，类 `A` 和类` C` 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则

#### 案例说明

**没有分离接口**

~~~ java
interface interface01{
    void operation01();
    void operation02();
    void operation03();
    void operation04();
    void operation05();
}

class B implements interface01{

    @Override
    public void operation01() {
        System.out.println("class B implements operation01");
    }

    @Override
    public void operation02() {
        System.out.println("class B implements operation02");
    }

    @Override
    public void operation03() {
        System.out.println("class B implements operation03");
    }

    @Override
    public void operation04() {
        System.out.println("class B implements operation04");
    }

    @Override
    public void operation05() {
        System.out.println("class B implements operation05");
    }
}

class D implements interface01{

    @Override
    public void operation01() {
        System.out.println("class D implements operation01");
    }

    @Override
    public void operation02() {
        System.out.println("class D implements operation02");
    }

    @Override
    public void operation03() {
        System.out.println("class D implements operation03");
    }

    @Override
    public void operation04() {
        System.out.println("class D implements operation04");
    }

    @Override
    public void operation05() {
        System.out.println("class D implements operation05");
    }
}


class A{
//    A类通过接口interface01 依赖（使用）类B但是只会使用1，2，3方法
    public void depend01(interface01 i){
        i.operation01();
    }
    public void depend02(interface01 i){
        i.operation02();
    }
    public void depend03(interface01 i){
        i.operation03();
    }
}

class C{
    //    C类通过接口interface01 依赖（使用）类D但是只会使用1，4，5方法
    public void depend01(interface01 i){
        i.operation01();
    }
    public void depend04(interface01 i){
        i.operation04();
    }
    public void depend05(interface01 i){
        i.operation05();
    }
}
~~~

- 如果不对接口进行分离，可以看到，类B,D都实现接口中的全部方法，但是真正类A,C是用不到接口中的全部方法的，所以，根据接口隔离原则，我们要对接口进行拆分。

**使用接口隔离原则进行改进**

- 类 A 通过接口 `Interface1` 依赖类 B，类 C 通过接口` Interface1` 依赖类 D，如果接口 `Interface1 `对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法
- 将接口 **`Interface1`** 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
- 接口 `Interface1` 中出现的方法，根据实际情况拆分为三个接口

**类图展示**

![1608370609294](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/19/173650-484986.png)

**代码说明**

~~~ java
public class Segregation {
    public static void main(String[] args) {
        A a=new A();
        a.depend01(new B());//A通过接口去依赖B类
        a.depend02(new B());//A通过接口去依赖B类
        a.depend03(new B());//A通过接口去依赖B类
    }
}

interface interface01{
    void operation01();
}
interface interface02{
    void operation02();
    void operation03();
}
interface interface03{
    void operation04();
    void operation05();
}

//现在类B并不需要实现方法4,5
class B implements interface01,interface02{

    @Override
    public void operation01() {
        System.out.println("class B implements operation01");
    }

    @Override
    public void operation02() {
        System.out.println("class B implements operation02");
    }

    @Override
    public void operation03() {
        System.out.println("class B implements operation03");
    }

}

class D implements interface01,interface03{

    @Override
    public void operation01() {
        System.out.println("class D implements operation01");
    }
    @Override
    public void operation04() {
        System.out.println("class D implements operation04");
    }

    @Override
    public void operation05() {
        System.out.println("class D implements operation05");
    }
}

class A{
//    A类通过接口interface01 A类通过接口interface02依赖（使用）类B但是只会使用1，2，3方法
    public void depend01(interface01 i){
        i.operation01();
    }
    public void depend02(interface02 i){
        i.operation02();
    }
    public void depend03(interface02 i){
        i.operation03();
    }
}

class C{
    //    C类通过接口interface01 依赖（使用）类D但是只会使用1，4，5方法
    public void depend01(interface01 i){
        i.operation01();
    }
    public void depend04(interface03 i){
        i.operation04();
    }
    public void depend05(interface03 i){
        i.operation05();
    }
}
~~~

#### 接口隔离原则的优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。

1.  将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2.  **接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。**
3.  如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
4.  使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
5.  能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

**接口隔离原则的实现**

在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 

-  接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
-  了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
-  提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

### 依赖倒转原则

#### 基本介绍

依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细

节，细节应该依赖抽象，其核心思想是：**要面向接口编程，不要面向实现编程。**

依赖倒转原则(`Dependence Inversion Principle`)是指：

- 高层模块不应该依赖低层模块，二者都应该依赖其抽象(抽象类或者接口，不要依赖具体的子类)

- 抽象不应该依赖细节，细节应该依赖抽象

- 依赖倒转(倒置)的中心思想是**面向接口编程**

- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建

  的架构比以细节为基础的架构要稳定的多。在` java `中，**抽象指的是接口或抽象类，细节就是具体的实现类**

- 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

**使用好处**

1. 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

2. 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

3. 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

**依赖倒转原则的作用**

依赖倒置原则的主要作用如下。 

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

**依赖倒转原则的实现**

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

#### 案例说明

请编程完成 `Person ` 接收消息 的功能。

**代码说明**

~~~ java
public class DependencyInversion {
    public static void main(String[] args) {
        Person p =new Person();
        p.receive(new Email());

    }
}

//是一个具体的类
class Email{
    public String getInfo(){
        return "电子邮件信息：HELLO WORD !";
    }
}

/**
 * 方式一：
 * 优点：1 很容易想到
 * 缺点：1，如果我们要增加对短信，微信消息的接受，那么对person类也要相应增加receive()方法
 * 解决思路：引入一个抽象的接口Receiver,表示接受者，这样person就可以和接口发生依赖
 *          因为微信，email都属于接受的范畴，都实现Receiver即可，符合依赖倒转原则，
 */
class Person{
    public void receive(Email e){
        System.out.println(e.getInfo());
    }
}
~~~

**使用依赖倒转原则改进**

~~~ java
public class DependencyInversion {
    public static void main(String[] args) {
//        修改之后，客户端不需要改变
        Person p =new Person();
        p.receive(new Email());
        p.receive(new Wchat());

    }
}
interface Receiver{
//    定义一个返回消息的抽象方法，接口
    public String getInfo();
}
//具体类去实现接口
class Email implements Receiver{

    @Override
    public String getInfo() {
        return "电子邮件信息:hello word !";
    }
}

//现在增加微信的消息，很容易进行扩展
class Wchat implements Receiver{
    @Override
    public String getInfo() {
        return "微信信息:hello word !";
    }
}

class Person{
  //参数是一个接口，非常容易的扩展
    public void receive(Receiver r){
        System.out.println(r.getInfo());
    }
}
~~~

#### 依赖关系传递的三种方式和应用案例

> 1. 接口传递
>
> 2. 构造方法传递
>
> 3. `setter`方法传递

**代码说明**

~~~ java
public class DependencyPass {

    public static void main(String[] args) {
// TODO Auto-generated method stub ChangHong changHong = new ChangHong();
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.open(changHong);

//通过构造器进行依赖传递
        OpenAndClose openAndClose = new OpenAndClose(changHong);
        openAndClose.open();
//通过 setter 方法进行依赖传递
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.setTv(changHong);
        openAndClose.open();

    }
}

// 方式 1： 通过接口传递实现依赖
// 开关的接口

interface IOpenAndClose {
    public void open(ITV tv); //抽象方法,接收接口
}

interface ITV { //ITV 接口
    public void play();
}

class ChangHong implements ITV {

    @Override
    public void play() {
        // TODO Auto-generated method stub
        System.out.println("长虹电视机，打开");
    }

}

//// 实现接口
class OpenAndClose implements IOpenAndClose {
    public void open(ITV tv) {
        tv.play();
    }
}

// 方式 2: 通过构造方法依赖传递
interface IOpenAndClose {
    public void open(); //抽象方法
}

interface ITV { //ITV 接口
    public void play();
}

class OpenAndClose implements IOpenAndClose {
    public ITV tv; //成员

    public OpenAndClose(ITV tv) { //构造器
        this.tv = tv;
    }

    public void open() {
        this.tv.play();
    }
}

// 方式 3 ,  通过 setter 方法传递
interface IOpenAndClose {
    public void open(); // 抽象方法


    public void setTv(ITV tv);
}

interface ITV { // ITV 接口
    public void play();
}

class OpenAndClose implements IOpenAndClose {
    private ITV tv;

    public void setTv(ITV tv) {
        this.tv = tv;
    }


    public void open() {
        this.tv.play();
    }
}

class ChangHong implements ITV {
    @Override
    public void play() {
// TODO Auto-generated method stub
        System.out.println("长虹电视机，打开");
    }
}
~~~

#### 依赖倒转原则细节

1. 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好，也就是说子类的上一级最好是接口或者抽象类。
2. 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
3. 继承时遵循里氏替换原则

### 里式替换原则

#### oo中继承性的思考

- 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
- 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性（父类的变化会影响子类），如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
- 问题提出：在编程中，如何正确的使用继承? => 里氏替换原则

#### 基本介绍

1. 里氏替换原则`Liskov Substitution Principle`在 1988 年，由麻省理工学院的以为姓里的女士提出的。
2. 如果对每个类型为 `T1` 的对象` o1`，都有类型为` T2 `的对象 `o2`，使得以` T1 `定义的所有程序 `P `在所有的对象` o1 `都代换成 `o2 `时，程序` P `的行为没有发生变化，那么类型 `T2` 是类型 `T1 `的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
3. 在使用继承时，遵循里氏替换原则，**在子类中尽量不要重写父类的方法**
4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。.

**里式替换原则作用**

里氏替换原则的主要作用如下。 

1. 里氏替换原则是实现**开闭原则**的重要方式之一。
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

**里式替换原则实现**

里氏替换原则通俗来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能。**

也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

 根据上述理解，对里氏替换原则的定义可以总结如下： 

- 子类可以**实现**父类的抽象方法，但不能**覆盖**父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。

#### 案例演示

**代码说明**

~~~ java
public class LisKvo {
    public static void main(String[] args) {
        M m=new M();
        System.out.println("11-3="+m.functionn01(11,3));
        System.out.println("1-8="+m.functionn01(1,8));
        System.out.println("********************************");
        N n=new N();
        System.out.println("11-3="+n.functionn01(11,3));//本来要计算11-3
        System.out.println("1-8="+n.functionn01(1,8));//计算1-8,但是子类对父类方法重写，结果肯定错误
    }
}


class M{
    public int functionn01(int num1,int num2){
        return num1-num2;
    }
}

class N extends M{
    @Override
    public int functionn01(int num1, int num2) {
        return num1+num2;
    }
    public int function(int num1,int num2){
        return functionn01(num1,num2)+9;
    }
}
~~~

**解决方法**

- 我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候
- 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替.

**改进方案**

![1608441452055](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/131733-689100.png)

**代码改进**

~~~ java
public class LisKvo {
    public static void main(String[] args) {
        M m=new M();
        System.out.println("11-3="+m.functionn01(11,3));
        System.out.println("1-8="+m.functionn01(1,8));
        System.out.println("********************************");
        N n=new N();
//        因为N不在继承m，那么调用者不会再认为function01()是做减法的
        int num=n.function02(11,3);
        System.out.println("11+3="+num);
        System.out.println("1+8="+n.function02(1,8));
//        现在使用组合的方式还可以做减法
        System.out.println(n.function04(11,3));//8
    }
}

class Base{
//    吧更加基础的方法和属性写到基础类中

}

class M extends Base{
    public int functionn01(int num1,int num2){
        return num1-num2;
    }
}

class N extends Base{
//    如果N类要使用M类，就使用一个组合的关系
    private M m=new M();//形成组合关系
//    加入我们想使用M的方法,就用下面的操作
    public int function02(int num1,int num2){
        return num1+num2;
    }
    public int function03(int num1,int num2){
        return function02(num1,num2)+9;
    }
    public int function04(int num1,int num2){
        return m.functionn01(num1,num2);
    }
}
~~~

### 开闭原则

开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

#### 基本介绍

- 开闭原则（`Open Closed Principle`）是编程中最基础、最重要的设计原则
- 一个软件实体如类，模块和函数应该对**扩展开放**(**对提供方,增加功能**)，**对修改关闭**(对使用方不需要修改)。用抽象构建框架，用实现扩展细节。
- 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
- 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

**开闭原则的作用**

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 

1. 对软件测试的影响

 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 

2. 可以提高代码的可复用性

 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 

3. 可以提高软件的可维护性

 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

**开闭原则的实现**

- 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。
- 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

 #### 案例说明

![1608443054162](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/134415-356856.png)

**代码说明**

~~~ java
public class OcpDemo {
    public static void main(String[] args) {
        GraphicEditor g=new GraphicEditor();
        g.drawShape(new Rectangle());
        g.drawShape(new Circle());

    }
}

//这是一个用于绘图的类 [使用方]
class GraphicEditor {
    //接收 Shape 对象，然后根据 type，来绘制不同的图形
    public void drawShape(Shape s) {
        if (s.m_type == 1) drawRectangle(s);
        else if (s.m_type == 2) drawCircle(s);
        else if (s.m_type == 3) drawTriangle(s);
    }

    //绘制矩形
    public void drawRectangle(Shape r) {
        System.out.println(" 绘制矩形 ");
    }

    //绘制圆形
    public void drawCircle(Shape r) {
        System.out.println(" 绘制圆形 ");
    }

    //绘制三角形
    public void drawTriangle(Shape r) {
        System.out.println(" 绘制三角形 ");
    }
}

//Shape 类，基类
class Shape {
    int m_type;
}


class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }
}

class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }
}

//新增画三角形
class Triangle extends Shape {
    Triangle() {
        super.m_type = 3;
    }
}
~~~

1. 优点是比较好理解，简单易操作。

2. 缺点是违反了设计模式的` ocp` 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.

3. 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多,需要修改使用方。

#### 改进思路

思路：把创建 **`Shape`** 类做成抽象类，并提供一个抽象的 **`draw`** 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 `Shape`，并实现` draw `方法即可，使用方的代码就不需要修  ->                                                                                                                          满足了开闭原则

**代码实现**

~~~ java
public class OcpDemo {
    public static void main(String[] args) {
        GraphicEditor g=new GraphicEditor();
        g.drawShape(new Rectangle());
        g.drawShape(new Circle());
        g.drawShape(new Triangle());
        g.drawShape(new Other());
    }
}


//这是一个用于绘图的类 [使用方]
class GraphicEditor {
    //接收 Shape 对象，然后根据 type，来绘制不同的图形
    public void drawShape(Shape s) {
       s.draw();
    }
}

//Shape 类，基类
abstract class Shape {
    int m_type;
    public abstract void draw();
}


class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }

    @Override
    public void draw() {
        System.out.println("绘制矩形");
    }
}


class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }

    @Override
    public void draw() {
        System.out.println("绘制圆形");
    }
}


//新增画三角形
class Triangle extends Shape {
    Triangle() {
        super.m_type = 3;
    }

    @Override
    public void draw() {
        System.out.println("绘制三角形");
    }
}

class Other extends Shape{

    @Override
    public void draw() {
        System.out.println("绘制其他图形");
    }
}
~~~

- 经过上面的设计，我们在需要绘制其他图形时候，只需要继承shape然后实现方法即可，再使用方不需要修改代码。

### 迪米特法则

#### 基本介绍

1. 一个对象应该对其他对象保持最少的了解（这样耦合度比较低），类与类关系越密切，耦合度越大
2. 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息
3. 迪米特法则还有个更简单的定义：只与直接的朋友通信
4. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

**迪米特法则的优点**

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 

**迪米特法则的实现**

从迪米特法则的定义和特点可知，它强调以下两点： 

1. 从依赖者的角度来说，只依赖应该依赖的对象。
2. 从被依赖者的角度说，只暴露应该暴露的方法。

 所以，在运用迪米特法则时要注意以下 6 点。 

1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
2. 在类的结构设计上，尽量降低类成员的访问权限。
3. 在类的设计上，优先考虑将一个类设置成不变类。
4. 在对其他类的引用上，将引用其他对象的次数降到最低。
5. 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
6. 谨慎使用序列化（Serializable）功能。

#### 应用案例

有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id

**代码说明**

~~~ java
public class Demeter {
    public static void main(String[] args) {
//创建了一个 SchoolManager 对象
        SchoolManager schoolManager = new SchoolManager();
//输出学院的员工 id  和	学校总部的员工信息
        schoolManager.printAllEmployee(new CollegeManager());

    }
}

//学校总部员工类
class Employee {
    private String id;
    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//学院的员工类
class CollegeEmployee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//管理学院员工的管理类
class CollegeManager {
    //返回学院的所有员工
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) { //这里我们增加了 10 个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
}

//学校管理类

//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager {
    //返回学校总部的员工
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();

        for (int i = 0; i < 5; i++) { //这里我们增加了 5 个员工到 list
            Employee emp = new Employee();
            emp.setId("学校总部员工 id= " + i);
            list.add(emp);
        }
        return list;
    }

    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager sub) {

        //分析问题
        //1. 这 里 的  CollegeEmployee 不是	SchoolManager 的直接朋友
        //2. CollegeEmployee 是以局部变量方式出现在 SchoolManager


        //3. 违反了 迪米特法则
        //获取到学院员工
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("------------学院员工------------");
        for (
                CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }

        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}
~~~

- 前面设计的问题在于 `SchoolManager `中，**`CollegeEmployee`** 类并不是 **`SchoolManager`** 类的直接朋友 (分析)

- 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合

**代码改进**

~~~ java
public class Demeter {
    public static void main(String[] args) {
//创建了一个 SchoolManager 对象
        SchoolManager schoolManager = new SchoolManager();
//输出学院的员工 id  和	学校总部的员工信息
        schoolManager.printAllEmployee(new CollegeManager());

    }
}

//学校总部员工类
class Employee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//学院的员工类
class CollegeEmployee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

//管理学院员工的管理类
class CollegeManager {
    //返回学院的所有员工
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) { //这里我们增加了 10 个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
  //封装的过程，对外只提供接口
    public void printEmployee(){
//        解决方法：
//        1 将输出学院员工的方法封装到CollegeManager类里面
        List<CollegeEmployee> list1 = this.getAllEmployee();
        System.out.println("------------学院员工------------");
        for (
                CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
    }
}

//学校管理类
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager {
    //返回学校总部的员工
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();

        for (int i = 0; i < 5; i++) { //这里我们增加了 5 个员工到 list
            Employee emp = new Employee();
            emp.setId("学校总部员工 id= " + i);
            list.add(emp);
        }
        return list;
    }

    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager sub) {
        sub.printEmployee();//对过程进行封装
        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}
~~~

#### 迪米特法则细节

- 迪米特法则的核心是**降低类之间的耦合**

- 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要**求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系**

### 合成复用原则（Composite Reuse Principle）

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

**合成复用原则重要性**

通常类的复用分为**继承复用和合成复用**两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

**实现方法**

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

#### 基本介绍

原则是尽量使用合成/聚合的方式，而不是使用继承

![1608446753839](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/144555-649120.png)

类B想使用类A中的方法，如果通过继承的方式，那么耦合度会很高，通过聚合的方式，可以降低耦合度，有三种方式，第一种是作为函数的参数传递，调用A的方法，第二种是作为属性存在，调用A的方法，第三种是使用Set()方法。

### 设计模式的核心思想

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

2. 针对接口编程，而不是针对实现编程。

3. 为了交互对象之间的松耦合设计而努力（高内聚，低耦合）

## UML类图

### UML基本介绍

1. `UML——Unified modeling language UML `(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
2. `UML` 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图:

### UML图分类

1. 用例图(use case)

2. 静态结构图：类图、对象图、包图、组件图、部署图

3. 动态行为图：交互图（时序图与协作图）、状态图、活动图

> 类图是描述类与类之间的关系的，是 `UML `图中最核心的

**类图用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。**

**类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。**

### 类图—依赖关系（Dependence）

只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。

**代码说明**

~~~ java
public class Dependence {
    private PersonDao personDao;
    public void save(Person person){}
    public IDCard getIDCard(Integer personID){
        return null;
    }
    public void modify(){
        Department department=new Department();
    }
    public static void main(String[] args) {

    }
}
class PersonDao{}

class IDCard{ }

class Person{}

class Department{}

~~~

**类图**

![1608448604981](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/151646-59730.png)

- 在这里也可以把依赖换成聚合关系。

**小结**

> 1)	类中用到了对方
>
> 2) 	如果是类的成员属性
>
> 3)	如果是方法的返回类型
>
> 4)	是方法接收的参数类型
>
> 5)	方法中使用到

### 类图—泛化关系 (generalization）

泛化关系实际上就是继承关系，他是依赖关系的特例

**代码说明**

~~~~ java
public abstract class DaoSupport{ public void save(Object entity){
}
public void delete(Object id){
}

}

public class PersonServiceBean extends Daosupport{
}

~~~~

**类图**

![1608448892685](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/152139-910427.png)

**小结**

> 1)      泛化关系实际上就是继承关系
>
> 2)      如果 A 类继承了 B 类，我们就说 A 和 B 存在泛化关系

### 类图—实现关系（Implementation）

实现关系实际上就是 **A** 类实现 **B** 接口，他是依赖关系的特例

**代码说明**

~~~ java
public interface PersonService { public void delete(Interger id);
}
public class PersonServiceBean implements PersonService { 
  public void delete(Interger id){}
}

~~~

**类图**

![1608449016439](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/152338-893737.png)

### 类图—关联关系（Association）

![1608451495287](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/24/165124-607443.png)

### 类图—聚合关系（Aggregation）

**介绍**

聚合关系（`Aggregation`）表示的是**整体和部分**的关系，**整体与部分可以分开**。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。

如：一台电脑由键盘(`keyboard`)、显示器(`monitor`)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：

**代码说明**

~~~ java
public class Computer {
    private Monitor monitor;
    private Mouse mouse;

    public void setMonitor(Monitor monitor) {
        this.monitor = monitor;
    }

    public void setMouse(Mouse mouse) {
        this.mouse = mouse;
    }
}
class Monitor{}
class Mouse{}
~~~

**类图说明**

![1608452075089](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/161436-77360.png)

### 类图—组合关系（Composition）

**基本介绍**

组合关系：也是整体与部分的关系，**但是整体与部分不可以分开**

- 再看一个案例：在程序中我们定义实体：`Person `与 `IDCard`、`Head`, 那么 `Head` 和 `Person` 就是 组合，`IDCard` 和`Person `就是聚合。
-  但是如果在程序中 `Person` 实体中定义了对` IDCard` 进行级联删除，即删除 `Person` 时连同` IDCard` 一起删除，那么 `IDCard ` 和 `Person` 就是组合了.

**代码说明**

~~~ java
public class Person{ 
  private IDCard card;//身份证可能丢失，所以是聚合关系
	private Head head = new Head();//组合关系
}
class IDCard{} 
class Head{}
~~~

**类图**

![1608452386196](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/20/161948-221855.png)

## 设计模式

### 设计模式介绍

1. 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

2. 设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度

### 设计模式的分类

设计模式分为三种类型，共 **23** 种

- 创建型模式：单例模式、抽象工厂模式、原型模式（克隆对象）、建造者模式、工厂模式。

- 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。

- 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（`Interpreter `模式）、状态模式、策略模式、职责链模式(责任链模式)。

> 注意：不同的书籍上对分类和名称略有差别
>
> - 创建型模式：主要讲如何创建一个对象。
> - 结构性模式：是站在软件结构角度思考问题，如何设计软件结构才具有更好的可扩展性，更加容易维护。
> - 行为型模式：站在方法的角度思考，如何设计方法更加的合理

### 单例设计模式

#### 单例设计模式的介绍

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在**一个对象实例**， 并且该类只提供一个取得其对象实例的方法(**静态方法**)。

比如 `Hibernate` 的` SessionFactory`，它充当数据存储源的代理，并负责创建 `Session` 对象。`SessionFactory `并不是轻量级的，一般情况下，一个项目通常只需要一个 `SessionFactory `就够，这是就会使用到单例模式。

**单例模式的3个特点**

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3.  单例类对外提供一个访问该单例的全局访问点。

**类图**

![1609052315402](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/145837-777559.png)

#### 单例模式的实现

单例模式有八种方式：

1. 饿汉式**(**静态常量)
2. 饿汉式（静态代码块）
3. 懒汉式(线程不安全)
4. 懒汉式(线程安全，同步方法）
5. 懒汉式(线程安全，同步代码块)
6. 双重检查
7. 静态内部类
8. 枚举

##### 饿汉式（静态常量）

**代码实现**

~~~ java
public class Singleton01 {
    public static void main(String[] args) {
        Singleton singleton=Singleton.getInstance();
        Singleton singleton1=Singleton.getInstance();
//        判断获取的两个实例是否是同一个实例
        System.out.println(singleton == singleton1);//true
//        从哈希码方面判断，也是同一个对象
        System.out.println(singleton.hashCode());
        System.out.println(singleton1.hashCode());
    }
}


//饿汉式，使用静态变量
class Singleton{
//    1 提供一个私有的构造方法，外部不可以new
    private Singleton(){

    }
//    2 提供一个对象实例
    private  final static Singleton instance=new Singleton();
//    提供一个共有的静态方法，用于返回实例对象
    public static Singleton getInstance(){
        return instance;
    }
~~~

**优缺点说明**

**优点：**

1. 这种写法比较简单，就是在**类装载的时候就完成实例化。避免了线程同步问题。**

**缺点：**

1. 在类装载的时候就完成实例化，没有达到` Lazy Loading `(懒加载)的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
2. 这种方式基于 `classloder `机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 `getInstance` 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 `instance` 就没有达到` lazy loading `的效果

> 结论：**这种单例模式可用，可能造成内存浪费**

##### 饿汉式（静态代码块）

**代码实现**

~~~ java
public class Singleton02 {
    public static void main(String[] args) {
        Singleton1 singleton=Singleton1.getInstance();
        Singleton1 singleton1=Singleton1.getInstance();
//        判断获取的两个实例是否是同一个实例
        System.out.println(singleton == singleton1);//true
//        从哈希码方面判断，也是同一个对象
        System.out.println(singleton.hashCode());
        System.out.println(singleton1.hashCode());
    }
}

//饿汉式，使用静态变量
class Singleton1{
    //    1 提供一个私有的构造方法，外部不可以new
    private Singleton1(){

    }
    //    2 提供一个对象实例
    private  final static Singleton1 instance;
//    把单例对象的创建放在静态代码块中
    static {
        instance=new Singleton1();
    }
    //    提供一个共有的静态方法，用于返回实例对象
    public static Singleton1 getInstance(){
        return instance;
    }
}
~~~

**优缺点分析**

1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在**类装载**的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

> 结论：**这种单例模式可用，但是可能造成内存浪费（单例对象被创建，但是又没有使用的情况下）**

##### 懒汉式（线程不安全）

**代码实现**

~~~ java
public class Singleton03Test {
    public static void main(String[] args) {
        Singleton2 singleton=Singleton2.getInstance();
        Singleton2 singleton1=Singleton2.getInstance();
//        判断获取的两个实例是否是同一个实例
        System.out.println(singleton == singleton1);//true
//        从哈希码方面判断，也是同一个对象
        System.out.println(singleton.hashCode());
        System.out.println(singleton1.hashCode());
    }
}

class Singleton2{
    private static Singleton2 instance;
//    创建私有的构造方法
    private Singleton2(){}

//    对外提供一个共有的方法，当需要单例对象的时候，才创建对象,既懒汉式
    public static Singleton2 getInstance(){
        if(instance == null){
            instance=new Singleton2();
        }
        return instance;
    }
}
~~~

**优缺点分析**

1. 起到了 **`Lazy Loading`** 的效果，但是只能在单线程下使用。

2. 如果在多线程下，一个线程进入了 `if (singleton == null)`判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

> 结论：**在实际开发中，不要使用这种方式.**

##### 懒汉式（线程安全1）

**代码实现**

~~~ java
public class Singleton03Test {
    public static void main(String[] args) {
        Singleton2 singleton=Singleton2.getInstance();
        Singleton2 singleton1=Singleton2.getInstance();
//        判断获取的两个实例是否是同一个实例
        System.out.println(singleton == singleton1);//true
//        从哈希码方面判断，也是同一个对象
        System.out.println(singleton.hashCode());
        System.out.println(singleton1.hashCode());
    }
}

class Singleton2{
    private static Singleton2 instance;
//    创建私有的构造方法
    private Singleton2(){}

//    对外提供一个共有的方法，当需要单例对象的时候，才创建对象,既懒汉式
//    添加同步锁，解决线程安全问题
    public static synchronized Singleton2 getInstance(){
        if(instance == null){
            instance=new Singleton2();
        }
        return instance;
    }
}
~~~

**优缺点分析**

1. 解决了线程安全问题

2. 效率太低了，每个线程在想获得类的实例时候，执行` getInstance()`方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接` return `就行了。方法进行同步效率太低

> 结论：在实际开发中，不推荐使用这种方式

##### 懒汉式（线程安全2）

**代码实现**

~~~ java
public class Singleton03Test {
    public static void main(String[] args) {
        Singleton2 singleton=Singleton2.getInstance();
        Singleton2 singleton1=Singleton2.getInstance();
//        判断获取的两个实例是否是同一个实例
        System.out.println(singleton == singleton1);//true
//        从哈希码方面判断，也是同一个对象
        System.out.println(singleton.hashCode());
        System.out.println(singleton1.hashCode());
    }
}

class Singleton2{
    private static Singleton2 instance;
//    创建私有的构造方法
    private Singleton2(){}

//    对外提供一个共有的方法，当需要单例对象的时候，才创建对象,既懒汉式
//    添加同步锁，解决线程安全问题
    public static  Singleton2 getInstance(){
        if(instance == null){
           synchronized (Singleton2.class){
               instance=new Singleton2();
           }
        }
        return instance;
    }
}
~~~

**优缺点**

- 这种实现方式不能不能起到线程同步的作用，

> 结论：在实际开发中，不推荐使用这种方式

##### 双重检查

**代码实现**

~~~ java
public class Singleton04Test {
    public static void main(String[] args) {
        Singleton5 singleton5=Singleton5.getInstance();
        Singleton5 singleton51=Singleton5.getInstance();
        System.out.println(singleton5 == singleton51);// true

    }
}

class Singleton5{
//    volatile关键字，保证对内存可见，也就是对象一旦改变。他会把这种改变立即同步到内存中
    private static volatile Singleton5 instance;

//    私有的构造方法
    private Singleton5(){}

//加入双重检查的代码，解决线程安全问题，同时解决懒加载问题
    public static Singleton5 getInstance(){
        if(instance == null){//只要单例对象不空，其余的线程就不会做线程安全同步的检测，提高效率
//            下面的操作是原子操作
            synchronized (Singleton5.class){//解决线程安全问题
                if(instance == null){
                    instance=new Singleton5();//懒加载问题
                }
            }
        }
        return instance;
    }
}
~~~

**优缺点分析**

1. `Double-Check `概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 `if (singleton == null)`检查，这样就可以保证线程安全了。

2. 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.

3. 线程安全；延迟加载；效率较高

> **结论：在实际开发中，推荐使用这种单例设计模式**

##### 静态内部类

静态内部类的特点：当静态内部类的外部类被装载的时候，静态内部类并不会被装载

在调用静态内部类的静态对象的时候，会导致静态内部类进行装载，并且装载时是线程安全的。因此不会有线程安全性问题。所以通过静态内部类，可以保证懒加载，还可以保证线程安全问题。

**代码说明**

~~~ java
public class Singleton05Test {
    public static void main(String[] args) {
        Singleton6 singleton6=Singleton6.getInstance();
        Singleton6 singleton61=Singleton6.getInstance();
        System.out.println(singleton6 == singleton61);

    }
}


//推荐使用
class Singleton6{

    private Singleton6(){}

//    静态内部类
    private static class SingletonInstance{
        private static final Singleton6 INSTANCE=new Singleton6();
    }
//    提供一个静态方法，直接返回属性INSTANCE
    public static Singleton6 getInstance(){
        return SingletonInstance.INSTANCE;
    }

}
~~~

**优缺点**

1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。

2. 静态内部类方式在` Singleton6` 类被装载时并不会立即实例化，而是在需要实例化时，调用 `getInstance` 方法，才会装载 `SingletonInstance `类，从而完成 `Singleton `的实例化。

3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，`JVM `帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

> 结论：**推荐使用.**

##### 枚举

**代码说明**

~~~ java
public class Singleton06Test {
    public static void main(String[] args) {
        Singleton7 singleton7=Singleton7.INSTANCE;
        Singleton7 singleton71=Singleton7.INSTANCE;
        System.out.println(singleton7 == singleton71);//true
        singleton7.method();//say hello

    }
}

enum Singleton7{
    INSTANCE;// 属性
    public void method(){
        System.out.println("say hello");
    }
}
~~~

**优缺点**

1. 这借助` JDK1.5 `中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。

2. 这种方式是 **`Effective Java`** 作者 **`Josh Bloch`**  提倡的方式

> 结论：推荐使用

##### 单例模式在jdk源码中的分析

**源码分析**

~~~ java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    /**
     * Returns the runtime object associated with the current Java application.
     * Most of the methods of class <code>Runtime</code> are instance
     * methods and must be invoked with respect to the current runtime object.
     *
     * @return  the <code>Runtime</code> object associated with the current
     *          Java application.
     */
    public static Runtime getRuntime() {
        return currentRuntime;
    }

    /** Don't let anyone else instantiate this class */
    private Runtime() {}//私有构造
}
~~~

Runtime实际上使用的是饿汉式

#### 单例模式注意事项

1. 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 `new`
3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、**session** 工厂等)

#### 单例模式的应用场景

对于 Java来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。

- 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
- 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
- 频繁访问数据库或文件的对象。
- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

#### 单例模式优缺点分析

**优点**

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。
- 可以避免对资源的多重占用。
- 单例模式设置全局访问点，可以优化和共享资源的访问。

**缺点**

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

### 简单工厂模式

**需求**

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1. 披萨的种类很多(比如 GreekPizz、CheesePizz 等)

2. 披萨的制作有 prepare，bake, cut, box

3. 完成披萨店订购功能。

#### 传统方式解决

传统解决方式定义一个抽象的pizza类，然后使各种披萨都继承与抽象披萨类，实现抽象类中的抽象方法即可。额外写一个订购类，专门用来管理订购的各种披萨。

![1608710239502](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/155721-22953.png)

**代码说明**

~~~ java
public class PizzaStore {
    public static void main(String[] args) throws IOException {
        new OrderPizza();

    }
}
class OrderPizza{
    public OrderPizza() throws IOException {
        Pizza pizza=null;
        String PizzaType;//订购披萨的类型
        do{
            PizzaType=getType();
            if(PizzaType.equals("CheesePizza")){
                pizza=new CheesePizza();
                pizza.setName("奶酪披萨");
            }else if(PizzaType.equals("GreekPizza")){
                pizza=new GreekPizza();
                pizza.setName("希腊披萨");
            }else {
                break;
            }
//            输出披萨制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.boxing();

        }while (true);
    }

//    获取用户想订购披萨的种类
    public String  getType() throws IOException {
        BufferedReader b=new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入你想订购的披萨种类:");
        String type=b.readLine();
        return type;
    }
}

abstract class Pizza{
    protected String name;

    public Pizza(){}

    public Pizza(String name) {
        this.name = name;
    }
//准备做pizza的原材料，因此做成抽象方法
    public abstract void prepare();

    public void bake(){
        System.out.println(name+"  baking ......");
    }

    public void cut(){
        System.out.println(name+"  cuting.......");
    }

    public void boxing(){
        System.out.println(name+"  boxing.....");
    }

    public void setName(String name) {
        this.name = name;
    }
}

class CheesePizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("给制作奶酪披萨准备原材料。。。。。");
    }
}

class GreekPizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("给制作希腊披萨准备原材料。。。。。");
    }
}
~~~

**优缺点分析**

1. 优点是比较好理解，简单易操作。

2. 缺点是违反了设计模式的 **ocp** 原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.
3. 比如我们这时要新增加一个**Pizza**的种类**(Pepper** 披萨**)**，我们需要做如下修改. 

**如果要增加披萨**：我们就需要进行下面修改，新增加披萨类继承于Pizza类，而对于OrderPizza类，我们也需要进行修改，如果有多个预定披萨的类，那么我们就要进行多处的修改，所以没有遵从ocp原则。

![1608716406427](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/174009-212058.png)

**改进思路分析**

- 分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。

- 思路：把创建 **Pizza** 对象封装到一个类中，这样我们有新的 **Pizza** 种类时，只需要修改该类就可，其它有创建到 Pizza对象的代码就不需要修改了.-> 简单工厂模式


#### 简单工厂介绍

简单工厂模式是**属于创建型模式**，是工厂模式的一种。**简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。**简单工厂模式是工厂模式家族中最简单实用的模式

简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)

在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.

**简单工厂模式**

简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类SimpleFactory，封装创建对象的代码。由SimpleFectory来维护我们需要创建的披萨种类，并且实例化。

![1608718514672](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/181515-63110.png)

**代码实现**

~~~ java
public class PizzaStore {
    public static void main(String[] args) throws IOException {
//        使用简单工厂模式创建披萨
        new OrderPizza(new SimpleFactory());
    }
}

//此类中的方法封装了实例化披萨的过程
class SimpleFactory{
//    根据PizzaType，返回一个pizza的实例
    public Pizza createPizza(String PizzaType){
        Pizza pizza=null;
        if(PizzaType.equals("CheesePizza")){
            pizza=new CheesePizza();
            pizza.setName("奶酪披萨");
        }else if(PizzaType.equals("GreekPizza")){
            pizza=new GreekPizza();
            pizza.setName("希腊披萨");
        }
        return pizza;
    }
}

class OrderPizza{
//    定义一个简单工厂的实例
    SimpleFactory simpleFactory;
    Pizza pizza=null;

    /**
     * 构造器方法
     * @param simpleFactory 简单工厂对象
     * @throws IOException
     */
    public OrderPizza(SimpleFactory simpleFactory) throws IOException {
    setFactory(simpleFactory);
    }

    public void setFactory(SimpleFactory simpleFactory) throws IOException {
        String orderType="";
        this.simpleFactory=simpleFactory;
        do {
            orderType=getType();
            pizza=this.simpleFactory.createPizza(orderType);
            if(pizza != null){
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.boxing();
            }else {
                System.out.println("订购披萨失败");
                break;
            }

        }while (true);

    }

//    获取用户想订购披萨的种类
    public String  getType() throws IOException {
        BufferedReader b=new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入你想订购的披萨种类:");
        String type=b.readLine();
        return type;
    }
}

abstract class Pizza{
    protected String name;

    public Pizza(){}

    public Pizza(String name) {
        this.name = name;
    }
//准备做pizza的原材料，因此做成抽象方法
    public abstract void prepare();

    public void bake(){
        System.out.println(name+"  baking ......");
    }

    public void cut(){
        System.out.println(name+"  cuting.......");
    }

    public void boxing(){
        System.out.println(name+"  boxing.....");
    }

    public void setName(String name) {
        this.name = name;
    }
}

class CheesePizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("给制作奶酪披萨准备原材料。。。。。");
    }
}

class GreekPizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("给制作希腊披萨准备原材料。。。。。");
    }
}
~~~

对于使用SimpleFactory去维护具体创建的披萨的类型，如果我们再想添加一个pizza时，只需要修改SimpleFactory即可，不需要再去修改OrderPizza类，因为真正实例化披萨的过程是在工厂方法中，使用简单工厂方法扩展时候，我们只需要修改一处即可。

![1608718998668](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/182327-986701.png)

#### 工厂方法模式

**看一个新的需求**

披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。

**思路一**

使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好，如果我们有多个地方的披萨，那么我们创建的工厂也很多。

#### 工厂方法介绍

1. 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。

2. 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

**工厂方法应用案例图解**

![1608727263778](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/204107-842741.png)

**代码实现**

~~~ java
public class factoryMethod {
    public static void main(String[] args) throws IOException {
        new BJorderPizza();
    }
}

class LDorderPizza extends  OrderPizza{


    public LDorderPizza() throws IOException {
    }

    @Override
    public Pizza createPizza(String PizzaType) {
        Pizza pizza=null;
        if(PizzaType.equals("LDCheesePizza")){
            pizza=new LDCheesePizza();
        }else if(PizzaType.equals("LDGreekPizza")){
            pizza=new LDGreekPizza();
        }
        return pizza;
    }
}

class BJorderPizza extends  OrderPizza{


    public BJorderPizza() throws IOException {
    }

    @Override
    public Pizza createPizza(String PizzaType) {
        Pizza pizza=null;
        if(PizzaType.equals("BJCheesePizza")){
            pizza=new BJCheesePizza();
        }else if(PizzaType.equals("BJGreekPizza")){
            pizza=new BJGreekPizza();
        }
        return pizza;
    }
}



abstract class OrderPizza{
//    定义一个抽象方法 createpizza()，让工厂自己去实现
    public abstract Pizza createPizza(String PizzaType);

    public OrderPizza() throws IOException {
        Pizza pizza = null;
        String PizzaType;//订购披萨的类型
        do {
            PizzaType = getType();
            pizza = createPizza(PizzaType);//抽象方法，需要子类实现
//            输出披萨制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.boxing();

        } while (true);
    }

    //    获取用户想订购披萨的种类
    public String  getType() throws IOException {
        BufferedReader b=new BufferedReader(new InputStreamReader(System.in));
        System.out.println("请输入你想订购的披萨种类:");
        String type=b.readLine();
        return type;
    }
}

abstract class Pizza{
    protected String name;

    public Pizza(){}

    public Pizza(String name) {
        this.name = name;
    }
    //准备做pizza的原材料，因此做成抽象方法
    public abstract void prepare();

    public void bake(){
        System.out.println(name+"  baking ......");
    }

    public void cut(){
        System.out.println(name+"  cuting.......");
    }

    public void boxing(){
        System.out.println(name+"  boxing.....");
    }

    public void setName(String name) {
        this.name = name;
    }
}

class BJCheesePizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("北京的BJCheesePizza");
    }
}

class LDGreekPizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("伦敦的LDGreekPizza");
    }
}

class BJGreekPizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("北京的LDGreekPizza");
    }
}
class LDCheesePizza extends Pizza{

    @Override
    public void prepare() {
        System.out.println("伦敦的BJCheesePizza");
    }
}
~~~

#### 抽象工厂模式

**抽象工厂模式介绍**

1. 抽象工厂模式：定义了一个 **interface** 用于创建相关或有依赖关系的对象簇，而无需指明具体的类

2. 抽象工厂模式可以将**简单工厂模式和工厂方法模式**进行整合。

3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。

4. 将工厂抽象成两层，**AbsFactory(**抽象工厂**)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

**类图**

![1608727398787](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/23/204320-947218.png)

**代码说明**

~~~ java
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        new OrderPizza1(new BJorderPizza1());
    }
}

class OrderPizza1{

  AbstractFactory abstractFactory;
    public OrderPizza1(AbstractFactory abstractFactory)  {
        setFactory(abstractFactory);
    }
    
    private void setFactory(AbstractFactory abstractFactory)  {
        Pizza1 pizza1=null;
        String Pizza1Type="";
        this.abstractFactory=abstractFactory;
        do {
            Pizza1Type=getType();
            pizza1=abstractFactory.createPizza(Pizza1Type);
            if(pizza1 != null){
                //            输出披萨制作过程
                pizza1.prepare();
                pizza1.bake();
                pizza1.cut();
                pizza1.boxing();
            }else {
                System.out.println("披萨订购失败");
                break;
            }
        }while (true);

    }
    //    获取用户想订购披萨的种类
    public String  getType() {
        String type=" ";
      try {
          BufferedReader b=new BufferedReader(new InputStreamReader(System.in));
          System.out.println("请输入你想订购的披萨种类:");
         type=b.readLine();
      }catch (Exception e){
          e.printStackTrace();
      }
        return type;
    }
}


interface AbstractFactory{
//    让下面工厂的子类具体实现
    public Pizza1 createPizza(String PizzaType);

}

class LDorderPizza1 implements AbstractFactory{

    @Override
    public Pizza1 createPizza(String Pizza1Type) {
        System.out.println("使用抽象工厂模式");
        Pizza1 Pizza1=null;
        if(Pizza1Type.equals("LDCheesePizza1")){
            Pizza1=new LDCheesePizza1();
        }else if(Pizza1Type.equals("LDGreekPizza1")){
            Pizza1=new LDGreekPizza1();
        }
        return Pizza1;
    }
}

class BJorderPizza1 implements AbstractFactory{

    @Override
    public Pizza1 createPizza(String Pizza1Type) {
        System.out.println("使用抽象工厂模式");
        Pizza1 Pizza1=null;
        if(Pizza1Type.equals("BJCheesePizza1")){
            Pizza1=new BJCheesePizza1();
        }else if(Pizza1Type.equals("BJGreekPizza1")){
            Pizza1=new BJGreekPizza1();
        }
        return Pizza1;
    }
}

abstract class Pizza1{
    protected String name;

    public Pizza1(){}

    public Pizza1(String name) {
        this.name = name;
    }
    //准备做Pizza1的原材料，因此做成抽象方法
    public abstract void prepare();

    public void bake(){
        System.out.println(name+"  baking ......");
    }

    public void cut(){
        System.out.println(name+"  cuting.......");
    }

    public void boxing(){
        System.out.println(name+"  boxing.....");
    }

    public void setName(String name) {
        this.name = name;
    }
}

class BJCheesePizza1 extends Pizza1{

    @Override
    public void prepare() {
        System.out.println("北京的BJCheesePizza1");
    }
}

class LDGreekPizza1 extends Pizza1{

    @Override
    public void prepare() {
        System.out.println("伦敦的LDGreekPizza1");
    }
}

class BJGreekPizza1 extends Pizza1{

    @Override
    public void prepare() {
        System.out.println("北京的LDGreekPizza1");
    }
}
class LDCheesePizza1 extends Pizza1{

    @Override
    public void prepare() {
        System.out.println("伦敦的BJCheesePizza1");
    }
}
~~~

### 原型模式

#### 克隆羊

现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10

只羊。

#### 传统解决方式

**思路分析**

![1608790392461](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/24/141315-972683.png)

**代码实现**

~~~ java
public class SheepDemo{
    public static void main(String[] args) {
        Sheep sheep=new Sheep("tom",5,"black");
        Sheep sheep1=new Sheep(sheep.getName(),sheep.getAge(), sheep.getColor());
      //在这里可以获取多个克隆的对象
    }

}

class Sheep {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getColor() {
        return color;
    }
}

~~~

**传统方法的优缺点**

1. 优点是比较好理解，简单易操作。

2. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低

3. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活

4. 改进的思路分析

- 思路：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力  =>原型模式

#### 原型模式介绍

原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根**本无须知道对象创建的细节。**

**总的来说分三点：**

1. 原型模式(Prototype 模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
3. 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象**.clone**()
4. **默认的克隆方法会对字符串和基本数据类型进行拷贝**

**类图说明**

![1608791575540](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/24/143257-798291.png)

1. Prototype : 原型类，声明一个克隆自己的接口

2. ConcretePrototype: 具体的原型类,  实现一个克隆自己的操作

3. Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）

**代码说明**

~~~ java
public class SheepDemo{
    public static void main(String[] args) {
        Sheep sheep=new Sheep("tom",5,"black");
//        使用圆形方法进行克隆
        Sheep sheep1=(Sheep)sheep.clone();
        System.out.println(sheep);
        System.out.println(sheep1);
        
    }

}

class Sheep  implements Cloneable{
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getColor() {
        return color;
    }

//    克隆该实例，使用默认的方法进行克隆
    @Override
    protected Object clone() {
        Sheep sheep=null;
       try{
           sheep=(Sheep)super.clone();
       }catch (Exception e){
           e.printStackTrace();
       }
        return sheep;
    }
}
~~~

#### 浅拷贝

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行**引用传递**，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
3. 前面我们克隆羊就是浅拷贝
4. 浅拷贝是使用默认的 clone()方法来实现

~~~ java
sheep = (Sheep) super.clone();
~~~

#### 深拷贝

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象**(**包括对象的引用类型**)**进行拷贝
3. 深拷贝实现方式 1：**重写 clone 方法来实现深拷贝**
4. 深拷贝实现方式 2：**通过对象序列化实现深拷贝(推荐)**

#### 原型模型优缺点

**优点**

- Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
- 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

**缺点**

- 需要为每一个类都配置一个 clone 方法
- clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

**模式类图**

![1609052817652](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/150658-107745.png)

**模式角色说明**

原型模式包含以下主要角色。 

1. 抽象原型类：规定了具体原型对象必须实现的接口。java中的克隆接口。
2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象，继承与克隆类的具体类。
3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

> Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。

#### 原型模型应用场景

原型模式通常适用于以下场景。 

- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
- 创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。

### 建造者模式

#### 需求

1. 需要建房子：这一过程为打桩、砌墙、封顶

2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.

3. 请编写程序，完成需求.

#### 传统方式解决盖房子

**类图**

![1609045604038](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/130645-355053.png)

**代码实现**

~~~ java
public class BuilderDemo {
    public static void main(String[] args) {
//        现在创建普通房子的实例
        CommonHouse commonHouse = new CommonHouse();
        commonHouse.build();

    }
}
//抽象的房子类
abstract class AbstractHouse{
    public abstract void buildBasic();
    public abstract void buildWall();
    public abstract void roofed();

//    具体盖房子的步骤
    public void build(){
        buildBasic();
        buildWall();
        roofed();
    }
}

class CommonHouse extends AbstractHouse{

    @Override
    public void buildBasic() {
        System.out.println("给普通房子打地基");
    }

    @Override
    public void buildWall() {
        System.out.println("给普通房子砌墙");
    }

    @Override
    public void roofed() {
        System.out.println("给普通房子修屋顶");
    }
}
~~~

**优缺点分析**

1. 优点是比较好理解，简单易操作。
2. 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。
3. 解决方案：将产品和产品建造过程解耦  =>  建造者模式.

#### 建造者模式的基本介绍

1. 建造者模式（**Builder Pattern**） 又叫**生成器模式**，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
2. 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。
3. 建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

**类图说明**

![1609051292772](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/144135-911206.png)

#### 建造者模式的基本角色

1. Product（产品角色）： 一个具体的产品对象。

2. Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 **接口/抽象类。**，抽象出建造的流程，不用考虑细节问题。
3. `ConcreteBuilder`（具体建造者）： 实现接口，构建和装配各个部件。(就相当于我们的房子，实现具体的建造细节)

4. Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

**建造者模式原理类图**

![1609046500552](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/132143-951061.png)

- `concreteBuilder`就是具体的建造者，也就是具体需要建造的房子。
- Builder是抽象的类或者是接口，只管理房子的建造过程，不会考虑具体的实现细节，是一个抽象的缓冲层。

#### 建造者模式实现盖房子

需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成

**类图实现**

![1609047089925](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/133133-673200.png)

- `HouseBuilder`：就是我们的抽象建造者

- CommonHouse,HighBuilding,OtherHouse是我们具体的建造者

- House:代表我们具体的产品

- HouseDirector:代表我们的指挥者

**代码实现**

~~~ java
public class BuilderHouse4 {
    public static void main(String[] args) {
//        客户端进行调用
//       修建普通的房子
        Commonhouse commonhouse=new Commonhouse();
//        修建房子的指挥者
        HouseDirector houseDirector=new HouseDirector(commonhouse);
//        返回修建好的房子
        House house=houseDirector.constructHouse();
        System.out.println(house);


//        修建高楼
        HighBuilding highBuilding=new HighBuilding();
//        重置指挥者
        houseDirector.setHouseBuilder(highBuilding);
        House house1 = houseDirector.constructHouse();
        System.out.println(house1);
    }
}


/**
 * 具体建造房子的流程，最后返回建造好的房子即可
 */
class HouseDirector{
//    聚合操作
    HouseBuilder houseBuilder=null;

//    通过构造器方法传入houseBuilder

    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

//    通过seter方法传入houseBuilder

    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

//    如何处理建造房子的流程，交给指挥者
    public House constructHouse(){
        houseBuilder.buildBasic();
        houseBuilder.buildWall();
        houseBuilder.roofed();
        return houseBuilder.getHouse();
    }
}

class HighBuilding extends HouseBuilder{

    @Override
    public void buildBasic() {
        System.out.println("高楼房子打地基");
    }

    @Override
    public void buildWall() {
        System.out.println("高楼房子修墙");
    }

    @Override
    public void roofed() {
        System.out.println("高楼房子修屋顶");
    }
}



/**
 * 下面开始建造具体的房子
 *
 */
class Commonhouse extends HouseBuilder{

    @Override
    public void buildBasic() {
        System.out.println("普通的房子打地基");
    }

    @Override
    public void buildWall() {
        System.out.println("普通的房子修墙");
    }

    @Override
    public void roofed() {
        System.out.println("普通的房子修屋顶");
    }
}





/**
 * 抽象的建造者，仅仅需要考虑房子的建造流程
 */
abstract class HouseBuilder{
    private House house=new House();

//    抽象的方法，只是负责房子的建造流程
    public abstract void buildBasic();
    public abstract void buildWall();
    public abstract void roofed();

//    使用方法建造房子
    public House getHouse(){
        return house;
    }

}



/**
 * 具体的房子类，相当于建造者模式中的产品
 * House--->product
 */
class House{
    private String Basic;
    private String wall;
    private String roofed;

    public House() {
    }

    public House(String basic, String wall, String roofed) {
        Basic = basic;
        this.wall = wall;
        this.roofed = roofed;
    }

    public String getBasic() {
        return Basic;
    }

    public String getWall() {
        return wall;
    }

    public String getRoofed() {
        return roofed;
    }

    @Override
    public String toString() {
        return "House{" +
                "Basic='" + Basic + '\'' +
                ", wall='" + wall + '\'' +
                ", roofed='" + roofed + '\'' +
                '}';
    }

    public void setBasic(String basic) {
        Basic = basic;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public void setRoofed(String roofed) {
        this.roofed = roofed;
    }
}
~~~

#### 建造者模式在jdk源码中的分析

`java.lang.StringBuilder `中的建造者模式

**代码分析**

![1609049698383](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/27/141501-413811.png)

**角色分析**

1. Appendable 接口定义了多个 append 方法(**抽象方法**), 即 Appendable 为抽象建造者, 定义了抽象方法

2. AbstractStringBuilder  实现了  Appendable  接口方法，这里的  AbstractStringBuilder 已经是**建造者**，只是不能实例化

3. StringBuilder **即充当了指挥者角色，同时充当了具体的建造者**，建造方法的实现是由 AbstractStringBuilder 完成 , 而 StringBuilder 继承了 AbstractStringBuilder

#### 建造者模式的注意细节

1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象

2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象

3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程

4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”

5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.

**抽抽象工厂模式和建造者模式对比**

- 建造者模式更加注重方法的**调用顺序**，工厂模式注重**创建对象**。
- 创建对象的力度不同，**建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样**
- 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
- 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。
- 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

**建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。**

#### 建造者模式的优缺点

**优点**

1. 封装性好，构建和表示分离。

2. 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。

3. 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。

 **其缺点如下：** 

1. 产品的组成部分必须相同，这限制了其使用范围。
2. 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。

#### 建造者模式应用场景

- 建造者模式唯一区别于工厂模式的是**针对复杂对象的创建**。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。
- 当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。
- 建造者模式主要适用于以下应用场景：
  - 相同的方法，不同的执行顺序，产生不同的结果。
  - 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
  - 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
  - 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值

### 适配器模式

- 在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。
- 在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。

#### 基本介绍

1. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)

2. 适配器模式属于结构型模式

3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

**定义**

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

#### 工作原理

1. 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容

2. 从用户的角度看不到被适配者，是解耦的

3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
4. 用户收到反馈结果，感觉只是和目标接口交互

#### 模式的结构

适配器模式（Adapter）包含以下主要角色。 

1. 目标（Target）接口：当前系统业务所**期待**的接口，它可以是**抽象类或接口**。
2. 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
3. 适配器（Adapter）类：它是一个转换器，通过**继承或引用适配者的对象**，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

**类适配器结构**

![1609227233432](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1609227233432.png)

**对象适配器结构**

![1609227261323](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1609227261323.png)

#### 类适配器

- 基本介绍：Adapter 类，通过继承 src 类，实现 dst  类接口，完成 src->dst 的适配。

- 类适配器模式可采用多重继承方式实现，如 C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。

 **案例演示**

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电

**类图分析**

![1609217588981](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/125314-869383.png)

**代码实现**

~~~ java
public class ClassAdapter {

    public static void main(String[] args) {
        Phone p=new Phone();
        p.charging(new ViltageAdapter());
    }
}

//被适配的类
class Voltage220v{

    public int output220V(){
        int src=220;
        System.out.println("输出电压："+src);
        return src;
    }
}

interface Ivoltage5V{
    public int output5v();
}

class ViltageAdapter extends Voltage220v implements Ivoltage5V{

//    此方法做的是适配的工作
    @Override
    public int output5v() {
//        获取220v电压
        int srcV=output220V();
//        处理电压
        int distV=srcV/44;
        return distV;
    }
}

class Phone{
//    充电的方法
    public void charging(Ivoltage5V ivoltage5V){
        if(ivoltage5V.output5v() == 5){
            System.out.println("电压是5v，可以充电");
        }else {
            System.out.println("电压不是5v，不可以充电");
        }
    }
}
~~~

**注意事项**

1. Java 是单继承机制，所以类适配器需要**继承** src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;继承关系会增强耦合度。

2. src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。

3. 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。

#### 对象适配器

**介绍**

1. 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以

   解决兼容性的问题。 即：持有 src 类，实现 dst  类接口，完成 src->dst 的适配，继承会增加类之间的耦合度。

2. 根据“合成复用原则”，在系统中尽量使用关联关系（聚合）来替代继承关系。

3. 对象适配器模式是适配器模式常用的一种

**案例演示**

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于 src (即被适配者)，我

们的目 dst(即目标)是 5V 直流电，使用对象适配器模式完成。

**类图实现**

![1609218794598](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/153641-364483.png)

**代码实现**

~~~ java
public class ClassAdapter {

    public static void main(String[] args) {
        Phone p=new Phone();
//        原来是继承关系，所以不需要传入参数，但是现在是聚合关系，需要传入待适配的对象
        p.charging(new ObjectAdapter(new Voltage220v()));

    }
}

//被适配的类
class Voltage220v{

    public int output220V(){
        int src=220;
        System.out.println("输出电压："+src);
        return src;
    }
}

interface Ivoltage5V{
    public int output5v();
}

//对象适配器
class ObjectAdapter implements Ivoltage5V{
//    体现出关联关系中的聚合关系
    private Voltage220v v;

    public ObjectAdapter(Voltage220v v) {
        this.v = v;
    }

    @Override
    public int output5v() {
        int dst=0;
        if(null != v){
//            获取220v的电压
            int src=v.output220V();
            System.out.println("使用对象适配器适配电压:"+src);
            dst=src/44;
            System.out.println("适配后的电压:"+dst);
        }

        return dst;
    }
}
class Phone{
//    充电的方法
    public void charging(Ivoltage5V ivoltage5V){
        if(ivoltage5V.output5v() == 5){
            System.out.println("电压是5v，可以充电");
        }else {
            System.out.println("电压不是5v，不可以充电");
        }
    }
}
~~~

**注意事项**

1. 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。

2. 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst必须是接口。
3. 使用成本更低，更灵活。

#### 接口适配器模式

**案例演示**

**类图**

![1609219651708](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1609219651708.png)

比如我们有一个接口适配器，其中有很多的方法，但是我们不需要其中的所有方法，那么此时我们就可以写一个抽象类去实现接口中的方法，把接口中的方法默认实现，然后我们使用匿名对象，使用的时候可以只实现抽象类中的某一个方法。

**代码说明**

~~~ java
public class InterfaceAdapter {
    public static void main(String[] args) {
//        匿名对象实现具体方法
        AbsAdapter absAdapter = new AbsAdapter() {
            @Override
            public void method02() {
                System.out.println("具体实现method02()方法");
            }
        };
        absAdapter.method02();
    }
}

//接口
interface InterAdapter
{
    public void method01();
    public void method02();
    public void method03();
    public void method04();
    public void method05();
}


abstract class AbsAdapter implements InterAdapter{
//    实现接口中的全部方法，都是默认的实现
    @Override
    public void method01() {

    }

    @Override
    public void method02() {

    }

    @Override
    public void method03() {

    }

    @Override
    public void method04() {

    }

    @Override
    public void method05() {

    }
}
~~~

#### 适配器模式的注意细节

1. 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。

2. 类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承
   1. 对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，
   2. 持有接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现

3. Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。

4. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式

#### 优缺点

**该模式的主要优点如下。** 

- 客户端通过适配器可以透明地调用目标接口。
- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
- 在很多业务场景中符合开闭原则。

 **其缺点是：** 

- 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
-  增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

#### 应用场景

适配器模式（Adapter）通常适用于以下场景。 

- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

### 桥接模式

#### 问题引入

- 在现实生活中，某些**类具有两个或多个维度的变化**，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。
- 当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。

现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:

![1609224114182](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/144157-426900.png)

**传统方式解决手机问题类图**

![1609224161136](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/144244-501704.png)

**传统方式解决手机问题缺点**

1. 扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。

2. 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.

3. 解决方案-使用桥接模式

#### 桥接模式

桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

**基本介绍**

1. 桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。

2. 是一种结构型设计模式

3. Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

#### 桥接模式的实现

可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。

**类图**

![1609224549509](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/144915-893195.png)

**说明**

桥接（Bridge）模式包含以下主要角色。 

1. **抽象化（Abstraction）角色**：定义抽象类，维护了 Implementor / 即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction充当桥接类

2. 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。

3. **实现化（Implementor）角色**：定义实现化角色的接口，供扩展抽象化角色调用，行为实现类的接口

4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现，行为的具体实现类

#### 使用桥接模式解决手机问题

使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护

**类图**

![1609224821430](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/145343-643905.png)

- Phone就相当于Abstraction抽象类。
- Brand是实现化接口Implementor
- foldedPhone,UpRightPhone是抽象类的子类
- Brand是接口是实现化角色的接口。

**代码实现**

~~~ java
public class BridgeDemo {
    public static void main(String[] args) {
//        获取折叠手机（样式+品牌）
        Phone foldedPhone = new FoldedPhone(new HW());
        foldedPhone.open();
        foldedPhone.call();
        foldedPhone.close();
//        使用直立式手机
        Phone upRightPhone = new UpRightPhone(new XM());
        upRightPhone.open();
        upRightPhone.call();
        upRightPhone.close();
    }
}

interface Brand{
    void open();
    void close();
    void call();
}

class HW implements Brand{

    @Override
    public void open() {
        System.out.println("华为手机开机了");
    }

    @Override
    public void close() {
        System.out.println("华为手机关机了");
    }

    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }
}

class XM implements Brand{
    @Override
    public void open() {
        System.out.println("小米手机开机了");
    }

    @Override
    public void close() {
        System.out.println("小米手机关机了");
    }

    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}

//抽象层
abstract class Phone{
  //使用聚合的方式
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }

    protected void open(){
        this.brand.open();
    }

    protected void close(){
        this.brand.close();
    }

    protected void call(){
        this.brand.call();
    }
}

class FoldedPhone extends Phone{
    public FoldedPhone(Brand brand) {
        super(brand);
    }
    public void open(){
        super.open();
        System.out.println("打开折叠样式的手机");
    }

    public void close(){
        super.close();
        System.out.println("关闭折叠样式的手机");
    }
     public void call(){
        super.call();
         System.out.println("用折叠样式手机打电话");
     }
}

//现在增加一个直立式手机的样式，非常简单
class UpRightPhone extends Phone{
    public UpRightPhone(Brand brand) {
        super(brand);
    }
    public void open(){
        super.open();
        System.out.println("打开直立式样式的手机");
    }

    public void close(){
        super.close();
        System.out.println("关闭直立式式的手机");
    }
    public void call(){
        super.call();
        System.out.println("用直立式手机打电话");
    }
}
~~~

#### 桥接模式在JDBC源码包中的应用

1. Jdbc 的 **Driver** 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的Driver，这些就可以当做实现接口类

2. 代码分析+Debug 源码

![1609226159024](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1609226159024.png)

**对 jdbc 源码分析的类图**

![1609226199914](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202012/29/151642-811386.png)

#### 桥接模式注意事项

1. 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。

2. 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。

3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。

4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程

5. 桥接模式要求正确识别出系统中两个独立变化的维度**(**抽象、和实现**)**，因此其使用范围有一定的局限性，即需要有这样的应用场景。

**优缺点**

- 抽象与实现分离，扩展能力强
- 符合开闭原则
- 符合合成复用原则
- 其实现细节对客户透明

缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。

#### 应用场景

当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。

桥接模式通常适用于以下场景。 

1. 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
2. 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
3. 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。

桥接模式的一个常见使用场景就是替换继承。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。

因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明继承具备强侵入性（父类代码侵入子类），同时会导致子类臃肿。因此，在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。

### 装饰器模式

在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。

#### 星巴克咖啡订单项目（咖啡馆）

- 咖啡种类/单品咖啡：Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)

- 调料：Milk、Soy(豆浆)、Chocolate

- 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便

- 使用 OO 的来计算不同种类咖啡的费用:  客户可以点单品咖啡，也可以单品咖啡+调料组合。

#### 方案一

![1609489417773](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202101/01/162340-933038.png)

**缺点**

1. Drink 是一个抽象类，表示饮料

2. des 就是对咖啡的描述, 比如咖啡的名字

3. cost() 方法就是计算费用，Drink 类中做成一个抽象方法.

4. Decaf 就是单品咖啡， 继承 Drink,  并实现 cost

5. Espress && Milk 就是单品咖啡+调料， 这个组合很多，代码量很大，扩展性不好。

问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸

#### 方案二

前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)

![1609489616234](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202101/01/162659-912718.png)

说明: milk,soy,chocolate 可以设计为 Boolean,表示是否要添加相应的调料.

#### 装饰器模式定义

装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

**说明**

1. 装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则**(ocp**)

2. 这里提到的动态的将新功能附加到对象和 ocp 原则，在后面的应用实例上会以代码的形式体现，

#### 装饰器模式原理

通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。

**模式的结构**

 装饰模式主要包含以下角色。 

1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

**类图**

![1609490137458](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202101/01/163548-617737.png)

**说明**

- 装饰者模式就像打包一个快递
  - 主体：比如：陶瓷、衣服 (Component)是被装饰者
  - 包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)
- Component 主体：比如类似前面的 Drink
- ConcreteComponent 和 Decorator
  - ConcreteComponent：具体的主体， 比如前面的各个单品咖啡
- Decorator: 装饰者，比如各调料.

Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。

#### 装饰器模式解决星巴克咖啡问题

**类图**

![1609490436342](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202101/01/164039-702492.png)

**代码实现**

~~~ java
public class DecoratorDemo {
    public static void main(String[] args) {
//        先点一份单品咖啡
        Drink longBlack = new LongBlack();
        System.out.println(longBlack.getDesc());
        System.out.println("longBlack cost:"+longBlack.cost());
        System.out.println("**********************");
//        添加一份牛奶
        longBlack=new Milk(longBlack);
        System.out.println(longBlack.getDesc());
        float a=longBlack.cost();
        System.out.println("longBlack cost:"+longBlack.cost());
        System.out.println("**********************");
//        添加一份巧克力
        longBlack=new Chocolate(longBlack);
        //System.out.println(longBlack.getDesc());
        float money=longBlack.cost();
        System.out.println("longBlack cost:"+longBlack.cost());

//        longBlack=new Chocolate(longBlack);
//        System.out.println(longBlack.getDesc());
//        System.out.println("longBlack cost:"+longBlack.cost());
    }
}

abstract class Drink{
    public String desc;
    private float price=0.0f;
//    计算费用的抽象方法,子类去实现
    public abstract float cost();

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Drink{" +
                "desc='" + desc + '\'' +
                ", price=" + price +
                '}';
    }
}

//抽象出所有咖啡的共同点,作为缓冲层出现
class Coffee extends Drink{

    @Override
    public float cost() {
        //获取咖啡的单价
        return super.getPrice();
    }
}
//具体的咖啡类
class Espresso extends Coffee{
    public Espresso(){
        setDesc("Espresso");
        setPrice(6.06f);
    }
}

class LongBlack extends Coffee{
    public LongBlack(){
        setDesc("LongBlack");
        setPrice(5.0f);
    }
}
class ShortBlack extends Coffee{
    public ShortBlack(){
        setDesc("ShortBlack");
        setPrice(4.0f);
    }
}

//装饰器
class Decorator extends Drink{
    private Drink drink;
//这里体现的是组合关系
    public Decorator(Drink drink) {
        this.drink = drink;
    }
//起到装饰的作用，计算价格
    @Override
    public float cost() {
//        自己的价格加上单品咖啡的价格
        return super.getPrice()+drink.getPrice();
    }

    @Override
    public String getDesc() {
//        drink.getDesc()被装饰者的描述信息
        return super.getDesc()+"  "+super.getPrice()+"  "+drink.getDesc();
    }
}

//具体的调味品，作为装饰器出现
class Chocolate extends Decorator{

    public Chocolate(Drink drink) {
        super(drink);
//        设置具体调味品的信息
        setDesc("巧克力调味品");
        setPrice(3.0f);
    }
}

class Milk extends Decorator{

    public Milk(Drink drink) {
        super(drink);
//        设置具体调味品的信息
        setDesc("牛奶调味品");
        setPrice(2.0f);
    }
}
class Soy extends Decorator{

    public Soy(Drink drink) {
        super(drink);
//        设置具体调味品的信息
        setDesc("豆浆调味品");
        setPrice(1.0f);
    }
}
~~~

扩展很容易，如果想添加一种咖啡，只需要增加一个咖啡类继承`Coffee`类即可

~~~ java
class Decaf extends Coffee{
    public Decaf(){
        setDesc("ShortBlack");
        setPrice(1.0f);
    }
}
~~~

#### 装饰器在jdk源码中的分析

![1609492502672](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/design/202101/01/171504-902930.png)

- InputStream就是抽象的类，类似于前面的Drink抽象类。是被装饰的对象
- FileInputStream是InputStream子类，也就是具体的咖啡类
- FilterInputStream也是InputStream子类，类似于Decorator，而BufferInputStream是FilterInputStream子类，也就是具体的修饰者。

~~~ java
//说明
//1. InputStream  是抽象类,  类似我们前面讲的 Drink
//2. FileInputStream 是	InputStream  子类，类似我们前面的 DeCaf, LongBlack
//3. FilterInputStream	是	InputStream 子类：类似我们前面 的 Decorator 修饰者
//4. DataInputStream  是 FilterInputStream  子类，具体的修饰者，类似前面的 Milk, Soy 等
//5. FilterInputStream 类  有	protected volatile InputStream in;  即含被装饰者
//6. 分析得出在 jdk 的 io 体系中，就是使用装饰者模式
~~~

#### 装饰器模式的优缺点

装饰（Decorator）模式的主要优点有： 

- 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用

- 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
- 装饰器模式完全遵守开闭原则

 其主要缺点是：装饰模式会增加许多子类，过度使用会增加程序得复杂性

#### 装饰器模式的应用场景

前面讲解了关于装饰模式的结构与特点，下面介绍其适用的应用场景，装饰模式通常在以下几种情况使用。 

- 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。
- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时。

### 组合模式

#### 问题引入

编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：

![1610263108416](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/10/151831-879768.png)

**传统解决方案**

![1610263151505](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610263151505.png)

**传统方案分析**

1. 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的
2. 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等
3. 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 => 组合模式

#### 组合模式基本介绍

组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型设计模式。

**基本介绍**

1. 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体**-**部分”的层次关系。
2. 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3. 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象
4. 组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。

![1610263466627](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/10/152428-536026.png)

- 由上图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。
- 这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。

#### 组合模式类图

![1610263558413](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/10/152601-679046.png)

**说明**

对原理结构图的说明-即(组合模式的角色及职责)

1. **Component** :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component  可以是抽象类或者接口，也就是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为

2. **Leaf :** 在组合中表示叶子节点，叶子节点没有子节点，用于继承或实现抽象构件。

3. **Composite** :非叶子节点，用于存储子部件，在 Component接口中实现 子部件的相关操作，比如增加(add),删除。

#### 组合模式解决学校院系展示的 应用实例

编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。

**类图说明**

![1610263748016](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/10/152910-420408.png)

**代码实现**

~~~ java
public class CompositeDemo {
    public static void main(String[] args) {
//     从大到小创建对象
        OrganizationComponent university = new University("清华大学", "顶级大学");

//        创建学院
        OrganizationComponent college = new College("计算机学院", "学习计算机");
        OrganizationComponent college1 = new College("信息工程学院", "学习电子信息工程");
//        给各个学院添加专业
        college.add(new Department("computer","计算机"));
        college.add(new Department("science","科学"));

        college1.add(new Department("通信工程","通信工程专业"));
        college1.add(new Department("生物医学","生物医学工程专业"));

//        学院添加到学校中
        university.add(college);
        university.add(college1);

        university.print();
        Map

    }
}

class Department extends OrganizationComponent{
    public Department(String name, String desc) {
        super(name, desc);
    }

    @Override
    public String getDesc() {
        return super.getDesc();
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public void print() {
        System.out.println("______________"+getName()+"___________________");
    }
}




class College extends OrganizationComponent{
    //存放的是department
    List<OrganizationComponent> list=new ArrayList<>();
    public College(String name, String desc) {
        super(name, desc);
    }

//    重写add方法


    @Override
    protected void add(OrganizationComponent organizationComponent) {
        list.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        list.remove(organizationComponent);
    }

    @Override
    public String getDesc() {
        return super.getDesc();
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public void print() {
        System.out.println("______________"+getName()+"___________________");
        for (OrganizationComponent temp:list) {
            temp.print();
        }

    }
}





/**
 * University就是composite,可以管理college
 */
class University extends OrganizationComponent{
    //list里面存放college
    List<OrganizationComponent> list=new ArrayList<>();
    public University(String name, String desc) {
        super(name, desc);
    }

//    重写add方法


    @Override
    protected void add(OrganizationComponent organizationComponent) {
        list.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        list.remove(organizationComponent);
    }

    @Override
    public String getDesc() {
        return super.getDesc();
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public void print() {
        System.out.println("______________"+getName()+"___________________");
        for (OrganizationComponent temp:list) {
            temp.print();
        }

    }
}


abstract class OrganizationComponent{
    private String name;
    private String desc;
    protected void add(OrganizationComponent organizationComponent){
//        不把此方法写为抽象的方法就是因为有的类不需要实现此方法
        //默认实现
//        抛出异常，不支持操作的异常
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent){
//        不把此方法写为抽象的方法就是因为有的类不需要实现此方法
        //默认实现
//        抛出异常，不支持操作的异常
        throw new UnsupportedOperationException();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public OrganizationComponent(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    abstract public void print();
}
~~~

#### 组合模式在 JDK 集合的源码分析

Java 的集合类-**HashMap** 就使用了组合模式

**类图说明**

![1610265580953](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610265580953.png)

- 其中Map和AbstractHashMap就是相当于Component的顶级接口，有很多管理具体类的方法。
- HashMap就相当于具体的实现子类，表示树中间的节点（Composite），里面重写了很多父类的方法。
- Node就代表叶子节点(是HashMap的静态内部类)。

#### 应用场景

前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。 

1. 在需要表示一个对象整体与部分的层次结构的场合。
2. 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。

#### 优缺点

组合模式的主要优点有： 

1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

 其主要缺点是： 

1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
2. 不容易限制容器中的构件；
3. 不容易用继承的方法来增加构件的新功能；

#### 使用注意细节

1. 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。

2. 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.

3. 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构

4. 需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.

5. 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

### 外观模式

#### 情景引入

~~~ java
组建一个家庭影院：

DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为： 直接用遥控器：统筹各设备开关

开爆米花机 放下屏幕 开投影仪 开音响 开DVD，选 dvd

去拿爆米花 调暗灯光 播放

观影结束后，关闭各种设备
~~~

#### 传统方法解决

**类图说明**

![1610540060808](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610540060808.png)

**问题分析**

1. 在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程

2. 不利于在 ClientTest 中，去维护对子系统的操作

3. 解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面(比如在高层接口提供四个方法ready, play, pause, end )，用来访问子系统中的一群接口

4. 也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 => 外观模式

#### 外观模式基本介绍

**外观模式的定义**

外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

1. 此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

2. 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

#### 外观模式的结构与实现

外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。

**模式的结构**

 外观（Facade）模式包含以下主要角色。 

1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
3. 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

**类图**

![1610540773546](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610540773546.png)

#### 外观模式解决影院管理

1. 外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 pc 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。

2. 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用

**示意图**

![1610540998021](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610540998021.png)

**影院管理类图**

![1610541041718](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1610541041718.png)

**代码实现**

~~~ java
public class FacadeTest {
    public static void main(String[] args) {
        HomeThreaterFacade homeThreaterFacade = new HomeThreaterFacade();
        homeThreaterFacade.ready();
        homeThreaterFacade.end();

    }
}

class HomeThreaterFacade{
//    定义各个子系统
    private DVDplayer dvDplayer;
    private PopCorn popCorn;
    private Projector projector;
    private Screen screen;
    private Stereo stereo;
    private TheaterLight theaterLight;

    public HomeThreaterFacade() {
        this.dvDplayer = DVDplayer.getInstance();
        this.popCorn = PopCorn.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
        this.stereo = Stereo.getInstance();
        this.theaterLight = TheaterLight.getInstance();
    }

    public void ready(){
        popCorn.on();;
        projector.on();
        screen.on();;
        stereo.on();
        theaterLight.on();
        dvDplayer.on();
    }
    public void pause(){
        dvDplayer.pause();
    }
    public void end(){
        popCorn.off();
        projector.off();
        screen.off();
        stereo.off();
        theaterLight.off();
        dvDplayer.off();
    }

}

class DVDplayer{
//    一个系统只有一个dvd
    private static DVDplayer instance=new DVDplayer();
    public static DVDplayer getInstance(){
        return instance;
    }
//    DVD的功能
    public void on(){
        System.out.println("DVD ON");
    }
    public void off(){
        System.out.println("DVD OF");
    }
    public void play(){
        System.out.println("DVD PLAY");
    }

    public void pause(){
        System.out.println("DVD pause");
    }
}

class PopCorn{
    //    一个系统只有一个dvd
    private static PopCorn instance=new PopCorn();
    public static PopCorn getInstance(){
        return instance;
    }
    public void on(){
        System.out.println("PopCorn ON");
    }
    public void off(){
        System.out.println("PopCorn OF");
    }
    public void play(){
        System.out.println("PopCorn PLAY");
    }
}

class Projector{
    //    一个系统只有一个dvd
    private static Projector instance=new Projector();
    public static Projector getInstance(){
        return instance;
    }
    public void on(){
        System.out.println("Projector ON");
    }
    public void off(){
        System.out.println("Projector OF");
    }
    public void play(){
        System.out.println("Projector PLAY");
    }
}

class Screen{
    //    一个系统只有一个dvd
    private static Screen instance=new Screen();
    public static Screen getInstance(){
        return instance;
    }
    public void on(){
        System.out.println("Screen up");
    }
    public void off(){
        System.out.println("Screen down");
    }
    public void play(){
        System.out.println("Screen PLAY");
    }
}

class Stereo{
    //    一个系统只有一个dvd
    private static Stereo instance=new Stereo();
    public static Stereo getInstance(){
        return instance;
    }
    public void on(){
        System.out.println("Stereo up");
    }
    public void off(){
        System.out.println("Stereo down");
    }
    public void play(){
        System.out.println("Stereo PLAY");
    }
}

class TheaterLight{
    //    一个系统只有一个dvd
    private static TheaterLight instance=new TheaterLight();
    public static TheaterLight getInstance(){
        return instance;
    }
    public void on(){
        System.out.println("TheaterLight up");
    }
    public void off(){
        System.out.println("TheaterLight down");
    }
    public void play(){
        System.out.println("TheaterLight PLAY");
    }
}
~~~

#### 外观模式注意事项

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性

2. 外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展

3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次

4. 当系统需要进行分层设计时，可以考虑使用 Facade 模式

5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性

6. 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。

#### 外观模式的优缺点

外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。 

1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

 外观（Facade）模式的主要缺点如下。 

1. 不能很好地限制客户使用子系统类，很容易带来未知风险。
2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”

#### 应用场景

通常在以下情况下可以考虑使用外观模式。 

1. 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
2. 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
3. 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。

### 享元模式

在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。

#### 问题引入

小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：

1. 有客户要求以新闻的形式发布

2. 有客户人要求以博客的形式发布

3. 有客户希望以微信公众号的形式发布

#### 传统方法解决

1. 直接复制粘贴一份，然后根据客户不同要求，进行定制修改
2. 给每个网站租用一个空间

**方案设计图**

![1610955639799](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/18/154041-211222.png)

**问题分析**

1. 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费
2. 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源
3. 对于代码来说，由于是一份实例，维护和扩展都更加容易
4. 上面的解决思路就可以使用 享元模式 来解决

#### 享元模式的基本介绍

**定义**

享元（Flyweight）模式的定义：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

**基本说明**

1. 享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象

2. 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个

3. 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率

4. 享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

![1610955893706](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/18/154456-245301.png)

#### 享元模式的结构实现

享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。 

- 内部状态指对象**共享**出来的信息，存储在享元信息内部，并且不回随环境的改变而改变；
- 外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享。

> 比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。
>
> 享元模式的本质是缓存共享对象，降低内存消耗。

**类图**

![1610955997937](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/18/154642-938007.png)

**类图说明**

- FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态的接口或实现。是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
- ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业
- UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
- FlyWeightFactory   享元工厂类，用于构建一个池容器(集合，可以想象为线程池)， 同时提供从池中获取对象方法，负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

#### 享元模式解决网站展现项目

**类图**

![1610956496340](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/24/165201-973184.png)

**代码实现**

~~~ java
public class FlyWeightTest {
    public static void main(String[] args) {
        WebSiteFactory factory = new WebSiteFactory();
        WebSite webSite = factory.getWebSiteCategory("新闻");
        webSite.use(new User("tom"));
        WebSite webSite1 = factory.getWebSiteCategory("音乐");
        webSite1.use(new User("xiaomign"));

        WebSite webSite2 = factory.getWebSiteCategory("音乐");
        webSite1.use(new User("xiaohong"));

        WebSite webSite3 = factory.getWebSiteCategory("音乐");
        webSite1.use(new User("xiaobai"));

        WebSite webSite4 = factory.getWebSiteCategory("音乐");
        webSite1.use(new User("xiaohua"));
//        虽然创建了好几个音乐类型网站，但是实际上池子中只有2个对象
        System.out.println("网站的分类个数："+factory.getSize());
    }
}

//外部状态
class User{
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

abstract class WebSite{
    public abstract void use(User user);
}

class ConCreteWebSite extends WebSite{
    private String type=" ";

    public ConCreteWebSite(String type) {
        this.type = type;
    }

    @Override
    public void use(User user) {
        System.out.println("网站的发布形式为："+type+"  使用者为："+user.getName());
    }
}

class WebSiteFactory{
//    一个池子，共享池
    private HashMap<String,ConCreteWebSite>pool=new HashMap<String ,ConCreteWebSite>();

    public WebSite getWebSiteCategory(String type){
//        首先判断是否有网站的类型
        if(!pool.containsKey(type)){
//            创建一个网站添加到池子中
            pool.put(type,new ConCreteWebSite(type));
        }
        return (WebSite)pool.get(type);
    }
//    获取网站分类的总数(也就是有多少个网站类型）
    public int getSize(){
        return pool.size();
    }
}
~~~

#### 享元模式在 JDK-Interger 的应用源码分析

~~~ java
public class FlyWeight {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //如果  Integer.valueOf(x) x 在	-128 --- 127 直接，就是使用享元模式返回,如果不在
        //范围类，则仍然 new
        
        //小结:
        //1. 在 valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的 Integer(new),  否则，就直接从 缓存池返回
        //2. valueOf 方法，就使用到享元模式
        //3. 如果使用 valueOf 方法得到一个 Integer 实例，范围在 -128 - 127  ，执行速度比 new 快


        Integer x = Integer.valueOf(127); // 得到 x 实例，类型 Integer Integer y = new Integer(127); // 得 到 y 实 例 ， 类 型 Integer Integer z = Integer.valueOf(127);//..
        Integer w = new Integer(127);

        System.out.println(x.equals(y)); // 大小，true System.out.println(x == y ); //	false System.out.println(x == z ); // true System.out.println(w == x ); // false System.out.println(w == y ); // false


        Integer x1 = Integer.valueOf(200);
        Integer x2 = Integer.valueOf(200);


        System.out.println("x1==x2" + (x1 == x2)); // false
    }
}
//源码
 public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
          //从缓冲池中获取
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
~~~

#### 享元模式优点及应用场景

**优缺点**

享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。

 其主要缺点是： 

1. 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
2. 读取享元模式的外部状态会使得运行时间稍微变长。

**应用场景**

当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。

 享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。

 前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。 

1. 系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。
2. 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。
3. 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。

#### 使用享元模式注意细节

1. 在享元模式这样理解，“享”就表示共享，“元”表示对象

2. 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
3. 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable 存储
4. 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
5. 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.
6. 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
7. 享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池

### 代理模式

#### 什么是代理

在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

- 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。
- 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
- 代理模式有不同的形式, 主要有三种 静态代理、动态代理 (JDK 代理、接口代理)和  **Cglib** 代理  (可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。

**代理模式示意图**

![1632482098228](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/24/191459-626990.png)

- ProxyObject是代理对象
- TargetObject是被代理对象

#### 代理模式特点

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

 代理模式的主要优点有： 

-  代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
-  代理对象可以扩展目标对象的功能；
-  代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

 其主要缺点是： 

-  代理模式会造成系统设计中类的数量增加
-  在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
-  增加了系统的复杂度；

>  那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式

#### 静态代理

##### 什么是静态代理

静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。

##### 应用实例

**具体要求**

1. 定义一个接口:ITeacherDao
2. 目标对象 TeacherDAO 实现接口 ITeacherDAO
3. 使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO
4. 调用的时候通过调用代理对象的方法来调用目标对象.
5. 特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法

##### 类图分析

![1632482408128](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/24/192010-34443.png)

**代码实现**

~~~ java
public class TestProxy {

    public static void main(String[] args) {
//        客户端进行调用
//        创建被代理对象
        TeacherDao teacherDao = new TeacherDao();
//        传入的参数是被代理的对象
//        创建代理的对象，同时传输被代理对象，
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);
//        通过代理对象，调用被代理对象的方法
//        也即是执行的是代理对象的方法，代理对象方法里面执行的是被代理的对象方法
        teacherDaoProxy.teach();
    }
}

interface ITeacherDao{
    void teach();

}

class TeacherDao implements ITeacherDao{

//    不直接调用这个方法，而是让代理对象调用
    public void teach() {
        System.out.println("老师正在授课！");
    }
}
//静态代理对象
class TeacherDaoProxy implements ITeacherDao{
    private ITeacherDao target;//目标对象，通过接口聚合

    TeacherDaoProxy(ITeacherDao target) {
        this.target = target;
    }

    public void teach() {
        System.out.println("代理对象开始代理,完成某些功能！");
        target.teach();//执行代理的方法
        System.out.println("提交！");
    }
}
~~~

##### 静态代理优缺点

**优点：**

1. 在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展

**缺点：**

1. 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类
2. 一旦接口增加方法,目标对象与代理对象都要维护

#### 动态代理

##### 什么是动态代理

1. 代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理

2. 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象

3. 动态代理也叫做：JDK 代理、接口代理

##### JDK 中生成代理对象的 API

1. 代理类所在包:java.lang.reflect.Proxy
2. JDK 实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数,完整的写法是:

`static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )`

##### 应用实例

将前面的静态代理改进成动态代理模式(即：JDK 代理模式)

**类图分析**

![1632482705396](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/24/192507-783076.png)

**代码实现**

~~~ java
public class TestDynamicProxy {

    public static void main(String[] args) {
        ITeacherDao teacherDao = new TeacherDao();
//        给目标对象创建代理对象,返回被代理的对象
        ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(teacherDao).getProxyInstance();
//        可以看出内存中动态生成了代理对象
//        System.out.println(proxyInstance);//qq.com.TeacherDao@2503dbd3
//        通过代理对象调用目标对象的方法
        proxyInstance.teach();

    }
}

interface ITeacherDao{
    void teach();
}

class TeacherDao implements ITeacherDao{

    public void teach() {
        System.out.println("老师正在授课！");
    }
}

//动态代理，没有继承接口
class ProxyFactory{
//    维护一个目标对象
    private Object target;

//    构造器对目标对象进行初始化
    public ProxyFactory(Object target) {
        this.target = target;
    }
//    给目标对象生成一个代理对象
    public Object getProxyInstance(){

        /**
         * public static Object newProxyInstance(ClassLoader loader,
         *                                           Class<?>[] interfaces,
         *                                           InvocationHandler h)
         * ClassLoader:指定当前目对象使用的类加载器，获取类加载器的方法固定
         * Class<?>[] interfaces：目标对象实现的接口类型，使用泛型方式确定类型
         * InvocationHandler：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行的目标对象
         * 方法作为参数传递
         */
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader()
                , target.getClass().getInterfaces()
                , new InvocationHandler() {
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("jdk代理开始");
//                        通过反射机制调用目标对象的方法
                        Object res = method.invoke(target, args);
                        System.out.println("jdk代理提交");
                        return res;
                    }
                });
    }
}
~~~

#### 几种常见的代理模式变体

1. 防火墙代理

内网通过代理穿透防火墙，实现对公网的访问。

2. 缓存代理

比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。

3. 远程代理

远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。

4. 同步代理：

主要使用在多线程编程中，完成多线程间同步工作同步代理：主要使用在多线程编程中，完成多线程间同步工作