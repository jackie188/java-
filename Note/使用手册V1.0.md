

# 使用手册V1.0

* [使用手册V1\.0](#使用手册v10)
  * [核心](#核心)
    * [JVM、JRE及JDK的关系](#jvmjre及jdk的关系)
    * [Java语言的特点](#java语言的特点)
    * [Java语言和c\+\+的区别](#java语言和c的区别)
    * [Java的基本数据类型](#java的基本数据类型)
    * [隐式(自动)类型转换和显示(强制)类型转换](#隐式自动类型转换和显示强制类型转换)
    * [自动装箱与拆箱](#自动装箱与拆箱)
    * [String(不是基本数据类型)](#string不是基本数据类型)
      * [String的不可变性](#string的不可变性)
      * [字符型常量和字符串常量的区别](#字符型常量和字符串常量的区别)
      * [什么是字符串常量池？](#什么是字符串常量池)
      * [String 类的常用方法都有那些？](#string-类的常用方法都有那些)
      * [String和StringBuffer、StringBuilder的区别是什么？](#string和stringbufferstringbuilder的区别是什么)
      * [switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上](#switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上)
    * [Java语言采用何种编码方案？有何特点？](#java语言采用何种编码方案有何特点)
    * [访问修饰符](#访问修饰符)
    * [运算符](#运算符)
    * [关键字](#关键字)
      * [static关键字](#static关键字)
      * [final关键字](#final关键字)
      * [final finally finalize区别](#final-finally-finalize区别)
      * [this关键字](#this关键字)
      * [super关键字](#super关键字)
      * [this和super的区别](#this和super的区别)
      * [break ,continue ,return 的区别及作用](#break-continue-return-的区别及作用)
    * [面向对象和面向过程的区别](#面向对象和面向过程的区别)
    * [面向对象三大特性(封装、继承、多态)](#面向对象三大特性封装继承多态)
    * [面向对象五大基本原则是什么](#面向对象五大基本原则是什么)
    * [抽象类和接口的对比](#抽象类和接口的对比)
    * [在Java中定义一个不做事且没有参数的构造方法的作用](#在java中定义一个不做事且没有参数的构造方法的作用)
    * [在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是](#在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是)
    * [一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？](#一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么)
    * [构造方法有哪些特性？](#构造方法有哪些特性)
    * [变量](#变量)
    * [内部类](#内部类)
    * [重写与重载](#重写与重载)
      * [重载与重写的区别](#重载与重写的区别)
      * [构造器（constructor）是否可被重写（override）](#构造器constructor是否可被重写override)
      * [重载的方法能否根据返回类型进行区分？为什么？](#重载的方法能否根据返回类型进行区分为什么)
    * [== 和 equals 的区别](#-和-equals-的区别)
    * [hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）](#hashcode-与-equals为什么重写equals方法后hashcode方法也必须重写)
    * [Java 中是值传递还是引用传递，还是两者共存](#java-中是值传递还是引用传递还是两者共存)
    * [IO流](#io流)
    * [BIO,NIO,AIO 有什么区别?](#bionioaio-有什么区别)
    * [反射](#反射)
    * [JAVA异常](#java异常)
    * [Java注解](#java注解)
    * [Java泛型](#java泛型)
    * [JAVA序列化](#java序列化)
    * [深拷贝和浅拷贝](#深拷贝和浅拷贝)
    * [常见的Object方法](#常见的object方法)
  * [集合](#集合)
    * [常用的集合类有哪些](#常用的集合类有哪些)
    * [List，Set，Map三者的区别？](#listsetmap三者的区别)
    * [常用集合框架底层数据结构](#常用集合框架底层数据结构)
    * [哪些集合类是线程安全的？](#哪些集合类是线程安全的)
    * [迭代器 Iterator 是什么](#迭代器-iterator-是什么)
    * [Java集合的快速失败机制 “fail\-fast”和安全失败机制“failsafe”是什么？](#java集合的快速失败机制-fail-fast和安全失败机制failsafe是什么)
    * [如何边遍历边移除 Collection 中的元素？](#如何边遍历边移除-collection-中的元素)
    * [Array 和 ArrayList 有何区别？](#array-和-arraylist-有何区别)
    * [comparable 和 comparator的区别？](#comparable-和-comparator的区别)
    * [Collection 和 Collections 有什么区别？](#collection-和-collections-有什么区别)
    * [List集合](#list集合)
      * [遍历一个 List 有哪些不同的方式？](#遍历一个-list-有哪些不同的方式)
      * [ArrayList的扩容机制](#arraylist的扩容机制)
      * [ArrayList 和 LinkedList 的区别是什么？](#arraylist-和-linkedlist-的区别是什么)
      * [ArrayList 和 Vector 的区别是什么？](#arraylist-和-vector-的区别是什么)
      * [简述 ArrayList、Vector、LinkedList 的存储性能和特性？](#简述-arraylistvectorlinkedlist-的存储性能和特性)
    * [Set集合](#set集合)
      * [说一下 HashSet 的实现原理](#说一下-hashset-的实现原理)
      * [HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）](#hashset如何检查重复hashset是如何保证数据不可重复的
        )
      * [HashSet与HashMap的区别](#hashset与hashmap的区别)
    * [Map集合](#map集合)
      * [HashMap在JDK1\.7和JDK1\.8中有哪些不同？HashMap的底层实现](#hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现)
      * [HashMap 的长度为什么是2的幂次方](#hashmap-的长度为什么是2的幂次方)
      * [HashMap的put方法的具体流程？](#hashmap的put方法的具体流程)
      * [HashMap的扩容操作是怎么实现的？](#hashmap的扩容操作是怎么实现的)
      * [HashMap默认加载因子为什么选择0\.75？](#hashmap默认加载因子为什么选择075)
      * [为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？](#为什么要将链表中转红黑树的阈值设为8为什么不一开始直接使用红黑树)
      * [HashMap是怎么解决哈希冲突的？](#hashmap是怎么解决哈希冲突的)
      * [HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？](#hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标)
      * [能否使用任何类作为 Map 的 key？](#能否使用任何类作为-map-的-key)
      * [为什么HashMap中String、Integer这样的包装类适合作为Key？](#为什么hashmap中stringinteger这样的包装类适合作为key)
      * [如果使用Object作为HashMap的Key，应该怎么办呢？](#如果使用object作为hashmap的key应该怎么办呢)
      * [HashMap 多线程导致死循环问题](#hashmap-多线程导致死循环问题)
      * [ConcurrentHashMap 底层具体实现知道吗？](#concurrenthashmap-底层具体实现知道吗)
      * [HashTable的底层实现知道吗？](#hashtable的底层实现知道吗)
      * [HashMap、ConcurrentHashMap及Hashtable 的区别](#hashmapconcurrenthashmap及hashtable-的区别)
      * [集合的常用方法](#集合的常用方法)
      * [Collection常用方法](#collection常用方法)
      * [List特有方法](#list特有方法)
      * [LinkedList特有方法](#linkedlist特有方法)
      * [Map](#map)
      * [Stack](#stack)
      * [Queue](#queue)
  * [虚拟机](#虚拟机)
    * [描述一下JVM内存模型以及分区，需要详细介绍每隔内存区域存放什么？](#描述一下jvm内存模型以及分区需要详细介绍每隔内存区域存放什么)
    * [对象的创建方法，对象的内存分配，对象的访问定位](#对象的创建方法对象的内存分配对象的访问定位)
    * [GC的两种判定方法，以及各有什么特点](#gc的两种判定方法以及各有什么特点)
    * [GC的三种收集方法：标记清除，复制算法，标记整理算法的原理和特点，分别使用在内存的哪一个区域，如果让你优化收集方法，有什么思路？](#gc的三种收集方法标记清除复制算法标记整理算法的原理和特点分别使用在内存的哪一个区域如果让你优化收集方法有什么思路)
    * [GC收集器有哪些，CMS收集器和G1收集器的特点](#gc收集器有哪些cms收集器和g1收集器的特点)
      * [serial收集器](#serial收集器)
      * [ParNew收集器（又叫<strong>Parallel收集器</strong>）](#parnew收集器又叫parallel收集器)
      * [Parallel Scavenge（<strong>并行清除</strong>）收集器](#parallel-scavenge并行清除收集器)
      * [Serial Old收集器](#serial-old收集器)
      * [Parallel Old收集器](#parallel-old收集器)
      * [CMS收集器](#cms收集器)
      * [G1收集器](#g1收集器)
    * [Minor GC,Major GC 和Full GC分别发生在什么时候，各有什么特点？](#minor-gcmajor-gc-和full-gc分别发生在什么时候各有什么特点)
    * [说说常用的内存调试工具？](#说说常用的内存调试工具)
    * [说说类加载的五个过程](#说说类加载的五个过程)
    * [双亲委派模型，问什么需要双亲委派模型，有什么优点？](#双亲委派模型问什么需要双亲委派模型有什么优点)
    * [分派：静态分派和动态分派](#分派静态分派和动态分派)
    * [那些内存区域会发生OOM以及会进行GC？](#那些内存区域会发生oom以及会进行gc)
    * [如何打破双亲委派模型？](#如何打破双亲委派模型)
    * [新生代中区分Eden和Survivor的作用是什么](#新生代中区分eden和survivor的作用是什么)
    * [简述分代垃圾回收器工作流程](#简述分代垃圾回收器工作流程)
    * [GC是什么? 为什么要有 GC?](#gc是什么-为什么要有-gc)
    * [简述CMS收集器](#简述cms收集器)
    * [简述G1收集器](#简述g1收集器)
    * [简述GC中Stop the world（重点）](#简述gc中stop-the-world重点)
    * [垃圾回收算法（重点）](#垃圾回收算法重点)
    * [什么是分代回收算法，为什么要进行分代回收](#什么是分代回收算法为什么要进行分代回收)
    * [你知道都有哪些垃圾回收器，各有什么特点](#你知道都有哪些垃圾回收器各有什么特点)
    * [什么是内存溢出，什么是内存泄漏，有什么区别](#什么是内存溢出什么是内存泄漏有什么区别)
    * [对象什么时候会被GC](#对象什么时候会被gc)
    * [说说Java中栈内存和堆内存的区别](#说说java中栈内存和堆内存的区别)
    * [强引用、软引用、弱引用、虚引用以及他们之间和gc的关系](#强引用软引用弱引用虚引用以及他们之间和gc的关系)
    * [java对象创建（5种创建对象的方法）](#java对象创建5种创建对象的方法)
    * [如果对象的引用被置为 null，垃圾收集器是否会立即回收对象？](#如果对象的引用被置为-null垃圾收集器是否会立即回收对象
      )
    * [jvm调优工具又哪些？各自的作用又是什么（重点）](#jvm调优工具又哪些各自的作用又是什么重点)
    * [你知道哪些JVM调优参数](#你知道哪些jvm调优参数)
    * [为什么字符串常量池在不同版本的jdk中位置会发生变化](#为什么字符串常量池在不同版本的jdk中位置会发生变化)
    * [概述一下类结构文件](#概述一下类结构文件)
    * [谈谈你对jvm的理解](#谈谈你对jvm的理解)
    * [JVM 配置常用参数有哪些?](#jvm-配置常用参数有哪些)
    * [常用 GC 调优策略有哪些？](#常用-gc-调优策略有哪些)
      * [GC 调优原则](#gc-调优原则)
      * [GC 调优目的](#gc-调优目的)
      * [GC 调优策略](#gc-调优策略)
    * [虚拟机栈和本地方法栈为什么是线程私有的？](#虚拟机栈和本地方法栈为什么是线程私有的)
    * [java对象的创建过程](#java对象的创建过程)
    * [对象访问定位的两种方式](#对象访问定位的两种方式)
    * [HotSpot为什么要分为新生代和老年代？](#hotspot为什么要分为新生代和老年代)
  * [并发](#并发)
    * [什么是进程？是什么线程？](#什么是进程是什么线程)
    * [进程和线程的关系？（区别）](#进程和线程的关系区别)
    * [并行和并发的区别？](#并行和并发的区别)
    * [多线程的优缺点（为什么使用多线程、多线程会引发什么问题）](#多线程的优缺点为什么使用多线程多线程会引发什么问题)
    * [线程的上下文切换](#线程的上下文切换)
    * [Java中守护线程和用户线程的区别？](#java中守护线程和用户线程的区别)
    * [线程死锁是如何产生的，如何避免](#线程死锁是如何产生的如何避免)
    * [用Java实现死锁，并给出避免死锁的解决方案](#用java实现死锁并给出避免死锁的解决方案)
    * [Java中的死锁、活锁、饥饿有什么区别？](#java中的死锁活锁饥饿有什么区别)
    * [线程的生命周期和状态](#线程的生命周期和状态)
    * [创建线程一共有哪几种方法？](#创建线程一共有哪几种方法)
    * [runnable 和 callable 有什么区别？](#runnable-和-callable-有什么区别)
    * [线程的run()和start()有什么区别？](#线程的run和start有什么区别)
    * [为什么调用start()方法时会执行run()方法，而不直接执行run()方法？](#为什么调用start方法时会执行run方法而不直接执行run方法)
    * [线程同步和线程调度](#线程同步和线程调度)
      * [线程同步以及线程调度相关的方法有哪些？](#线程同步以及线程调度相关的方法有哪些)
      * [线程的sleep()方法和yield()方法有什么不同？](#线程的sleep方法和yield方法有什么不同)
      * [sleep()方法和wait()方法的区别？](#sleep方法和wait方法的区别)
      * [wait()方法一般在循环块中使用还是if块中使用？](#wait方法一般在循环块中使用还是if块中使用)
      * [线程通信的方法有哪些？](#线程通信的方法有哪些)
      * [为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？](#为什么waitnotifynotifyall被定义在object类中而不是在thread类中)
      * [为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？](#为什么waitnotify和notifyall必须在同步方法或者同步块中被调用)
      * [为什么Thread类的sleep()和yield()方法是静态的？](#为什么thread类的sleep和yield方法是静态的)
      * [如何停止一个正在运行的线程？](#如何停止一个正在运行的线程)
      * [如何唤醒一个阻塞的线程](#如何唤醒一个阻塞的线程)
      * [Java如何实现两个线程之间的通信和协作](#java如何实现两个线程之间的通信和协作)
      * [同步方法和同步方法块哪个效果更好？](#同步方法和同步方法块哪个效果更好)
      * [什么是线程同步？什么是线程互斥？他们是如何实现的？](#什么是线程同步什么是线程互斥他们是如何实现的)
      * [在Java程序中如何保证线程的运行安全？](#在java程序中如何保证线程的运行安全)
      * [线程类的构造方法、静态块是被哪个线程调用的？](#线程类的构造方法静态块是被哪个线程调用的)
      * [一个线程运行时异常会发生什么?](#一个线程运行时异常会发生什么)
      * [线程数量过多会造成什么异常？](#线程数量过多会造成什么异常)
      * [三个线程T1、T2、T3，如何让他们按顺序执行？](#三个线程t1t2t3如何让他们按顺序执行)
    * [synchronized关键字](#synchronized关键字)
      * [什么是synchronized关键字 ？](#什么是synchronized关键字-)
      * [Java内存的可见性问题](#java内存的可见性问题)
      * [synchronized关键字三大特性是什么？](#synchronized关键字三大特性是什么)
      * [synchronized关键字可以实现什么类型的锁？](#synchronized关键字可以实现什么类型的锁)
      * [synchronized关键字的使用方式](#synchronized关键字的使用方式)
      * [synchronized底层原理](#synchronized底层原理)
      * [Jdk1\.6为什么要对synchronized进行优化？](#jdk16为什么要对synchronized进行优化)
      * [jDK1\.6对synchronized做了哪些优化？](#jdk16对synchronized做了哪些优化)
      * [Java中都有哪几种锁](#java中都有哪几种锁)
        * [乐观锁和悲观锁](#乐观锁和悲观锁)
        * [独占锁和共享锁](#独占锁和共享锁)
        * [互斥锁和读写锁](#互斥锁和读写锁)
        * [公平锁和非公平锁](#公平锁和非公平锁)
        * [可重入锁](#可重入锁)
        * [自旋锁](#自旋锁)
        * [分段锁](#分段锁)
        * [锁升级（无锁|偏向锁|轻量级锁|重量级锁）](#锁升级无锁偏向锁轻量级锁重量级锁)
        * [锁优化技术（锁粗化、锁消除）](#锁优化技术锁粗化锁消除)
    * [volatile](#volatile)
      * [volatile的作用是什么？](#volatile的作用是什么)
      * [volatile的特性有哪些？](#volatile的特性有哪些)
      * [Java内存的可见性问题](#java内存的可见性问题-1)
      * [为什么代码会重排序？](#为什么代码会重排序)
      * [重排序会引发什么问题？](#重排序会引发什么问题)
      * [as\-if\-serial规则和happens\-before规则的区别](#as-if-serial规则和happens-before规则的区别)
      * [voliatile的实现原理？](#voliatile的实现原理)
      * [volatile实现内存可见性原理](#volatile实现内存可见性原理)
      * [volatile实现有序性原理](#volatile实现有序性原理)
      * [Java虚拟机插入内存屏障的策略](#java虚拟机插入内存屏障的策略)
      * [编译器对内存屏障插入策略的优化](#编译器对内存屏障插入策略的优化)
      * [volatile能使一个非原子操作变成一个原子操作吗？](#volatile能使一个非原子操作变成一个原子操作吗)
      * [volatile、synchronized的区别？](#volatilesynchronized的区别)
    * [ConcurrentHashMap](#concurrenthashmap)
      * [什么是ConcurrentHashMap？相比于HashMap和HashTable有什么优势](#什么是concurrenthashmap相比于hashmap和hashtable有什么优势)
      * [java中ConcurrentHashMap是如何实现的？](#java中concurrenthashmap是如何实现的)
      * [ConcurrentHashMap结构中变量使用volatile和final修饰有什么作用？](#concurrenthashmap结构中变量使用volatile和final修饰有什么作用)
      * [ConcurrentHashMap有什么缺点？](#concurrenthashmap有什么缺点)
      * [ConcurrentHashMap默认初始容量是多少？每次扩容为原来的几倍？](#concurrenthashmap默认初始容量是多少每次扩容为原来的几倍)
      * [ConCurrentHashMap 的key，value是否可以为null？为什么？HashMap中的key、value是否可以为null？](#concurrenthashmap的keyvalue是否可以为null为什么hashmap中的keyvalue是否可以为null)
      * [ConCurrentHashmap在JDK1\.8中，什么情况下链表会转化为红黑树？](#concurrenthashmap在jdk18中什么情况下链表会转化为红黑树)
      * [ConcurrentHashMap在JDK1\.7和JDK1\.8版本中的区别？](#concurrenthashmap在jdk17和jdk18版本中的区别)
      * [ConcurrentHashMap迭代器是强一致性还是弱一致性？](#concurrenthashmap迭代器是强一致性还是弱一致性)
    * [ThreadLocal](#threadlocal)
      * [什么是ThreadLocal？有哪些应用场景？](#什么是threadlocal有哪些应用场景)
      * [ThreadLocal原理和内存泄露？](#threadlocal原理和内存泄露)
    * [线程池](#线程池)
      * [什么是线程池？为什么使用线程池](#什么是线程池为什么使用线程池)
      * [创建线程池的方式](#创建线程池的方式)
      * [ThreadPoolExecutor构造函数的重要参数分析](#threadpoolexecutor构造函数的重要参数分析)
      * [ThreadPoolExecutor的饱和策略（拒绝策略 )](#threadpoolexecutor的饱和策略拒绝策略-)
      * [线程池的执行流程](#线程池的执行流程)
      * [execute()方法和submit()方法的区别](#execute方法和submit方法的区别)
  * [数据库](#数据库)
    * [什么是Mysql数据库](#什么是mysql数据库)
    * [Mysql常用的存储引擎有哪些，他们都有什么特点？](#mysql常用的存储引擎有哪些他们都有什么特点)
    * [数据库的三大范式](#数据库的三大范式)
    * [Mysql的数据类型都有哪些？](#mysql的数据类型都有哪些)
    * [索引](#索引)
      * [什么是索引](#什么是索引)
      * [索引的优缺点](#索引的优缺点)
      * [索引的数据结构](#索引的数据结构)
      * [Hash索引和B\+树的区别？](#hash索引和b树的区别)
      * [索引的类型有哪些](#索引的类型有哪些)
      * [索引的种类有哪些？](#索引的种类有哪些)
      * [B树和B\+树的区别？](#b树和b树的区别)
      * [数据库为什么使用B\+树而不是B树？](#数据库为什么使用b树而不是b树)
      * [什么是聚簇索引，什么是非聚簇索引？](#什么是聚簇索引什么是非聚簇索引)
      * [非聚簇索引一定会进行回表查询吗？](#非聚簇索引一定会进行回表查询吗)
      * [索引的使用场景有哪些？](#索引的使用场景有哪些)
      * [索引的设计原则有哪些？](#索引的设计原则有哪些)
      * [如何对索引进行优化](#如何对索引进行优化)
      * [如何创建删除索引？](#如何创建删除索引)
      * [使用索引查询时性能一定会提升吗？](#使用索引查询时性能一定会提升吗)
      * [什么是前缀索引](#什么是前缀索引)
      * [什么是最左匹配原则](#什么是最左匹配原则)
      * [索引在什么情况下会失效？](#索引在什么情况下会失效)
    * [数据库事务](#数据库事务)
      * [什么是数据库事务？](#什么是数据库事务)
      * [事务的四大特性是什么？](#事务的四大特性是什么)
      * [数据库的并发一致性问题](#数据库的并发一致性问题)
      * [数据库的隔离级别有哪些？](#数据库的隔离级别有哪些)
      * [隔离级别是如何实现的？](#隔离级别是如何实现的)
      * [什么是MVCC](#什么是mvcc)
    * [数据库锁](#数据库锁)
      * [什么是数据库锁](#什么是数据库锁)
      * [数据库锁与隔离级别的关系](#数据库锁与隔离级别的关系)
      * [数据库锁类型有哪些？](#数据库锁类型有哪些)
      * [MySQL中InnoDB引擎的行锁模式及其是如何实现的？](#mysql中innodb引擎的行锁模式及其是如何实现的)
      * [什么是数据库的乐观锁和悲观锁，如何实现？](#什么是数据库的乐观锁和悲观锁如何实现)
      * [什么是死锁？如何避免？](#什么是死锁如何避免)
    * [Sql基础](#sql基础)
      * [SQL语句主要分为哪几类](#sql语句主要分为哪几类)
      * [SQL约束有哪些](#sql约束有哪些)
      * [什么是子查询](#什么是子查询)
      * [了解MySQL的几种连接查询吗？](#了解mysql的几种连接查询吗)
      * [mysql中in和exists的区别？](#mysql中in和exists的区别)
      * [varchar和char的区别？](#varchar和char的区别)
      * [MySQL中int(10)和char(10)和varchar(10)的区别？](#mysql中int10和char10和varchar10的区别)
      * [drop、delete和truncate的区别？](#dropdelete和truncate的区别)
      * [UNION和UNION ALL的区别？](#union和union-all的区别)
      * [什么是临时表，什么时候会使用到临时表，什么时候删除临时表？](#什么是临时表什么时候会使用到临时表什么时候删除临时表)
      * [大表数据查询如何进行优化？](#大表数据查询如何进行优化)
      * [了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？](#了解慢日志查询吗统计过慢查询吗对慢查询如何优化)
      * [为什么要设置主键？](#为什么要设置主键)
        * [主键一般用自增ID还是UUID？](#主键一般用自增id还是uuid)
      * [字段为什么要设置成not null?](#字段为什么要设置成not-null)
      * [如何优化查询过程中的数据访问？](#如何优化查询过程中的数据访问)
      * [如何优化长难的查询语句？](#如何优化长难的查询语句)
      * [如何优化LIMIT分页？](#如何优化limit分页)
      * [如何优化UNION查询](#如何优化union查询)
      * [如何优化WHERE子句](#如何优化where子句)
      * [SQL语句执行的很慢原因是什么？](#sql语句执行的很慢原因是什么)
      * [SQL语句的执行顺序?](#sql语句的执行顺序)
    * [数据库优化](#数据库优化)
      * [大表如何优化？](#大表如何优化)
      * [什么是垂直分表、垂直分库、水平分表、水平分库？](#什么是垂直分表垂直分库水平分表水平分库)
      * [分库分表后，ID键如何处理？](#分库分表后id键如何处理)
      * [MySQL的复制原理及流程？如何实现主从复制？](#mysql的复制原理及流程如何实现主从复制)
      * [了解读写分离吗？](#了解读写分离吗)
  * [网络](#网络)
    * [什么是网络协议，为什么要对网络协议分层](#什么是网络协议为什么要对网络协议分层)
    * [计算机网络的各层协议及作用](#计算机网络的各层协议及作用)
    * [URI和URL的区别](#uri和url的区别)
    * [DNS的工作流程](#dns的工作流程)
    * [了解ARP协议吗?](#了解arp协议吗)
    * [有了IP地址，为什么还要用MAC地址？](#有了ip地址为什么还要用mac地址)
    * [说一下ping的过程](#说一下ping的过程)
    * [路由器和交换机的区别？](#路由器和交换机的区别)
    * [TCP与UDP有什么区别](#tcp与udp有什么区别)
    * [TCP协议如何保证可靠传输](#tcp协议如何保证可靠传输)
    * [TCP的三次握手及四次挥手](#tcp的三次握手及四次挥手)
      * [三次握手](#三次握手)
      * [四次挥手](#四次挥手)
      * [为什么TCP连接的时候是3次？两次是否可以？](#为什么tcp连接的时候是3次两次是否可以)
      * [为什么TCP连接的时候是3次，关闭的时候却是4次？](#为什么tcp连接的时候是3次关闭的时候却是4次)
      * [TIME\_WAIT和CLOSE\_WAIT的区别在哪?](#time_wait和close_wait的区别在哪)
      * [为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？](#为什么客户端发出第四次挥手的确认报文后要等2msl的时间才能释放tcp连接)
      * [如果已经建立了连接，但是客户端突然出现故障了怎么办？](#如果已经建立了连接但是客户端突然出现故障了怎么办)
    * [HTTP 与 HTTPS 的区别](#http-与-https-的区别)
    * [什么是对称加密与非对称加密](#什么是对称加密与非对称加密)
    * [HTTPS的加密过程](#https的加密过程)
    * [常用HTTP状态码](#常用http状态码)
    * [常见的HTTP方法](#常见的http方法)
    * [GET和POST区别](#get和post区别)
    * [HTTP 1\.0、HTTP 1\.1及HTTP 2\.0的主要区别是什么](#http-10http-11及http-20的主要区别是什么)
    * [Session、Cookie和Token的主要区别](#sessioncookie和token的主要区别)
    * [如果客户端禁止 cookie 能实现 session 还能用吗？](#如果客户端禁止-cookie-能实现-session-还能用吗)
    * [在浏览器中输⼊url地址到显示主⻚的过程](#在浏览器中输url地址到显示主的过程)
    * [Servlet是线程安全的吗](#servlet是线程安全的吗)



## 核心

### JVM、JRE及JDK的关系

JDK（Java Development Kit）：是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。

Java Runtime Environment（JRE）：是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。

JVM是Java Virtual Machine：（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。

> 简单来说就是JDK是Java的开发工具，JRE是Java程序运行所需的环境，JVM是Java虚拟机．它们之间的关系是JDK包含JRE和JVM，JRE包含JVM．

### Java语言的特点

- 种面向对象的语言
- Java虚拟机实现了平台无关性，一次编译，到处运行支持多线程
- 支持网络编程
- 支持多线程
- 具有较高的安全性和可靠性

### Java语言和c++的区别

- Java 通过虚拟机从而实现跨平台特性，一次编译，到处运行，但是 C++ 依赖于特定的平台。
- Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和C 一样的指针。
- Java 支持自动垃圾回收，而 C++ 需要手动回收
- Java 不支持**多重继承**（多重继承需要通过接口去实现），只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
- Java 不支持操作符重载，虽然可以对两个  String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
- Java 的 goto是保留字，但是不可用，C++ 可以使用 goto

### Java的基本数据类型

> 注意：string不是基本数据类型，基本数据类型一共8种。

![1631324232409](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/093713-566942.png)

### 隐式(自动)类型转换和显示(强制)类型转换

隐式(自动)类型转换：从存储范围小的类型到存储范围大的类型

~~~ java
byte → short(char)→ int → long → float → double
~~~

显示(强制)类型转换：从存储范围大的类型到存储范围小的类型

~~~ java
double->float->long->int->short(char)->byte
//该类类型转换很可能存在精度的损失。
~~~

下面看一个案例：

~~~ java
short s = 1; 
s = s + 1;
~~~

这是会报错的，因为1是int 型， s+1 会自动转换为int 型，将int 型直接赋值给short 型会报错。做一下修改即可避免报错:

~~~ java
short s = 1;
s = (short)(s + 1);//做强制类型转换
~~~

或这样写，因为s += 1 会自动进行强制类型转换

~~~ java
short s = 1;
s += 1;//自动进行类型转换
~~~

### 自动装箱与拆箱

- 装箱：将基本类型用包装器类型包装起来
- 拆箱：将包装器类型转换为基本类型

> 这个地方有很多易混淆的地方，但在面试中问到的频率一般，笔试的选择题中经常出现，还
> 有一个String 创建对象和这个比较像，很容易混淆，在下文可以看到

下面这段代码的输出结果是什么？

~~~ java
public class Main {
  public static void main(String[] args) {
    Integer a = 100;
    Integer b = 100;
    Integer c = 128;
    Integer d = 128;
    System.out.println(a==b);
    System.out.println(c==d);
  }
}
true //从缓冲池中取出的同一个对象
false //在堆空间new出来的对象
~~~

很多人看到这个结果会很疑惑，为什么会是一个true 一个flase ．其实从源码中可以很容易找到原因．首先找到Integer 方法中的valueOf 方法,下面来看一下源码：

~~~ java
public static Integer valueOf(int i) {
  if (i >= IntegerCache.low && i <= IntegerCache.high)
  	return IntegerCache.cache[i + (-IntegerCache.low)];//从缓冲池中取出对象
  return new Integer(i);
}
~~~

可以看到当不满足if 语句中的条件，就会重新创建一个对象返回，那结果必然不相等。继续打开IntegerCache 可以看到：

~~~ java
  private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
~~~

我们发现缓冲池中存储的数字范围是[-128,127],大概说的就是在通过valueOf 方法创建Integer 对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的Integer对象。所以上面代码中a 与b 相等， c 与d 不相等。

在看一下下面的代码会输出什么结果：

~~~ java
public class Main {
  public static void main(String[] args) {
    Double a = 1.0;
    Double b = 1.0;
    Double c = 2.0;
    Double d = 2.0;
    System.out.println(a==b);
    System.out.println(c==d);
  }
}
false
false
~~~

采用同样的方法，可以看到Double 的valueOf 方法，每次返回都是重新new 一个新的对象，所以上面代码中的结果都不想等。

~~~ java
public static Double valueOf(double d) {
	return new Double(d);
}
~~~

在看一下下面代码输出的结果：

~~~ java
public class Main {
  public static void main(String[] args) {
    Boolean a = false;
    Boolean b = false;
    Boolean c = true;
    Boolean d = true;
    System.out.println(a==b);
    System.out.println(c==d);
  }
}
true
true
~~~

我们再来看一下valueOf()方法

~~~ java
public static Boolean valueOf(boolean b) {
	return (b ? TRUE : FALSE);
}
~~~

再看看TRUE 和FALSE 是个什么东西，是两个静态成员属性。

~~~ java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);
~~~

> 小结：
>
> Integer 、Short 、Byte 、Character 、Long 这几个类的valueOf 方法的实现是类似的。Double 、Float 的valueOf 方法的实现是类似的。然后是Boolean 的valueOf 方法是单独一组的。

~~~ java
Integer i = new Integer(xxx) 
Integer i =xxx 
//上面两个语句的区别
~~~

这两者的区别主要是第一种会触发自动装箱，第二者不会
最后看看下面这段程序的输出结果

~~~ java
public class Main {
  public static void main(String[] args) {
    Integer a = 1;
    Integer b = 2;
    Integer c = 3;
    Long g = 3L;
    int int1 = 12;
    int int2 = 12;
    Integer integer1 = new Integer(12);
    Integer integer2 = new Integer(12);
    Integer integer3 = new Integer(1);
    System.out.println("c==(a+b) ->"+ (c==(a+b)));
    System.out.println("g==(a+b) ->" + (g==(a+b)));
    System.out.println( "c.equals(a+b) ->" + (c.equals(a+b)));
    System.out.println( "g.equals(a+b) ->" + (g.equals(a+b)));
    System.out.println("int1 == int2 -> " + (int1 == int2));
    System.out.println("int1 == integer1 -> " + (int1 == integer1));
    System.out.println("integer1 == integer2 -> " + (integer1 ==
    integer2));
    System.out.println("integer3 == a1 -> " + (integer3 == a));
  }
}

c==(a+b) ->true
g==(a+b) ->true
c.equals(a+b) ->true
g.equals(a+b) ->false
int1 == int2 -> true
int1 == integer1 -> true
integer1 == integer2 -> false
integer3 == a1 -> false
~~~

下面简单解释这些结果。

1. 当 "=="运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果
   其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。所
   以c==a+b ， g==a+b 为true 。
2. 而对于equals 方法会先触发自动拆箱过程，再触发自动装箱过程。也就是说a+b，会先各自调
   用intValue 方法，得到了加法运算后的数值之后，便调用Integer.valueOf 方法，再进行
   equals 比较。所以c.equals(a+b) 为true 。而对于g.equals(a+b) ， a+b 会先拆箱进行相加
   运算，在装箱进行equals 比较，但是装箱后为Integer ， g 为Long ，所以g.equals(a+b) 为
   false 。
3. int1 == int2 为true 无需解释， int1 == integer1 ，在进行比较时， integer1 会先进行
   一个拆箱操作变成int 型在进行比较，所以int1 == integer1 为true 。
4. integer1 == integer2 -> false 。integer1 和integer2 都是通过new 关键字创建的，可以
    看成两个对象，所以integer1 == integer2 为false 。integer3 == a1 -> false ,
    integer3 是一个对象类型，而a1 是一个常量它们存放内存的位置不一样，所以integer3 ==
    a1 为false ，具体原因可学习下java的内存模型。

### String(不是基本数据类型)

#### String的不可变性



在 Java 8 中， String 内部使用 char 数组存储数据。并且被声明为final ，因此它不可被继承。

~~~ java
public final class String implements java.io.Serializable, Comparable<String>,
CharSequence {
		private final char value[];
}
~~~

为什么Strin g`要设计成不可变的呢（不可变性的好处）:

1. 可以缓存 hash 值（）,因为 String 的hash 值经常被使用，例如String 用做 HashMap 的 key 。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2. 常量池优化,String 对象创建之后，会在**字符串常量池**(这个区域在堆区)中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用,并且可以快速进行GC操作。
3. 线程安全，String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

#### 字符型常量和字符串常量的区别 

1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符

2. 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字
    符串在内存中存放位置)
3. 占内存大小 字符常量占**两个字节** ，字符串常量占若干个字节(至少一个字符结束标志)

#### 什么是字符串常量池？

字符串常量池位于**堆内存中**（在jdk7之后和类变量一起被放到堆区域，目的是进行GC操作释放大量的内存，之前在永久代，GC的频率很低），专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串（相同的字符串在常量池中只会存储一个），在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。

详情请查看String-Table原理：[String-Table原理](https://github.com/justdoitMr/rzf.github.io/blob/main/Note/JVM-String-Table%E5%8E%9F%E7%90%86.md)

#### String 类的常用方法都有那些？

> 面试时一般不会问，但面试或笔试写字符串相关的算法题经常会涉及到，还是得背一背（以下大致
> 是按使用频率优先级排序）

- length() ：返回字符串长度
- charAt() ：返回指定索引处的字符
- substring() ：截取字符串
- trim() ：去除字符串两端空白
- split() ：分割字符串，返回一个分割后的字符串数组。
- replace() ：字符串替换。
- indexOf() ：返回指定字符的索引。
- toLowerCase() ：将字符串转成小写字母。
- toUpperCase() ：将字符串转成大写字符。

#### String和StringBuffer、StringBuilder的区别是什么？

1. 可变性

String 不可变， StringBuilder 和StringBuffer 是可变的,具体体现在final关键字上。

2. 线程安全

String 由于是不可变的，所以线程安全，StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁（但是多个方法的组合并不是线程安全的），所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

3. 性能

StringBuilder > StringBuffer > String

**小结：**

![1631326632419](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/101713-439730.png)

#### switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 

switch 可以作用于char byte short int 及它们对应的包装类型， switch 不可作用于long,double float boolean 及他们的包装类型。在 JDK1.5之后可以作用于枚举类型，在JDK1.7之后可作用于String 类型。

### Java语言采用何种编码方案？有何特点？

Java语言采用Unicode编码标准，它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。

### 访问修饰符

在Java编程语言中有四种权限访问控制符，这四种访问权限的控制符能够控制类中成员的可见性。其中类有两种public 、default 。而方法和变量有 4 种： public 、default 、protected 、private 。

- public : 对所有类可见。使用对象：类、接口、变量、方法
- protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
- default : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

**小结**

![1631326967136](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/102247-924926.png)

### 运算符

- **&&和&**
  && 和& 都可以表示逻辑与，但他们是有区别的，共同点是他们两边的条件都成立的时候最终结果才是true ；不同点是&& 只要是第一个条件不成立为false ，就不会再去判断第二个条件，最终结果直接为false ，而& 判断的是所有的条件。
- **||和|**
  || 和| 都表示逻辑或，共同点是只要两个判断条件其中有一个成立最终的结果就是true ，区别是|| 只要满足第一个条件，后面的条件就不再判断，而| 要对所有的条件进行判断。

### 关键字

#### static关键字

static 关键字的主要用途就是方便在没有创建对象时调用方法和变量和优化程序性能。（static修饰的变量和方法属于类）

**static变量（静态变量）**
用static 修饰的变量被称为静态变量，也被称为类变量，可以直接通过类名来访问它。静态变量被所有的对象共享，在内存中只有一个副本，仅当在类初次加载时会被初始化，而非静态变量在创建对象的时候被初始化，并且存在多个副本，各个对象拥有的副本互不影响。

**static方法(静态方法)**
static 方法不依赖于任何对象就可以进行访问，在static 方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用，但是在非静态成员方法中是可以访问静态成员方法/变量的。

~~~ java
public class Main {
  public static String s1 = "s1";//静态变量
  String s2 = "s2";
  public void fun1(){
    System.out.println(s1);
    System.out.println(s2);
  }
  public static void fun2(){
    System.out.println(s1);
    System.out.println(s2);//此处报错，静态方法不能调用非静态变量
  }
}
~~~

**static代码块（静态代码块）**
静态代码块的主要用途是可以用来优化程序的性能，因为它只会在类加载时加载一次，很多时候会将一些只需要进行一次的初始化操作都放在static 代码块中进行。如果程序中有多个static 块，在类初次被加载的时候，会按照static 块的顺序来执行每个static 块。

~~~ java
public class Main {
  static {
 	 	System.out.println("hello,word");
  }
  public static void main(String[] args) {
  	Main m = new Main();
  }
}
~~~

**可以通过this访问静态成员变量吗？（可以）**
this 代表当前对象，可以访问静态变量，而静态方法中是不能访问非静态变量,也不能使用this 引用。

**初始化顺序**

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。如果存在继承关系的话，初始化顺序为父类中的静态变量和静态代码块——子类中的静态变量和静态代码块——父类中的实例变量和普通代码块——父类的构造函数——子类的实例变量和普通代码块——子类的构造函数。

#### final关键字

final 关键字主要用于修饰类，变量，方法。
1. 类：被final 修饰的类不可以被**继承**
2. 方法：被final 修饰的方法不可以被**重写**
3. 变量：被final 修饰的变量是基本类型，变量的数值**不能改变**；被修饰的变量是引用类型，变量便
   不能在引用其他对象(引用不可以改变)，但是变量所引用的对象本身是可以改变的。

~~~ java
public class Main {
  	int a = 1;
  public static void main(String[] args) {
    final int b = 1;
    b = 2;//报错
    final Main m = new Main();
    m.a = 2;//不报错,可以改变引用类型变量所指向的对象
  }
}
~~~

> 详细可以参考：[Java关键字总结](https://github.com/justdoitMr/rzf.github.io/blob/main/Note/Java%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93.md)

#### final finally finalize区别

- final 主要用于修饰类，变量，方法
- finally 一般作用在try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize 是一个属于Object 类的一个方法，该方法一般由垃圾回收器来调用，当我们调用
  System.gc() 方法的时候，由垃圾回收器调用finalize() ，回收垃圾，但Java语言规范并不保证inalize 方法会被及时地执行、而且根本不会保证它们会被执行。

#### this关键字

> 重点掌握前三种即可

1. this 关键字可用来引用当前类的实例变量。主要用于形参与成员名字重名，用this 来区分。

~~~ java
public Person(String name, int age) {
  this.name = name;
  this.age = age;
}
~~~

2. this 关键字可用于调用当前类方法。
3. this() 可以用来调用当前类的构造函数。(注意： this() 一定要放在构造函数的第一行，否则编译不通过)

~~~ java
class Person{
  private String name;
  private int age;
  	public Person() {
  }
  public Person(String name) {
  	this.name = name;
  }
  public Person(String name, int age) {
    this(name);
    this.age = age;
  }
}
~~~

4. this 关键字可作为调用方法中的参数传递。

5. this 关键字可作为参数在构造函数调用中传递。
6. this 关键字可用于从方法返回当前类的实例。

#### super关键字

1. super 可以用来引用直接父类的实例变量。和this 类似，主要用于区分父类和子类中相同的字段
2. super 可以用来调用直接父类构造函数。(注意： super() 一定要放在构造函数的第一行，否则编译不通过)
3. super 可以用来调用直接父类方法。

~~~ java
public class Main {
  public static void main(String[] args) {
    Child child = new Child("Father","Child");
    child.test();
  }
}
class Father{
  protected String name;
	public Father(String name) {
		this.name = name;
	}
	public void Say(){
		System.out.println("hello,child");
	}
}
class Child extends Father{
  private String name;
  public Child(String name1, String name2) {
    super(name1); //调用直接父类构造函数
    this.name = name2;
  }
  public void test(){
    System.out.println(this.name);
    System.out.println(super.name); //引用直接父类的实例变量
    super.Say(); //调用直接父类方法
  }
}
~~~

#### this和super的区别

**相同点：**

1. super() 和this() 都必须在构造函数的第一行进行调用，否则就是错误的
2. this() 和super() 都指的是对象，所以，均不可以在static 环境中使用。

**不同点：**

1. super() 主要是对父类构造函数的调用， this() 是对重载构造函数的调用
2. super() 主要是在继承了父类的子类的构造函数中使用，是在不同类中的使用； this() 主要是在同一类的不同构造函数中的使用

#### break ,continue ,return 的区别及作用

- break 结束当前的循环体
- continue 结束本次循环,进入下一次循环
- return 结束当前方法

### 面向对象和面向过程的区别

- 面向过程
  - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。
  - 缺点：没有面向对象易维护、易复用、易扩展
- 面向对象
  - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合
    的系统，使系统更加灵活、更加易于维护
  - 缺点：性能比面向过程低

### 面向对象三大特性(封装、继承、多态)

**封装**
封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。
**继承**
继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。
**多态（重要）**
多态是同一个行为具有多个不同表现形式或形态的能力。这句话不是很好理解，可以看这个解释，在Java语言中，多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中实现多态的三个必要条件：继承、重写、向上转型。继承和重写很好理解，向上转型是指在多态中需要将子类的引用赋给父类对象。

### 面向对象五大基本原则是什么

**单一职责原则（Single-Resposibility Principle）**
一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
**开放封闭原则（Open-Closed principle）**
软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。
**里氏替换原则 （Liskov-Substituion Principle）**

子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。

**依赖倒置原则（Dependecy-Inversion Principle）**
依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
**接口隔离原则（Interface-Segregation Principle）**
使用多个小的专门的接口，而不要使用一个大的总接口。

### 抽象类和接口的对比

在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。抽象类：用来捕捉子类的通用特性的。接口：抽象方法的集合。

**相同点：**

- 接口和抽象类都不能实例化
- 都包含抽象方法，其子类都必须覆写这些抽象方法

**不同点**

![1631329032503](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/105713-951714.png)

### 在Java中定义一个不做事且没有参数的构造方法的作用

Java程序存在继承，在执行子类的构造方法时，如果没有用super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。如果父类只定义了有参数的构造函数，而子类的构造函数没有用super 调用父类那个特定的构造函数，就会出错。另外在使用反射机制和序列化机制的时候，需要提供无参构造函数。

### 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是

帮助子类进行初始化工作

### 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

### 构造方法有哪些特性？

- 方法名称和类同名
- 不用定义返回值类型
- 不可以写retrun 语句
- 构造方法可以被重载

### 变量

- 类变量：独立于方法之外的变量，用static 修饰。
- 实例变量：独立于方法之外的变量，不过没有 static 修饰。
- 局部变量：类的方法中的变量。
- 成员变量：成员变量又称全局变量，可分为类变量和实例变量，有static 修饰为类变量，没有static 修饰为实例变量。

**小结**

![1631337065132](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/131118-685562.png)

### 内部类

内部类包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类

**成员内部类**

成员内部类定义为位于另一个类的内部，成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private 成员和静态成员）。

~~~ java
class Outer{
  private double a = 0;
  public static int b =1;
  public Outer(double a) {
  	this.a = a;
  }
  class Inner { //内部类
    public void fun() {
    System.out.println(a);
    System.out.println(b);
    }
  }
}
~~~

当成员内部类拥有和外部类同名的成员变量或者方法时，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类. this .成员变量。

在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。
**成员内部类是依附外部类而存在的**，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：

~~~ java
class Outter{
  private double a = 0;
  public static int b =1;
  public Outter(){}
  public Outter(double a) {
    this.a = a;
    Inner inner = new Inner();
    inner.fun(); //调用内部类的方法
  }
  class Inner { //内部类
  int b = 2;
  public void fun() {
    System.out.println(a);
    System.out.println(b); //访问内部类的b
    System.out.println(Outter.this.b);//访问外部类的b
    }
  }
}
public class Main{
  public static void main(String[] args) {
    Outter outter = new Outter();
    Outter.Inner inner = outter.new Inner(); //创建内部类的对象
  }
}
~~~

**局部内部类**

**局部内部类是定义在一个方法或者一个作用域里面的类**，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。

~~~ java
class Outter {
  private int outter_a = 1;
  private static int static_b = 2;
  public void test1(){
    int inner_c =3;
  class Inner {
    private void fun(){
    System.out.println(outter_a);
    System.out.println(static_b);
    System.out.println(inner_c);
  }
}
Inner inner = new Inner(); //创建局部内部类
inner.fun();
}
public static void test2(){
  int inner_d =3;
  class Inner {
  private void fun(){
    System.out.println(outter_a); //编译错误，定义在静态方法中的局部
    类不可以访问外部类的实例变量
    System.out.println(static_b);
    System.out.println(inner_d);
    }
  }
  Inner inner = new Inner();
  inner.fun();
  }
}
~~~

**匿名内部类**

匿名内部类只没有名字的内部类，在日常开发中使用较多。使用匿名内部类的前提条件：必须继承一个父类或实现一个接口。

~~~ java
interface Person {
	public void fun();
}
class Demo {
  public static void main(String[] args) {
    new Person() {
      public void fun() {
      	System.out.println("hello,word");
      }
    }.fun();
  }
}
~~~

**静态内部类**

静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static 。静态内部类是不需要依赖于外部类的，并且它不能使用外部类的非static 成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static 成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。

~~~ java
class Outter {
  int a = 1;
  static int b = 2;
  public Outter() {
  }
  static class Inner {
  public Inner() {
    System.out.println(a);//报错，静态内部类不能访问非静态变量
    System.out.println(b);
    }
  }
}
public class Main{
  public static void main(String[] args) {
  	Outter.Inner inner = new Outter.Inner();
  }
}
~~~

**内部类的优点**

1. 内部类不为同一包的其他类所见，具有很好的封装性；

2. 匿名内部类可以很方便的定义回调。
3. 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实
    现，对于内部类都没有影响。
4. 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。

局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final ？

~~~ java
public class Main {
  public static void main(String[] args) {
  }
  public void fun(final int b) {
      final int a = 10;
      new Thread(){
      public void run() {
        System.out.println(a);
        System.out.println(b);
      };
  	}.start();
  }
}
~~~

对于变量a 可以从生命周期的角度理解，局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，如果局部内部类要调用没有final 修饰的局部变量时，就会造成生命周期不一致出错。
对于变量b ，其实是将fun 方法中的变量b 以参数的形式对匿名内部类中的拷贝（变量b 的拷贝）进行赋值初始化。在run 方法中访问的变量b 根本就不是test 方法中的局部变量b ，而是一个拷贝值，所以不存在生命周期不一致的问题，但如果在run 方法中修改变量b 的值会导致数据不一致，所以需要加final 修饰。

### 重写与重载

#### 重载与重写的区别

重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private 则子类中就不是重写。

#### 构造器（constructor）是否可被重写（override）

构造器可以被重载，不能被重写

#### 重载的方法能否根据返回类型进行区分？为什么？

不能，因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。

### == 和 equals 的区别

`==`
对于基本数据类型， == 比较的是值；对于引用数据类型， == 比较的是内存地址。
**eauals**
对于没有重写equals 方法的类， equals 方法和== 作用类似；对于重写过equals 方法的类，equals 比较的是值。

### hashCode 与 equals（为什么重写equals方法后，hashCode方法也必须重写）

**equals**

先看下String 类中重写的equals 方法。

![1631338169393](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/132929-690894.png)

从源码中可以看到：

1. equals 方法首先比较的是内存地址，如果内存地址相同，直接返回true ；如果内存地址不同，再比较对象的类型，类型不同直接返回false ；类型相同，再比较值是否相同；值相同返回true ，值不同返回false 。总结一下， equals 会比较内存地址、对象类型、以及值，内存地址相同， equals 一定返回true ；对象类型和值相同， equals 方法一定返回true 。

2. 如果没有重写equals 方法，那么equals 和== 的作用相同，比较的是对象的地址值。

**hashCode**

hashCode 方法返回对象的散列码，返回值是int 类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。

关于hashCode 有一些约定：

1. 两个对象相等，则hashCode 一定相同。

2. 两个对象有相同的hashCode 值，它们不一定相等。
3. hashCode() 方法默认是对堆上的对象产生独特值，如果没有重写hashCode() 方法，则该类的两个对象的hashCode 值肯定不同

**为什么重写equals 方法后， hashCode 方法也必须重写**

1. 根据规定，两个对象相等， hashCode 值也许相同，所以重写equals 方法后， hashCode 方法也必须重写（面试官肯定不是想听这个答案）

2. hashCode 在具有哈希机制的集合中起着非常关键的作用，比如HashMap 、HashSet 等。以HashSet 为例， HashSet 的特点是存储元素时无序且唯一，在向HashSet 中添加对象时，首相会计算对象的HashCode 值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的HashCode 值相同），调用equals 方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。所以重写equals 方法后， hashCode方法不重写的话，会导致所有对象的HashCode 值都不相同，都能添加成功，那么HashSet中会出现很多重复元素， HashMap 也是同理（因为HashSet 的底层就是通过HashMap 实现的），会出现大量相同的Key （ HashMap 中的key 是唯一的，但不同的key 可以对应相同的value ）。所以重写equals 方法后， hashCode 方法也必须重写。同时因为两个对象的hashCode 值不同，则它们一定不相等，所以先计算对象的hashCode 值可以在一定程度上判断两个对象是否相等，提高了集合的效率。总结一下，一共两点：第一，在HashSet 等集合中，不重写hashCode 方法会导致其功能出现问题；第二，可以提高集合效率。

### Java 中是值传递还是引用传递，还是两者共存 

> 这是一个很容易搞混又很难解释清楚的问题，先说结论，Java中只有值传递

首先看下面的代码：

~~~ java
public class Main{
  public static void main(String[] args) {
    int a = 1;
    printValue(a);
    System.out.println("a:" + a);
  }
public static void printValue(int b){
    b = 2;
    System.out.println("b:"+ b);
  }
}
//输出
b:2
a:1
~~~

可以看到将a 的值传到printValue 方法中，并将其值改为2。但方法调用结束后， a 的值还是1，并未发生改变，所以这种情况下为值传递。再看下面这段代码

~~~ java
public class Main{
  public static void main(String[] args) {
    Preson p = new Preson();
    p.name = "zhangsan";
    printValue(p);
    System.out.println("p.name: " + p.name);
  }
  public static void printValue(Preson q){
    q.name = "lisi";
    System.out.println("q.name: "+ q.name);
  }
}
class Preson{
	public String name;
}
//结果
q.name: lisi
p.name: lisi
~~~

在将p 传入printValue 方法后，方法调用结束， p 的name 属性竟然被改变了！所以得出结论，参数为基本类型为值传递，参数为引用类型为时为引用传递。这个结论是错误的，下面来看看判断是值传递还是值传递的关键是什么，先看定义

- 值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
- 引用传递：是指在调用函数时将实际参数的**地址**直接传递到函数中，那么在函数中对参数所进行的
  修改，将影响到实际参数。

从定义中可以明显看出，区分是值传递还是引用传递主要是看向方法中传递的是实际参数的副本还是实际参数的地址。上面第一个例子很明显是值传递，其实第二个例子中向printValue 方法中传递的是一个**引用的副本**，只是这个副本引用和原始的引用指向的同一个对象，所以副本引用修改过对象属性后，通过原始引用查看对象属性肯定也是被修改过的。换句话说， printValue 方法中修改的是副本引用指向的对象的属性，不是引用本身，如果修改的是引用本身，那么原始引用肯定不受影响。真是的引用是c语言或者c++语言中才有的，因为里面有指针传递，而指针刚好就是地址，看下面这个例子

~~~ java
public class Main{
  public static void main(String[] args) {
    Preson p = new Preson();
    p.name = "zhangsan";
    printValue(p);
    System.out.println("p.name: " + p.name);
  }
    public static void printValue(Preson q){
      q = new Preson();
      q.name = "lisi";
      System.out.println("q.name: "+ q.name);
    }
}
class Preson{
	public String name;
}
//结果
q.name: lisi
p.name: zhangsan
~~~

可以看到将p 传入printValue 方法后， printValue 方法调用结束后， p 的属性name 没有改变，这是因为在printValue方法中并没有改变副本引用q 所指向的对象，而是改变了副本引用q 本身，将副本引用q 指向了另一个对象并对这个对象的属性进行修改，所以原始引用p 所指向的对象不受影响。所以证明Java中只存在值传递。

### IO流

Java IO流主要可以分为输入流和输出流。按照照操作单元划分，可以划分为字节流和字符流。按照流的角色划分为节点流和处理流。
**Java I0流的40多个类都是从4个抽象类基类中派生出来的。**

- InputStream：字节输入流
- Reader：字符输入流
- OutputStream：字节输出流
- Writer：字符输出流

### BIO,NIO,AIO 有什么区别?

BIO (Blocking I/O)：服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io

NIO (New I/O)：服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，jdk1,4开始支持

AIO (Asynchronous I/O)：服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。
这些概念看着比较枯燥，可以从这个经典的烧开水的例子去理解

BIO ：来到厨房，开始烧水NIO，并坐在水壶面前一直等着水烧开。
NIO：来到厨房，开AIO始烧水，但是我们不一直坐在水壶前面等，而是做些其他事，然后每隔几分钟到厨房看一下水有没有烧开。
AIO：来到厨房，开始烧水，我们不一直坐在水壶前面等，而是在水壶上面装个开关，水烧开之后它会通知我。

### 反射

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
Java获取Class对象的三种方式

~~~ java
class Person {
  public String name = "zhangsan";
  	public Person() {
  }
}

public class Main{
  public static void main(String[] args) throws ClassNotFoundException {
    //方式1
    Person p1 = new Person();
    Class c1 = p1.getClass();
    //方式2
    Class c2 = Person.class;
    //方式3可能会抛出ClassNotFoundException异常
    Class c3 = Class.forName("com.company");
  }
}
~~~

因为在一个类在 JVM 中只会有一个 Class 实例，所以对c1 、c2 、c3 进行equals 比较时返回的都是true 。

**反射优缺点：**

- 优点：运行期类型的判断，动态加载类，提高代码灵活度。
- 缺点：性能比直接的java代码要慢很多。

反射应用场景：

- Java的很多框架都用到了反射，例如Spring 中的xml的配置模式等
- 动态代理设计模式也采用了反射机制

### JAVA异常

异常主要分为Error 和Exception 两种

- Error： Error 类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理。
- EXception： Exception 以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。

**异常框图**

![1631339302016](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/134824-327309.png)

除了以上的分类，异常还能分为非检查异常和检查异常

- 非检查异常（unckecked exception）：该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch 捕获它，也没有使用throws 抛出该异常，编译也会正常通过。因为这样的异常发生的原因很可能是代码写的有问题。
- 检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。这是编译器要求必须处理的异常。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，所以必须处理这些异常。

> 下面来看下try{}catch(){}finally{} 和return 之间的“恩恩怨怨”，这里有些乱，面试时问的也不是很多，实在记不住就算啦。还是先看代码猜结果。

~~~ java
public class Main {
        public static void main(String[] args) {
            int a = test1();
            System.out.println(a);
            int b = test2();
            System.out.println(b);
            int c = test3();
            System.out.println(c);
            int d = test4();
            System.out.println(d);
            int e = test5();
            System.out.println(e);
        }

        public static int test1() {
            int a = 1;
            try {
                a = 2;
                return a;
            } catch (Exception e) {
                System.out.println("hello,test1");
                a = 3;
            } finally {
                a = 4;
            }
            return a;
        }

        //输出 2
        public static int test2() {
            int a = 1;
            try {
                a = 2;
                return a;
            } catch (Exception e) {
                System.out.println("hello,test2");
                a = 3;
                return a;
            } finally {
                a = 4;
            }
        }
//输出 2
catch()

        {
        }

        public static int test3() {
            int a = 1;
            try {
                a = 2 / 0;
                return a;
            } catch (Exception e) {
                System.out.println("hello,test3");
                a = 3;
            } finally {
                a = 4;
            }
            return a;
        }

        //输出 hello,test3
// 4
        public static int test4() {
            int a = 1;
            try {
                a = 2 / 0;
                return a;
            } catch (Exception e) {
                System.out.println("hello,test4");
                a = 3;
                return a;
            } finally {
                a = 4;
            }
        }

        //输出 hello,test4
// 3
        public static int test5() {
            int a = 1;
            try {
                a = 2 / 0;
                return a;
            } catch (Exception e) {
                a = 3;
                return a;
            } finally {
                a = 4;
                return a;
            }
        }
//输出 4
    }

~~~

如果没有仔细的研究过，应该好多会猜错，下面总结下规律。
1. 从前三个例子可以看出如果try{} 中的代码没有异常， catch(){} 代码块中的代码不会执行。所以如果try{} 和catch(){} 都含有return 时，无异常执行try{} 中的return ，存在异常执行catch(){} 的return 
2. 不管任何情况，就算try{} 或catch(){} 中含有return ， finally{} 中的代码一定会执行，那么为什么test1 、test2 、test3 中的结果不是4呢，因为虽然finally 是在return 后面的表达式运算之后执行的，但此时并没有返回运算之后的值，而是把值保存起来，不管finally 对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。
3. 如果return 的数据是引用数据类型，而在finally 中对该引用数据类型的属性值的改变起作用，try 中的return 语句返回的就是在finally 中改变后的该属性的值。这个不理解可以看看上面提到的Java的值传递的问题。
4. 如果finally{} 中含有return ，会导致程序提前退出，不在执行try{} 或catch(){} 中的return 。所以test5 返回的值是4。

最后总计一下try{}catch(){}finally{} 的执行顺序。
1. 先执行try 中的语句，包括return 后面的表达式；
2. 有异常时,执行catch 中的语句，包括return 后面的表达式，无异常跳过catch 语句；
3. 然后执行finally 中的语句，如果finally 里面有return 语句，执行return 语句，程序结束；
4. finally{} 中没有return 时，无异常执行try 中的return ，如果有异常时则执行catch 中的return 。前两步执行的return 只是确定返回的值，程序并未结束， finally{} 执行之后，最后将前两步确定的return 的返回值返回。

### Java注解

> 面试问的不多，但是在使用框架开发时会经常使用，但东西太多了，这里只是简单介绍下概念。

Annotation 注解可以看成是java中的一种标记记号，用来给java中的类，成员，方法，参数等任何程序元素添加一些额外的说明信息，同时不改变程序语义。注解可以分为三类：基本注解，元注解，自定义注解

**标准注解**

1. @Deprecated：该注解用来说明程序中的某个元素（类，方法，成员变量等）已经不再使用，如果使用的话的编译器会给出警告。

2. @SuppressWarnings(value=“”)：用来抑制各种可能出现的警告。
3. @Override：用来说明子类方法覆盖了父类的方法，保护覆盖方法的正确使用

元注解（元注解也称为元数据注解，是对注解进行标注的注解，元注解更像是一种对注解的规范说明，用来对定义的注解进行行为的限定。例如说明注解的生存周期，注解的作用范围等）
1. @Target(value=“ ”)：该注解是用来限制注解的使用范围的，即该注解可以用于哪些程序元
    素。
2. @Retention(value=“ ”)：用于说明注解的生存周期
3. @Documnent：用来说明指定被修饰的注解可以被javadoc.exe工具提取进入文档中，所有使
    用了该注解进行标注的类在生成API文档时都在包含该注解的说明。
4. @Inherited：用来说明使用了该注解的父类，其子类会自动继承该注解。
5. @Repeatable：java1.8新出的元注解，如果需要在给程序元素使用相同类型的注解，则需将
    该注解标注上。

自定义注解：用@Interface来声明注解。

### Java泛型

Java 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

**泛型擦除（这是面试考察泛型时经常问到的问题）**

Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。看下面代码：

~~~ java
public class Main{
        public static void main(String[] args) {
            ArrayList<Integer> arrayList1 = new ArrayList<>();
            ArrayList<String> arrayList2 = new ArrayList<>();
            System.out.println(arrayList1.getClass() == arrayList2.getClass());
        }
    }
//结果
true
~~~

可以看到ArrayList<Integer> 和ArrayList<String> 的原始类型是相同，在编译成字节码文件后都会变成List ，JVM看到的只有List ，看不到泛型信息，这就是泛型的类型擦除。在看下面这段代码

~~~ java
public class Main{
        public static void main(String[] args) throws Exception {
            ArrayList<Integer> arrayList = new ArrayList<>();
            arrayList.add(1);
            arrayList.getClass().getMethod("add",
                    Object.class).invoke(arrayList, "a");
            System.out.println(arrayList.get(0));
            System.out.println(arrayList.get(1));
        }
    }
//结果
1
a
~~~

- 可以看到通过反射进行add 操作， ArrayList<Integer> 竟然可以存储字符串，这是因为在反射就是在运行期调用的add 方法，在运行期泛型信息已经被擦除。
- 既然存在类型擦除，那么Java是如何保证在ArrayList<Integer> 添加字符串会报错呢？
  Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。

### JAVA序列化

- 序列化：将对象写入到IO流中
- 反序列化：从IO流中恢复对象
- 序列化的意义：将Java对象转换成字节序列，这些字节序列更加便于通过网络传输或存储在磁盘上，在需要时可以通过反序列化恢复成原来的对象。
- 实现方式
  - 实现Serializable接口
  - 实现Externalizable接口
- 序列化的注意事项：
  - 对象的类名、实例变量会被序列化；方法、类变量、transient 实例变量都不会被序列化。
  - 某个变量不被序列化，可以使用transient 修饰。
  - 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。
  - 反序列化时必须有序列化对象的class 文件。

### 深拷贝和浅拷贝

深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，两个引用指向两个对象，但对象内容相同。
浅拷贝：对基本数据类型进行值传递，对引用数据类型复制一个引用指向原始引用的对象，就是复制的引用和原始引用指向同一个对象。

看下面图：

![1631340064173](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/11/140105-751355.png)

深拷贝的实现方式

1. 重载clone 方法

~~~ java
public class Main {
        public static void main(String[] args) throws NoSuchMethodException,
                InvocationTargetException, IllegalAccessException,
                CloneNotSupportedException {
            Address s = new Address("天津");
            Person p = new Person("张三", 23, s);
            System.out.println("克隆前的地址：" + p.getAddress().getName());
            Person cloneP = (Person) p.clone();
            cloneP.getAddress().setName("北京");
            System.out.println("克隆后的地址：" +
                    cloneP.getAddress().getName());
        }
    }

    class Address implements Cloneable {
        private String city;

        public Address(String name) {
            this.city = name;
        }

        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }

        public String getName() {
            return city;
        }

        public void setName(String name) {
            this.city = name;
        }
    }

    class Person implements Cloneable {
        private String name;
        private int age;
        private Address address;

        public Person(String name, int age, Address address) {
            this.name = name;
            this.age = age;
            this.address = address;
        }

        @Override
        public Object clone() throws CloneNotSupportedException {
            Person person = (Person) super.clone();
            person.address = (Address) address.clone();
            return person;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public Address getAddress() {
            return address;
        }

        public void setAddress(Address address) {
            this.address = address;
        }
    }
//结果
克隆前的地址：天津
克隆后的地址：北京
~~~

其实就是Person 类和Address 类都要重写clone 方法，这里面需要注意的一点是super.clone() 为浅克隆，所以在在Person 类中重写clone 方法时， address 对象需要调用address.clone() 重新赋值，因为address 类型为引用类型。

2. 序列化

~~~ java
 public class Main {
        public static void main(String[] args) throws IOException,
                ClassNotFoundException {
            Address s = new Address("天津");
            Person p = new Person("张三", 23, s);
            System.out.println("克隆前的地址：" + p.getAddress().getName());
            Person cloneP = (Person) p.deepClone();
            cloneP.getAddress().setName("北京");
            System.out.println("克隆后的地址：" +
                    cloneP.getAddress().getName());
        }
    }

    class Address implements Serializable {
        private String city;

        public Address(String name) {
            this.city = name;
        }

        public String getName() {
            return city;
        }

        public void setName(String name) {
            this.city = name;
        }
    }

    class Person implements Serializable {
        private String name;
        private int age;
        private Address address;

        public Person(String name, int age, Address address) {
            this.name = name;
            this.age = age;
            this.address = address;
        }

        public Object deepClone() throws IOException, ClassNotFoundException {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            ByteArrayInputStream bis = new
                    ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);
            return ois.readObject();
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public Address getAddress() {
            return address;
        }

        public void setAddress(Address address) {
            this.address = address;
        }
    }
//输出
克隆前的地址：天津
克隆后的地址：北京
~~~

### 常见的Object方法

> 这些方法都很重要，面试经常会问到，要结合其他知识将这些方法理解透彻

- Object clone() ：创建与该对象的类相同的新对象
- boolean equals(Object) ：比较两对象是否相等
- void finalize() ：当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法
- Class getClass() ：返回一个对象运行时的实例类
- int hashCode() ：返回该对象的散列码值
- void notify() ：唤醒等待在该对象的监视器上的一个线程
- void notifyAll() ：唤醒等待在该对象的监视器上的全部线程
- String toString() ：返回该对象的字符串表示
- void wait() ：在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待

## 集合

### 常用的集合类有哪些

Map接口和Collection接口是所有集合框架的父接口。下图中的实线和虚线看着有些乱，其中接口与接口之间如果有联系为继承关系，类与类之间如果有联系为继承关系，类与接口之间则是类实现接口。重点掌握的抽象类有 HashMap ， LinkedList ， HashTable ， ArrayList ， HashSet ， Stack ，TreeSet ， TreeMap 。注意： Collection 接口不是 Map 的父接口。 

![1631410295108](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/12/093136-823698.png)

![1631409999135](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/12/093102-794935.png)

**大图**

![](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/31/131640-548931.png)

### List，Set，Map三者的区别？ 

List ：有序集合（有序指存入的顺序和取出的顺序相同，不是按照元素的某些特性排序），可存储重复元素，可存储多个 null 。 

Set：无序集合（元素存入和取出顺序不一定相同），不可存储重复元素，只能存储一个。

Map：使用键值对的方式对元素进行存储，是无序的，且是唯一的。值不唯一。不同的键可以对应相同的值。

### 常用集合框架底层数据结构 

- List：
  - ArrayList ：数组
  - LinkedList ：双线链表 
- Set ：
  - HashSet ：底层基于 HashMap 实现， HashSet 存入读取元素的方式和 HashMap 中的 Key 是一致的。值存储在key位置，而value存储object对象。
  - TreeSet ：红黑树 
- Map ：
  - HashMap ： JDK1.8之前 HashMap 由数组+链表组成的， JDK1.8之后有数组+链表/红黑树组成，当链表长度大于8时，链表转化为红黑树，当长度小于6时，从红黑树转化为链表。这样做的目的是能提高 HashMap 的性能，因为红黑树的查找元素的时间复杂度远小于链表。
  - HashTable ：数组+链表，线程安全，效率低。
  - TreeMap ：红黑树 

![](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/31/131740-215003.png)

### 哪些集合类是线程安全的？ 

- Vector ：相当于有同步机制的 ArrayList
- Stack ：栈
- HashTable：使用synchronized保证线程安全。
- enumeration ：枚举 

### 迭代器 Iterator 是什么 

Iterator 是 Java 迭代器最简单的实现，它不是一个集合，它是一种用于访问集合的方法， Iterator接口提供遍历任何 Collection 的接口 。

### Java集合的快速失败机制 “fail-fast”和安全失败机制“failsafe”是什么？ 

**快速失败**
Java的快速失败机制是Java集合框架中的一种错误检测机制，当多个线程同时对集合中的内容进行修改时可能就会抛出 ConcurrentModificationException 异常。其实不仅仅是在多线程状态下，在单线程中用增强 for 循环中一边遍历集合一边修改集合的元素也会抛出ConcurrentModificationException 异常。看下面代码 

~~~ java
public class Main{
  public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    for(Integer i : list){
      list.remove(i); //运行时抛出ConcurrentModificationException异常
    }
  }
}
~~~

正确的做法是用迭代器的 remove() 方法，便可正常运行。 

~~~ java
public class Main{
  public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    Iterator<Integer> it = list.iterator();
    while(it.hasNext()){
    	it.remove();
    }
  }
}
~~~

造成这种情况的原因是什么？细心的同学可能已经发现两次调用的 remove() 方法不同，一个带参数据，一个不带参数，这个后面再说，经过查看 ArrayList 源码，找到了抛出异常的代码 

~~~ java
final void checkForComodification() {
  if (modCount != expectedModCount)
  	throw new ConcurrentModificationException();
}
~~~

从上面代码中可以看到如果 modCount 和 expectedModCount 这两个变量不相等就会抛出
ConcurrentModificationException 异常。那这两个变量又是什么呢？继续看源码 

~~~ java
protected transient int modCount = 0; //在AbstractList中定义的变量

int expectedModCount = modCount;//在ArrayList中的内部类Itr中定义的变量
~~~

从上面代码可以看到， modCount 初始值为0，而 expectedModCount 初始值等于 modCount 。也就是说在遍历的时候直接调用集合的 remove() 方法会导致 modCount 不等于 expectedModCount进而抛出 ConcurrentModificationException 异常，而使用迭代器的 remove() 方法则不会出现这种问题。那么只能在看看 remove() 方法的源码找找原因了 

~~~ java
public E remove(int index) {
  rangeCheck(index);
  modCount++;
  E oldValue = elementData(index);
  int numMoved = size - index - 1;
  if (numMoved > 0)
    System.arraycopy(elementData, index+1, elementData, index,
    numMoved);
  elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
~~~

从上面代码中可以看到只有 modCount++ 了，而 expectedModCount 没有操作，当每一次迭代时，迭代器会比较 expectedModCount 和 modCount 的值是否相等，所以在调用 remove() 方法后，modCount 不等于 expectedModCount 了，这时就了报 ConcurrentModificationException 异常。但用迭代器中 remove() 的方法为什么不抛异常呢？原来迭代器调用的 remove() 方法和上面的 remove() 方法不是同一个！迭代器调用的 remove() 方法长这样： 

~~~ java
public void remove() {
  if (lastRet < 0)
    throw new IllegalStateException();
  checkForComodification();
  try {
    ArrayList.this.remove(lastRet);
    cursor = lastRet;
    lastRet = -1;
    expectedModCount = modCount; //这行代码保证了expectedModCount和modCount是相等的
  } catch (IndexOutOfBoundsException ex) {
  throw new ConcurrentModificationException();
  }
}
~~~

从上面代码可以看到 expectedModCount = modCount ，所以迭代器的 remove() 方法保证了expectedModCount 和 modCount 是相等的，进而保证了在增强 for 循环中修改集合内容不会报ConcurrentModificationException 异常。 

上面介绍的只是单线程的情况，用迭代器调用 remove() 方法即可正常运行，但如果是多线程会怎么样呢？

答案是在多线程的情况下即使用了迭代器调用 remove() 方法，还是会报ConcurrentModificationException 异常。这又是为什么呢？还是要从 expectedModCount 和modCount 这两个变量入手分析，刚刚说了 modCount 在 AbstractList 类中定义，而expectedModCount 在 ArrayList 内部类中定义，所以 modCount 是个共享变量而expectedModCount 是属于线程各自的。简单说，线程1更新了 modCount 和属于自己的expectedModCount ，而在线程2看来只有 modCount 更新了， expectedModCount 并未更新，所以会抛出 ConcurrentModificationException 异常。 

**安全失败**
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会抛出 ConcurrentModificationException 异常。缺点是迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生了修改，迭代器是无法访问到修改后的内容。java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用。 

### 如何边遍历边移除 Collection 中的元素？ 

从上文“快速失败机制”可知在遍历集合时如果直接调用 remove() 方法会抛ConcurrentModificationException 异常，所以使用迭代器中调用 remove() 方法 

### Array 和 ArrayList 有何区别？ 

- Array 可以包含基本类型和对象类型， ArrayList 只能包含对象类型。
- Array 大小是固定的， ArrayList 的大小是动态变化的。( ArrayList 的扩容是个常见面试题)
- 相比于 Array ， ArrayList 有着更多的内置方法，如 addAll() ， removeAll() 。
- 对于基本类型数据， ArrayList 使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用 Array 。 

### comparable 和 comparator的区别？ 

- comparable 接口出自 java.lang 包，可以理解为一个内比较器，因为实现了 Comparable 接口的类可以和自己比较，要和其他实现了 Comparable 接口类比较，可以使用 compareTo(Objectobj) 方法。compareTo 方法的返回值是 int ，有三种情况： 
  - 返回正整数（比较者大于被比较者）
  - 返回0（比较者等于被比较者）
  - 返回负整数（比较者小于被比较者） 
- comparator 接口出自 java.util 包，它有一个 compare(Object obj1, Object obj2) 方法用来排序，返回值同样是 int ，有三种情况，和 compareTo 类似。 

它们之间的区别：很多包装类都实现了 comparable 接口，像 Integer 、 String 等，所以直接调用Collections.sort() 直接可以使用。如果对类里面自带的自然排序不满意，而又不能修改其源代码的情况下，使用 Comparator 就比较合适。此外使用 Comparator 可以避免添加额外的代码与我们的目标类耦合，同时可以定义多种排序规则，这一点是 Comparable 接口没法做到的，从灵活性和扩展性讲Comparator更优，故在面对自定义排序的需求时，可以优先考虑使用 Comparator 接口 

### Collection 和 Collections 有什么区别？ 

- Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
- Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法，例如常用的 sort()方法。此类不能实例化，就像一个工具类，服务于Java的 Collection 框架。 

### List集合

#### 遍历一个 List 有哪些不同的方式？ 

先说一下常见的元素在内存中的存储方式，主要有两种： 

1. 顺序存储（Random Access）：相邻的数据元素在内存中的位置也是相邻的，可以根据元素的位置（如 ArrayList 中的下表）读取元素。

2. 链式存储（Sequential Access）：每个数据元素包含它下一个元素的内存地址，在内存中不要求相邻。例如 LinkedList 。 

**主要的遍历方式主要有三种：**

1. for 循环遍历：遍历者自己在集合外部维护一个计数器，依次读取每一个位置的元素。
2. Iterator 遍历：基于顺序存储集合的 Iterator 可以直接按位置访问数据。基于链式存储集合的Iterator ，需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。
3. foreach 遍历： foreach 内部也是采用了 Iterator 的方式实现，但使用时不需要显示地声明Iterator 。 

那么对于以上三种遍历方式应该如何选取呢？

在Java集合框架中，提供了一个 RandomAccess 接口，该接口没有方法，只是一个标记。通常用来标记List 的实现是否支持 RandomAccess 。所以在遍历时，可以先判断是否支持 RandomAccess （ list instanceof RandomAccess ），如果支持可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。 

#### ArrayList的扩容机制 

> 一般面试时需要记住， ArrayList 的初始容量为10，扩容时对是旧的容量值加上旧的容量数值进行右移一位（位运算，相当于除以2，位运算的效率更高），所以每次扩容都是旧的容量的1.5倍。 

#### ArrayList 和 LinkedList 的区别是什么？ 

- 是否线程安全： ArrayList 和 LinkedList 都是不保证线程安全的
- 底层实现： ArrayList 的底层实现是数组， LinkedList 的底层是双向链表。 
- 内存占用： ArrayList 会存在一定的空间浪费，因为每次扩容都是之前的1.5倍，而 LinkedList中的每个元素要存放直接后继和直接前驱以及数据，所以对于每个元素的存储都要比 ArrayList花费更多的空间。 
- 应用场景： ArrayList 的底层数据结构是数组，所以在插入和删除元素时的时间复杂度都会收到位置的影响，平均时间复杂度为o(n)，在读取元素的时候可以根据下标直接查找到元素，不受位置的影响，平均时间复杂度为o(1)，所以 ArrayList 更加适用于多读，少增删的场景。 LinkedList的底层数据结构是双向表，所以插入和删除元素不受位置的影响，平均时间复杂度为o(1)，如果是在指定位置插入则是o(n)，因为在插入之前需要先找到该位置，读取元素的平均时间复杂度为o(n)。所以 LinkedList 更加适用于多增删，少读写的场景。 

#### ArrayList 和 Vector 的区别是什么？ 

**相同点：**

1. 都实现了 List 接口
2. 底层数据结构都是数组

**不同点：**

1. 线程安全： Vector 使用了 Synchronized 来实现线程同步，所以是线程安全的，而ArrayList 是线程不安全的。
2. 性能：由于 Vector 使用了 Synchronized 进行加锁，所以性能不如 ArrayList 。
3. 扩容： ArrayList 和 Vector 都会根据需要动态的调整容量，但是 ArrayList 每次扩容为旧容量的1.5倍，而 Vector 每次扩容为旧容量的2倍 

#### 简述 ArrayList、Vector、LinkedList 的存储性能和特性？ 

- ArrayList 底层数据结构为**数组**，对元素的读取速度快，而增删数据慢，线程不安全。
- LinkedList 底层为**双向链表**，对元素的增删数据快，读取慢，线程不安全。
- Vector 的底层数据结构为数组，用 Synchronized 来保证线程安全，性能较差，但线程安全。 

### Set集合

#### 说一下 HashSet 的实现原理 

- HashSet 的底层是 HashMap ，默认构造函数是构建一个初始容量为16，负载因子为0.75 的 HashMap 
- HashSet 的值存放于 HashMap 的 key 上， HashMap 的 value 统一为 PRESENT 。 

#### HashSet如何检查重复？（HashSet是如何保证数据不可重复的？）  
这里面涉及到了 HasCode() 和 equals() 两个方法。
**equals()**
先看下 String 类中重写的 equals 方法 

![1631491128950](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/075906-114279.png)

从源码中可以看到：
1. equals 方法首先比较的是内存地址，如果内存地址相同，直接返回 true ；如果内存地址不同，再比较对象的类型，类型不同直接返回 false ；类型相同，再比较值是否相同；值相同返回 true ，值不同返回 false 。总结一下， **equals 会比较内存地址、对象类型、以及值**，内存地址相同， equals 一定返回 true ；对象类型和值相同， equals 方法一定返回 true 。
2. 如果没有重写 equals 方法，那么 equals 和 == 的作用相同，比较的是对象的地址值。 

**hashCode **

hashCode 方法返回对象的散列码，返回值是 int 类型的散列码。散列码的作用是确定该对象在哈希表中的索引位置。关于 hashCode 有一些约定：

1. 两个对象相等，也就是说是同一个对象，则 hashCode 一定相同。
2. 两个对象有相同的 hashCode 值，它们不一定相等。
3. hashCode() 方法默认是对堆上的对象产生独特值，如果没有重写 hashCode() 方法，则该类的两个对象的 hashCode 值肯定不同 

介绍完equals()方法和hashCode()方法，继续说下HashSet是如何检查重复的。

HashSet 的特点是存储元素时无序且唯一，在向 HashSet 中添加对象时，首相会计算对象的 HashCode值来确定对象的存储位置，如果该位置没有其他对象，直接将该对象添加到该位置；如果该存储位置有存储其他对象（新添加的对象和该存储位置的对象的 HashCode 值相同），调用 equals 方法判断两个对象是否相同，如果相同，则添加对象失败，如果不相同，则会将该对象重新散列到其他位置。 

#### HashSet与HashMap的区别 

![1631491420584](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/080342-181525.png)

### Map集合 

#### HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现 
JDK1.7的底层数据结构(数组+链表) 

![1631491497543](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/080459-768545.png)

JDK1.8的底层数据结构(数组+链表或者红黑树) 

![1631491538361](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/080540-805343.png)

JDK1.7的Hash函数 ：

~~~ java
static final int hash(int h){
  h ^= (h >>> 20) ^ (h >>>12);
  return h^(h >>> 7) ^ (h >>> 4);
}
~~~

JDK1.8的Hash函数 :

~~~ java
static final int hash(Onject key){
  int h;
  return (key == null) ? 0 : (h = key.hashCode())^(h >>> 16);
}
~~~

JDK1.8的函数经过了一次异或一次位运算一共两次扰动，而JDK1.7经过了四次位运算五次异或一共九次扰动。这里简单解释下JDK1.8的hash函数，面试经常问这个，两次扰动分别是key.hashCode() 与 key.hashCode() 右移16位进行异或。这样做的目的是，高16位不变，低16位与高16位进行异或操作，进而减少碰撞的发生，高低Bit都参与到Hash的计算。如何不进行扰动处理，因为hash值有32位，直接对数组的长度求余，起作用只是hash值的几个低位 

HashMap在JDK1.7和JDK1.8中有哪些不同点： 

![1631491811657](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/081013-143497.png)

#### HashMap 的长度为什么是2的幂次方  

因为 HashMap 是通过 key 的hash值来确定存储的位置，但Hash值的范围是-2147483648到2147483647，不可能建立一个这么大的数组来覆盖所有hash值。所以在计算完hash值后会对数组的长度进行取余操作，如果数组的长度是2的幂次方， (length - 1)&hash 等同于 hash%length ，可以用(length - 1)&hash 这种位运算来代替%取余的操作进而提高性能。 

> 根本原因是使用移位计算提高性能。

#### HashMap的put方法的具体流程？ 

![1631492060821](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/081422-123036.png)

#### HashMap的扩容操作是怎么实现的？ 

- 初始值为16，负载因子为0.75，阈值为负载因子*容量 
- resize() 方法是在 hashmap 中的键值对大于阀值时或者初始化时，就调用 resize() 方法进行扩容。 
- 每次扩容，容量都是之前的两倍 ，至于为什么扩容为原来容量的2倍，也就是保证HashMap总容量是2的幂次方，这样可以使用移位计算。
- 扩容时有个判断 e.hash & oldCap 是否为零，也就是相当于hash值对数组长度的取余操作，若等于0，则位置不变，若等于1，位置变为原位置加旧容量。 

#### HashMap默认加载因子为什么选择0.75？ 

这个主要是考虑空间利用率和查询成本的一个折中。如果加载因子过高，空间利用率提高，但是会使得哈希冲突的概率增加；如果加载因子过低，会频繁扩容，哈希冲突概率降低，但是会使得空间利用率变低。具体为什么是0.75，不是0.74或0.76，这是一个基于数学分析（泊松分布）和行业规定一起得到的一个结论。 

#### 为什么要将链表中转红黑树的阈值设为8？为什么不一开始直接使用红黑树？ 
可能有很多人会问，既然红黑树性能这么好，为什么不一开始直接使用红黑树，而是先用链表，链表长度大于8时，才转换为红红黑树 

- 因为红黑树的节点所占的空间是普通链表节点的两倍，但查找的时间复杂度低，所以只有当节点特别多时，红黑树的优点才能体现出来。至于为什么是8，是通过数据分析统计出来的一个结果，链表长度到达8的概率是很低的，综合链表和红黑树的性能优缺点考虑将大于8的链表转化为红黑树。 
- 链表转化为红黑树除了链表长度大于8，还要 HashMap 中的数组长度大于64。也就是如果HashMap 长度小于64，链表长度大于8是不会转化为红黑树的，而是直接扩容。 

#### HashMap是怎么解决哈希冲突的？ 

哈希冲突： hashMap 在存储元素时会先计算 key 的hash值来确定存储位置，因为 key 的hash值计算最后有个对数组长度取余的操作，所以即使不同的 key 也可能计算出相同的hash值，这样就引起了hash冲突。 hashMap 的底层结构中的链表/红黑树就是用来解决这个问题的。 

HashMap 中的哈希冲突解决方式可以主要从三方面考虑（以JDK1.8为背景） 

- 拉链法

  HasMap 中的数据结构为数组+链表/红黑树，当不同的 key 计算出的hash值相同时，就用链表的形式将Node结点（冲突的 key 及 key 对应的 value ）挂在数组后面。 

- hash函数

  key 的hash值经过两次扰动， key 的 hashCode 值与 key 的 hashCode 值的右移16位进行异或，然后对数组的长度取余（实际为了提高性能用的是位运算，但目的和取余一样），这样做可以让hashCode 取值出的高位也参与运算，进一步降低hash冲突的概率，使得数据分布更平均。 

- 红黑树

  在拉链法中，如果hash冲突特别严重，则会导致数组上挂的链表长度过长，性能变差，因此在链表长度大于8时，将链表转化为红黑树，可以提高遍历链表的速度。 

#### HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？ 

hashCode() 处理后的哈希值范围太大，建立大的数组需要连续的内存空间，不可能在内存建立这么大的数组。 

#### 能否使用任何类作为 Map 的 key？ 

可以，但要注意以下两点：

- 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。
- 最好定义 key 类是不可变的，这样 key 对应的 hashCode() 值可以被缓存起来，性能更好，这也是为什么 String 特别适合作为 HashMap 的 key 。 

#### 为什么HashMap中String、Integer这样的包装类适合作为Key？ 

- 这些包装类都是 final 修饰，是不可变性的， 保证了 key 的不可更改性，不会出现放入和获取时哈希值不同的情况。
- 它们内部已经重写过 hashcode() , equal() 等方法。 

#### 如果使用Object作为HashMap的Key，应该怎么办呢？ 

- 重写 hashCode() 方法，因为需要计算hash值确定存储位置
- 重写 equals() 方法，因为需要保证 key 的唯一性。 

#### HashMap 多线程导致死循环问题 

由于JDK1.7的 hashMap 遇到hash冲突采用的是头插法，在多线程情况下会存在死循环问题，但JDK1.8已经改成了尾插法，不存在这个问题了。但需要注意的是JDK1.8中的 HashMap 仍然是不安全的，在多线程情况下使用仍然会出现线程安全问题。基本上面试时说到这里既可以了，具体流程用口述是很难说清的，

#### ConcurrentHashMap 底层具体实现知道吗？ 

**JDK1.7 **

在JDK1.7中， ConcurrentHashMap 采用 Segment 数组 + HashEntry 数组的方式进行实现。Segment 实现了 ReentrantLock ，所以 Segment 有锁的性质， HashEntry 用于存储键值对。一个 ConcurrentHashMap 包含着一个 Segment 数组，一个 Segment 包含着一个 HashEntry 数组，HashEntry 是一个链表结构，如果要获取 HashEntry 中的元素，要先获得 Segment 的锁。 

![1631493037332](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083039-528273.png)

**JDK1.8 **

在JDK1.8中，不在是 Segment + HashEntry 的结构了，而是和 HashMap 类似的结构，Node数组+链表/红黑树，采用 CAS + synchronized 来保证线程安全。当链表长度大于8，链表转化为红黑树。在JDK1.8中 synchronized 只锁链表或红黑树的头节点，是一种相比于 segment 更为细粒度的锁，锁的竞争变小，所以效率更高。 

![1631493095750](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083138-835049.png)

总结一下：

- JDK1.7底层是 ReentrantLock + Segment + HashEntry ，JDK1.8底层是 synchronized + CAS +链表/红黑树
- JDK1.7采用的是分段锁，同时锁住几个 HashEntry ，JDK1.8锁的是Node节点，只要没有发生哈希冲突，就不会产生锁的竞争。所以JDK1.8相比于JDK1.7提供了一种粒度更小的锁，减少了锁的竞争，提高了 ConcurrentHashMap 的并发能力。 

#### HashTable的底层实现知道吗？ 

HashTable 的底层数据结构是**数组+链表**，链表主要是为了解决哈希冲突，并且整个数组都是synchronized 修饰的，所以 HashTable 是线程安全的，但

锁的粒度太大，锁的竞争非常激烈，效率很低 。

![1631493200168](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083321-643903.png)

#### HashMap、ConcurrentHashMap及Hashtable 的区别 

![1631493250791](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083412-535740.png)

#### 集合的常用方法 

#### Collection常用方法 

![1631493324225](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083525-973284.png)

#### List特有方法 

![1631493377330](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083619-113136.png)

#### LinkedList特有方法 

![1631493427443](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083710-210706.png)

#### Map 

![1631493463280](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631493463280.png)

![1631493483412](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083804-385164.png)

#### Stack 

![1631493525625](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083847-441500.png)

#### Queue 

![1631493567974](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/083929-636293.png)

## 虚拟机

### 描述一下JVM内存模型以及分区，需要详细介绍每隔内存区域存放什么？

运行时数据区在jdk7和jdk8中有些不同

**jdk8之前**

![1630923561125](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/181935-534013.png)

**jdk8**

![1630923618522](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/182019-684911.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

java内存模型整体上可以划分为三部分：类加载子系统，运行时数据区和执行引擎子系统。

**程序计数器**

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。程序计数器也不会出现GC**

**java虚拟机栈**

**与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。

Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

**扩展：那么方法/函数如何调用？**

Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。

**本地方法栈**

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

**堆**

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

![1630924137169](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/182858-639403.png)

上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

**方法区**

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

> **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

**常用参数**

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小

```java
java -XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen 
```

相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

下面是一些常用参数：

```java
java -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 
```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

**运行时常量池**

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。** 

![1630924368456](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/183249-669099.png)

**直接内存**

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

执行引擎：分为解释器和jit即使编译器，解释器主要作用是对字节码的解释执行，而jit及时编译器主要是对一些热点代码进行二次编译，直接编译我机器可以理解的机器语言，这样下次执行是效率更高。

### 对象的创建方法，对象的内存分配，对象的访问定位

**对象的创建**

Java对象的创建大致上有以下几个步骤：

1. **类加载检查**：检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载过程
2. **为对象分配内存**：对象所需内存的大小在类加载完成后便完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。由于堆被线程共享，因此此过程需要进行同步处理（分配在TLAB上不需要同步）
3. **内存空间初始化**：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. **对象设置**：JVM对对象头进行必要的设置，保存一些对象的信息（指明是哪个类的实例，哈希码，GC年龄等）
5. **init**：执行完上面的4个步骤后，对JVM来说对象已经创建完毕了，但对于Java程序来说，我们还需要对对象进行一些必要的初始化。

**对象的内存分配**
Java对象的内存分配有两种情况，由Java堆是否规整来决定（Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定）：

1. 指针碰撞(Bump the pointer)：如果Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离
2. 空闲列表(Free List)：如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单的进行指针碰撞了。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

**对象的访问定位**

对象的访问形式取决于虚拟机的实现，目前主流的访问方式有使用**句柄和直接指针**两种：

- 使用句柄：
  如果使用句柄访问，Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息：

![1631498456547](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/100057-645728.png)

优势：引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身不需要修改。

- 直接指针：

如果使用直接指针访问对象，那么对象的实例数据中就包含一个指向对象类型数据的指针，引用中存的直接就是对象的地址：

![1631498515820](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/100203-575230.png)

优势：速度更快，节省了一次指针定位的时间开销，积少成多的效应非常可观。

缺点：如果发生GC行为对象的内存地址发生变化，那么需要更新引用的地址。

### GC的两种判定方法，以及各有什么特点

**引用计数法：**

- 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。
- 引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互**循环引用**的问题。

**可达性分析（引用链）**
 在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。

![1631498814941](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/100656-310658.png)

在Java语言里，可作为GC Roots对象的包括如下几种：

- 虚拟机栈(栈桢中的本地变量表)中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中JNI的引用的对象

### GC的三种收集方法：标记清除，复制算法，标记整理算法的原理和特点，分别使用在内存的哪一个区域，如果让你优化收集方法，有什么思路？

优化收集方法的思路

- 分代收集算法
  原理：根据对象存活的周期的不同将内存划分为几块，然后再选择合适的收集算法。一般是把java堆分成新生代和老年代，这样就可以根据各个年待的特点采用最适合的收集算法。在新生代中，每次垃圾收集都会有大量的对象死去，只有少量存活，所以选用复制算法。老年代因为对象存活率高，没有额外空间对他进行分配担保，所以一般采用标记整理或者标记清除算法进行回收。

详情请查看这篇文章：[Java垃圾回收算法概述](https://github.com/justdoitMr/rzf.github.io/blob/main/Note/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.md)

### GC收集器有哪些，CMS收集器和G1收集器的特点

一共有7款收集器

#### serial收集器

单线程，串行执行，工作时必须暂停其他工作线程。多用于client机器上，使用**复制算法**。

一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束，年轻代垃圾收集器。

- 特点：CPU利用率最高，停顿时间即用户等待时间比较长。
- 适用场景：小型应用
- 通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

#### ParNew收集器（又叫**Parallel收集器**）

serial收集器的多线程版本，server模式下虚拟机首选的新生代收集器，年轻代垃圾收集器。**复制算法**

采用多线程来通过扫描并压缩堆

- 特点：停顿时间短，回收效率高，对吞吐量要求高。
- 适用场景：大型应用，科学计算，大规模数据采集等。
- 通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

#### Parallel Scavenge（**并行清除**）收集器

复制算法，可控制吞吐量的收集器。吞吐量即有效运行时间，吞吐量优先，年轻代垃圾收集器。并行垃圾收集器

#### Serial Old收集器

serial的老年代版本，使用整理算法。串行垃圾收集器。

#### Parallel Old收集器

Parallel Scavenge收集器的老年代版本，多线程，采用标记压缩算法，基于并行回收。

#### CMS收集器

目标是最短回收停顿时间。**标记清除**算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。分四个阶段：

- 初始标记：GC Roots直连的对象做标记
- 并发标记：多线程方式GC Roots Tracing，这个时候还有可能产生垃圾。
- 重新标记：修正第二阶段标记的记录
- 并发清除。

尽管`CMS`收集器采用的是并发回收（非独占式），**但是在其初始化标记和重新标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“`Stop-the-World`”，只是尽可能地缩短暂停时间。

**由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的**。

- 特点：响应时间优先，减少垃圾收集停顿时间，缺点是会产生垃圾碎片。
- 适应场景：服务器、电信领域等。
- 通过JVM参数 -XX:+UseConcMarkSweepGC设置

#### G1收集器

基本思想是化整为零，将堆分为多个Region，优先收集回收价值最大的Region。

- 并行并发
- 分代收集
- 空间整合（**标记整理**算法）
- 可预测的停顿

在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
特点：

- 支持很大的堆，高吞吐量
- 支持多CPU和垃圾回收线程
- 在主线程暂停的情况下，使用并行收集
- 在主线程运行的情况下，使用并发收集
- 实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
- 通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器

### Minor GC,Major GC 和Full GC分别发生在什么时候，各有什么特点？

**新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。

**老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上

### 说说常用的内存调试工具？

- jps:查看虚拟机进程的状况，如进程ID

- jmap:用于生成堆转储快照文件（某一时刻的）

- jstack:用来生成线程快照（某一时刻的）。生成线程快照的主要目的是定位线程长时停顿的原因（如死锁，死循环，等待I/O 等），通过查看各个线程的调用堆栈，就可以知道没有响应的线程在后台做了什么或者等待什么资源。

- jconsole:主要是内存监控和线程监控。内存监控：可以显示内存的使用情况。线程监控：遇到线程停顿时，可以使用这个功能。
- jstat:虚拟机统计信息监视工具。如显示垃圾收集的情况，内存使用的情况。

### 说说类加载的五个过程

类的加载主要是三个阶段，加载，链接（验证，准备，解析），初始化，其中在链接阶段又分为三个阶段。其中类的加载过程如下：

![1630830948135](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/05/163549-672493.png)

每一个阶段的工作如下：

**加载阶段：**

1. 通过一个类的权限定名，获取定义此类的二进制字节流，注意这个字节流可以是经过编译器编译后产生的字节流，也可以是网络上的字节流文件。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构(也就是运行时数据区）。
3. 在堆内存中生成一个代表这个类的java. lang.class对象，作为方法区这个类的各种数据结构的访问入口。

**链接阶段：**

验证：验证经过第一个阶段后加载进来的字节码文件是否是正确的，防止危害虚拟机的安全。

准备：对类变量以及类分配内存并且初始化，常量在编译的时候已经进行内存分配和初始化操作。

解析：将常量池的符号引用转换为直接引用的过程。

**初始化阶段：**

初始化阶段就是执行类的构造器方法clinit()的过程。这个方法是jvm把类中的类变量和静态代码块组合起来形成的一个方法

**使用阶段：**使用类

**卸载阶段：**对类型进行卸载。

### 双亲委派模型，问什么需要双亲委派模型，有什么优点？

当一个类收到了类加载请求时，自己不会先去加载这个类，而是将其委派给父类去加载，如果父类不能加载，反馈给子类，由子类去完成类的加载；

![1630831572226](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/05/164613-651750.png)

启动类加载器（引导类加载器 Bootstrap ClassLoader）:此加载器用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar）下面的内容，用于提供jvm自身需要的类。

扩展类加载器：主要加载%JAVA_HOME%\lib\ext目录下的类库文件或者java.ext.dirs系统变量所指定的类库文件（加载扩展库）

程序应用类加载器：主要加载用户类路径(classpath)所指定的类库。

用户自定义类加载器：加载用户自定义的类库。

为什么使用双亲委派机制对类进行加载？

- 避免类的重复加载，这样可以保证一个类只有一个类加载器进行加载。
- 保护程序的安全，防止核心的api被篡改。

###  分派：静态分派和动态分派

**解析**

**类加载时进行**，将部分方法的符号引用转化为直接引用。这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。这里边有两个重要的点：**编译期可知，运行期不可变**只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有**静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法**（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-VirtualMethod），与之相反，其他方法就被称为“虚方法”（Virtual Method）。

**分派**

这里所谓的分派指的是在Java中对方法的调用。Java中有三大特性：封装、继承和多态。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。**其中重载属于静态分派，而重写则是动态分派的过程**。除了使用分派的方式对方法进行调用之外，还可以使用解析调用，解析调用是在编译期间就已经确定了，在类装载的解析阶段就会把符号引用转化为直接引用，不会延迟到运行期间再去完成。而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。

**方法解析**

对于方法的调用，虚拟机提供了四条方法调用的字节码指令，分别是：

- `invokestatic`: 调用静态方法
- `invokespecial`: 调用构造方法，私有方法，父类方法
- `invokevirtual`: 调用虚方法
- `invokeinterface`: 调用接口方法

其中，1和2都可以在类加载阶段确定方法的唯一版本，因此，在类加载阶段就可以把符号引用解析为直接引用，在调用时刻直接找到方法代码块的内存地址进行执行（编译时已经找到了，并且存在方法调用的入口）；3和4则是在运行期间动态绑定方法的直接引用。

`invokestatic`指令和`invokespecial`指令调用的方法称为非虚方法，注意，`final`修饰的方法也属于虚方法。

**静态分派**

静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程（因为还没有涉及到Java虚拟机）。静态分派的最直接的解释是在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的。比如创建一个类`O`，在`O`中创建了静态类内部类`A`，`O`中又有两个静态类内部类`B`、`C`继承了这个静态内部类`A`，那么实际上当编写如下的代码：

### 那些内存区域会发生OOM以及会进行GC？

会发生OOM的内存区域：本地方法栈，虚拟机栈，堆区域，方法区

会发生GC的区域：堆区，方法区

既没有GC又没有OOM的区域：PC寄存器

### 如何打破双亲委派模型？

双亲委派模型都依靠`loadClass()`，重写`loaderClass()`即可；

### 新生代中区分Eden和Survivor的作用是什么

新生代分为 3 个分区：Eden（伊甸园）、Survivor0、Survivor1；其中Survivor0、 Survivor1 合起来成为Survivor（幸存区）; 如果没有Survivor，Eden区每进行一次`Minor GC`，存活的对象都会被送到老年代。老年代将很快被填满，老年代每发生一次`Full GC` 的速度比 `Minor GC`慢10倍；所以产生了Survivor区，每产生一次minor GC操作，都会把当前存活下来的对象放入Survivor区域中，等到对象存活到一定的年龄，然后在放到老年代，等老年代块满的时候，在进行一次major gc释放内存空间。对象年龄默认是16岁。

> Survivor 的作用就是减少老年代`Full GC` 的次数,相当于缓冲带；
> Eden和Survivor的比例分配8:1:1
>
> 默认情况下新生代和老年代的比例是1:2的比例。

### 简述分代垃圾回收器工作流程

1. new 的对象先放eden 区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象， JVM 的垃圾回收器将对伊甸园区进行垃圾回收（ Minor GC ),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区，没有被销毁的对象放入survivor0 区域。
3. 如果eden区域满，再次触发垃圾回收，此时上次幸存下来的放到幸存者survivor0 区的，如果没有回收，就会放到幸存者survivor1 区，然后把这一次eden中存活的对象也放到survivor1 区。
4. ……..
5. 如果再次经历垃圾回收，此时会重新放回幸存者survivor0 区，接着再去幸存者survivor1 区。
6. 啥时候能去养老区呢？可以设置次数。默认是15次。·可以设置参数： -XX:MaxTenuringThreshold =进行设置,也就是设置对象的生存年龄。
7. 在养老区，对象相对悠闲。当老年区内存不足时，再次触发GC：Major GC ，进行养老区的内存清理。
8. 若养老区执行了Major GC 之后发现依然无法进行对象的保存，就会触发FULL GC操作，如果内存空间还是不够，就会产生OOM 异常。

> 关于垃圾回收，频繁发生在新生代，很少发生在老年代，几乎不会再永久代或者元空间发生，

对象内存空间分配的特殊情况

1. 如果来了一个新对象，先看看 Eden 是否放的下？
   1. 如果Eden 放得下，则直接放到 Eden 区
   2. 如果 Eden 放不下，则触发YGC ，执行垃圾回收，看看还能不能放下？
2. 将对象放到老年区又有两种情况：
3. 如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代
4. 那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报OOM
5. 如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

**图示过程：**

![1630901747597](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/121547-801883.png)

> Minor GC和Full GC触发条件，答默认情况下发生15次Minor GC之后就会触发一次Full GC
>
> 触发Major GC是eden区域的行为，不是幸存者区域的行为，eden是主动的，幸存者区是被动行为。

### GC是什么? 为什么要有 GC?

GC 是垃圾收集（GabageCollection）；Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，而不需要人为手动释放内存；主要调用的是 System.gc() 和 Runtime.getRuntime().gc()；

### 简述CMS收集器

CMS（Concurrent Mark Sweep）收集器基于`标记—清除算法`实现的收集器，是一种以获取最短回收停顿时间为目标的收集器。主要优点是并发收集，低停顿，在cpu多核的情况下性能较好。在启动 JVM 的参数加上

“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器；**其使用在老年代 可以配合新生代的Serial和ParNew收集器一起使用；由于 CMS 使用 标记—清除算法 GC时会产生大量碎片，有可能提前触发Full GC；如果在老年代充满之前无法回收不可达对象，或者没有足够的空间满足分配就会导致Concurrent Mode Failure（并发模式故障）**;

### 简述G1收集器

G1（Garbage-First）从整体来看是基于`标记—整理`算法实现的收集器，能够实现并发并行，对cpu利用率较高，减少停顿时间。目标是取代jdk1.5发布的CMS收集器。**G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用,G1收集器可预测垃圾回收的停顿时间,对空间进行整合；由于G1是基于复制算法实现，当没有足够的空间（region）分配存活的对象就会导致Allocation (Evacuation) Failure（分配失败）**；

### 简述GC中Stop the world（重点）

Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。Stop-The-World对系统性能存在影响，因此垃圾回收的一个原则是尽量减少“Stop-The-World”的时间；

为什么有STW发生？

- 因为使用可达性分析算法分析垃圾时候，分析工作必须在一个能确保一致性的快照中进行
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

被STW 中断的应用程序线程会在完成GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW 的发生。

STW 事件和采用哪款GC 无关，所有的GC 都有这个事件。

STW 是JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。

### 垃圾回收算法（重点）

标记-清除法：标记出没有用的对象，之后一个一个回收掉

**算法过程**

1. 标记： Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header 中记录为可达对象。注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象,不可达的对象无法标记。
2. 清除： Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header 中没有标记为可达对象，则将其回收，此时对整个堆内存执行遍历操作，就可以发现那些不可达的垃圾对象然后清除操作。

**缺点**

1. 标记清除算法的效率不算高（应为需要对整个堆空间进行遍历，还有遍历可达的对象）。
2. 在进行GC 的时候，需要停止整个应用程序，用户体验较差
3. 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表。

**优点**

1. 实现起来比较简单

**复制算法**

**算法过程**

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

大部分新生代使用的垃圾回收算法就是复制算法。

**优点**

1. 没有标记和清除过程，实现简单，运行高效，最明显的特征。
2. 复制过去以后保证空间的连续性，不会出现“碎片”问题。所以这种垃圾清楚后，对象内存的分配可以用指针碰撞的方式进行分配，但是标记-清楚算法回收的内存，只能采用空闲列表的方式分配对象的内存。

**缺点**

1. 此算法的缺点也是很明显的，就是需要两倍的内存空间。
2. 对于G1 这种分拆成为大量region 的GC ，复制而不是移动，意味着GC 需要维护region 之间对象引用关系，不管是内存占用或者时间开销也不小（也就是栈中存储对象的引用（对象的地址）也需要发生变化）。

**标记压缩算法**

**执行过程**

1. 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一边，按照顺序排放，之后清理边界之外的所有内存空间。

**标记-压缩算法与标记-清除算法的比较**

1. 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（ Mark-Sweep-Compact ）算法。
2. 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
3. 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时， JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

**优点**

1. 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
2. 消除了复制算法当中，内存减半的高额代价。

**缺点**

1. 从效率上来说，标记-整理算法要低于复制算法。因为清除后还涉及对象内存的整理。
2. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot 虚拟机采用的不是句柄池的方式，而是直接指针）
3. 移动过程中，需要全程暂停用户应用程序。即： STW

**垃圾回收算法小结**

1. 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。以空间换取时间效率。
2. 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。

![1630904429853](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/130030-419709.png)

### 什么是分代回收算法，为什么要进行分代回收

**分代垃圾回收是基于这样一个事实：不同的对象的生存周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。**

**分代收集算法**

当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为**新生代和老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。

**年轻代（Young Generation）的回收算法 (主要以 复制算法为主)** 

所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

**分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？**

- 年轻代（Young Generation）的回收算法 (主要以 复制算法为主)
  - 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
  - 新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor（survivor0、 survivor1）区。大部分对象在 Eden 区中生成。回收时先将 Eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 区 和这个 survivor0 区，此时 survivor0 区是空的，然后将survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。
  - 当 survivor1 区不足以存放 Eden 区 和 survivor0区 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代、老年代都进行回收。
  - 新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高（不一定等 Eden 区满了才触发）。新生代触发GC一定是eden区域的行为，幸存者区域一般是被动的行为。

- 年老代（Old Generation）的回收算法（主要以 标记压缩 为主）
  - 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
  - 内存比新生代也大很多（大概比例是1 : 2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。
  - 如果有大对象，eden区域放不下，也会考虑直接存放在老年代中。

### 你知道都有哪些垃圾回收器，各有什么特点

![1630904586572](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/130306-303373.png)

图片来自于知乎：知识追寻者。

### 什么是内存溢出，什么是内存泄漏，有什么区别

内存溢出说的是用户申请的空间已经超过系统可用的内存空间，最常见的是栈内存溢出，堆内存溢出。

内存泄漏，强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象，但是如果内存泄漏的次数发生多了就会导致内存溢出。

### 对象什么时候会被GC

**引用计数算法**

1. 引用计数算法（ Reference Counting ）比较简单，对每个对象保存一个整数的引用计数器属性，用于记录对象被引用的情况。
2. 对于一个对象A ，只要有任何一个对象引用了A ，则A 的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A 不可能再被使用，可进行回收。

优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

1. 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
3. 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java 的垃圾回
   收器中没有使用这类算法。

**可达性分析算法**

1. 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中存在的循环引用问题，防止内存泄漏的发生。
2. 相较于引用计数算法，这里的可达性分析就是Java 、C# 选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（ Tracing Garbage Collection ）

算法实现思路

1. 可达性分析算法是以根对象集合（ GCRoots ）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
2. 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（ Reference Chain ）
3. 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
4. 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

GC root可以是那些元素？

1. 虚拟机栈中引用的对象
2. 本地方法栈中引用的对象
3. 方法区中常量池中引用的对象
4. 所有被同步锁synchronized持有的对象
5. java虚拟机内部引用的对象
6. 方法区中类静态属性引用的对象

> 小结
>
> 1. 总结一句话就是，除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区地方对堆空间进行引用的，都可以作为GC Roots 进行可达性分析
> 2. 除了这些固定的GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots 集合。比如：分代收集和局部回收（ PartialGC ）
> 3. 可达性分析算法必须在一个能保证一致性快照中进行。

### 说说Java中栈内存和堆内存的区别

1. 从存储数据的角度说：栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象；java中基本上所有的对象都存储在堆内存区域。
2. 从是否共享角度说：栈内存线程私有，堆内存线程共享
3. 是否会发生内存的溢出：栈内存不足时，JVM会抛出java.lang.StackOverFlowError（一般发生在递归的时候）；堆内存不足时，JVM会抛出java.lang.OutOfMemoryError
4. 栈的内存远小于堆内存，-Xss选项设置栈的大小。-Xms选项可以设置堆的开始大小;堆一般把最大堆内存和最小堆内存设置为一样。

### 强引用、软引用、弱引用、虚引用以及他们之间和gc的关系

- 强引用：new出的对象之类的引用， 只要强引用还在，gc时永远不会被回收 
- 软引用：有用但非必须的对象，内存溢出异常之前，将会把软引用对象列入第二次回收。
- 弱引用：有用但非必须的对象，对象能生存到下一次垃圾收集发生之前。 
- 虚引用：对生存时间无影响，在垃圾回收时得到通知。
- 终结器引用：
  - 它用于实现对象的finalize() 方法，也可以称为终结器引用
  - 无需手动编码，其内部配合引用队列使用
  - 在GC 时，终结器引用入队。由Finalizer 线程通过终结器引用找到被引用对象调用它的finalize() 方法，第二次GC 时才回收被引用的对象

> 强引用是造成java内存泄漏的主要原因

### java对象创建（5种创建对象的方法）

- 使用new关键字创建对象; 会调用构造方法；
- 使用Class类的newInstance方法(反射机制)；会调用构造方法；
- 使用Constructor类的newInstance方法(反射机制)；会调用构造方法；
- 使用Clone方法创建对象；不会调用构造方法；
- 使用(反)序列化机制创建对象；不会调用构造方法；

### 如果对象的引用被置为 null，垃圾收集器是否会立即回收对象？

不会，在下一个垃圾回收周期中回收对象。

### jvm调优工具又哪些？各自的作用又是什么（重点）

- jps: 查看进程的参数信息;
- jstat: 查看某个Java进程内的线程堆栈信息;
- jinfo: 查看虚拟机参数；
- jmap:查看堆内存使用状况，生成快照存储(dump文件);
- jhat: 分析jmap dump生成的快照文件；
- jconsole: 基于JMX的可视化工具，监控 cpu, 内存，线程等使用情况；
- jvisualvm: JDK 自带分析工具,功能齐全，如查看进行信息，快照转存，监控cpu,线程，方法区，堆等；

### 你知道哪些JVM调优参数

- -Xms128m JVM初始分配的堆内存
- -Xmx512m JVM最大允许分配的堆内存，按需分配；
- -XX:MetaspaceSize：分配给类元数据空间（以字节计）的初始大小;
- -XX:MaxMetaspaceSize：分配给类元数据空间的最大值，超过此值就会触发Full GC
- -XX:NewRatio：新生代和老年代的占比；
- -XX:NewSize：新生代空间；
- -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比；
- -XX:MaxTenuringThreshold：对象进入老年代的年龄阈值；
- XX:+PrintGC：打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息

### 为什么字符串常量池在不同版本的jdk中位置会发生变化

1. 永久代的默认空间大小比较小，但是字符串的使用又比较的频繁，所以进行调整，放入堆内存中，空间比较大。最初是放在永久代中，但是永久代中垃圾回收不频繁。
2. 永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC 产生STW 或者容易产生OOM：
   PermGen Space
3. 堆中空间足够大，字符串可被及时回收。
4. 在jdk6中是放在永久代中，但是在jdk7/jdk8中，把静态变量和字符串常量池移动到堆内存中，可以频繁的进行垃圾回收操作。

### 概述一下类结构文件

在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。比如scala也可以被编译为.class文件在虚拟机上面运行。

可以说`.class`文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。

### 谈谈你对jvm的理解

Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

> 什么是字节码文件，采用字节码文件的好处？
>
> 在 Java 中，JVM可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。

java程序从源文件到运行可以经过下面三个步骤：

![1630924896460](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/184140-229261.png)

我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

> HotSpot采用了惰性评估(Lazy  Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK  9引入了一种新的编译模式AOT(Ahead of Time  Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT  编译器的编译质量是肯定比不上 JIT 编译器的。

**总结：**

Java虚拟机（JVM）是运行 Java  字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的  JVM  实现是 Java 语言“一次编译，随处可以运行”的关键所在。 

### JVM 配置常用参数有哪些?

**垃圾回收参数**

-Xnoclassgc 是否对类进行回收

-verbose:class -XX:+TraceClassUnloading 查看类加载和卸载信息

-XX:SurvivorRatio Eden和其中一个survivor的比值

-XX:PretenureSizeThreshold 大对象进入老年代的阈值，Serial和ParNew生效

-XX:MaxTenuringThreshold 晋升老年代的对象年龄，默认15, CMS默认是4

-XX:HandlePromotionFailure 老年代担保

-XX:+UseAdaptiveSizePolicy动态调整Java堆中各个区域大小和进入老年代年龄

-XX:ParallelGCThreads 并行回收的线程数

-XX:MaxGCPauseMillis Parallel Scavenge参数，设置GC的最大停顿时间

-XX:GCTimeRatio  Parallel Scavenge参数，GC时间占总时间的比率，默认99%，即1%的GC时间

-XX:CMSInitiatingOccupancyFraction，old区触发cms阈值，默认68%

-XX:+UseCMSCompactAtFullCollection(CMS完成后是否进行一次碎片整理，停顿时间加长)

-XX:CMSFullGCsBeforeCompaction(执行多少次不进行碎片整理的FullGC后进行一次带压缩的)

-XX:+ScavengeBeforeFullGC，在fullgc前触发一次minorGC

**垃圾回收统计信息**

-XX:+PrintGC 输出GC日志

-verbose:gc等同于上面那个

-XX:+PrintGCDetails 输出GC的详细日志

**堆大小设置**

-Xmx:最大堆大小

-Xms:初始堆大小(最小内存值)

-Xmn:年轻代大小

-XX:NewSize和-XX:MaxNewSize 新生代大小

-XX:SurvivorRatio:3 意思是年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5

-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5

-Xss栈容量 默认256k

-XX:PermSize永久代初始值

-XX:MaxPermSize 永久代最大值

> 进程是资源分配的基本单位，线程是调度的基本单位

### 常用 GC 调优策略有哪些？

1. GC 调优原则；
2. GC 调优目的；
3. GC 调优策略；

#### GC 调优原则

在调优之前，我们需要记住下面的原则：

> 多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java  应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量；  减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。

#### GC 调优目的

将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。

#### GC 调优策略

**策略 1：**将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

**策略 2：**大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的  full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。`-XX:PretenureSizeThreshold` 可以设置直接进入老年代的对象大小。

**策略 3：**合理设置进入老年代对象的年龄，`-XX:MaxTenuringThreshold` 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。

**策略 4：**设置稳定的堆大小，堆大小设置有两个参数：`-Xms` 初始化堆大小，`-Xmx` 最大堆大小。

**策略5：**注意： 如果满足下面的指标，**则一般不需要进行 GC 优化：**

> MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。

### 虚拟机栈和本地方法栈为什么是线程私有的？

- 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：**和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### java对象的创建过程

下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。

![1630925253458](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/184734-713758.png)

**Step1:类加载检查**

 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**Step2:分配内存**

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![1630925290375](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/06/184811-926866.png)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

**Step3:初始化零值**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**Step4:设置对象头**

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**Step5:执行 init 方法**

 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象访问定位的两种方式

java对象在访问的时候，我们需要通过java虚拟机栈的reference类型的数据去操作具体的对象。由于reference类型在java虚拟机规范中只规定了一个对象的引用，并没有定义这个这个引用应该通过那种方式去定位、访问java堆中的具体对象实例，所以一般的访问方式也是取决与java虚拟机的类型。目前主流的访问方式有通过句柄和直接指针两种方式。

1. 句柄访问

使用句柄访问方式，java堆将会划分出来一部分内存去来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中则包含对象实例数据的地址和对象类型数据（如对象的类型，实现的接口、方法、父类、field等）的具体地址信息。下边我以一个例子来简单的说明一下：

​	Object obj = new Object();

Object obj表示一个本地引用，存储在java栈的本地便变量表中，表示一个reference类型的数据。

new Object()作为实例对象存放在java堆中，同时java堆中还存储了Object类的信息（对象类型、实现接口、方法等）的具体地址信息，这些地址信息所执行的数据类型存储在方法区中。

2. 直接指针访问

如果使用指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型的相关信息（如对象的类型，实现的接口、方法、父类、field等），而reference中存储的就是对象的地址。

这两种访问方式各有利弊，使用句柄访最大的好处是reference中存储着稳定的句柄地址，当对象移动之后（垃圾收集时移动对象是非常普遍的行为），只需要改变句柄中的对象实例地址即可，reference不用修改。

使用指针访问的好处是访问速度快，它减少了一次指针定位的时间开销，由于java是面向对象的语言，在开发中java对象的访问非常的频繁，因此这类开销积少成多也是非常可观的，反之则提升访问速度。

### HotSpot为什么要分为新生代和老年代？ 

答案看分代收集算法的解释

## 并发

### 什么是进程？是什么线程？ 

**线程是处理器任务调度和执行的基本单位，进程是操作系统资源分配的基本单位。**
进程是程序的一次执行过程，是系统运行的基本单位。线程是一个比进程更小的执行单位，一个进程可以包含多个线程。 

### 进程和线程的关系？（区别） 

**定义：线程是处理器任务调度和执行的基本单位；进程是操作系统资源分配的基本单位。 **

包含关系：一个进程可以包含多个线程。

**讲解线程和进程的时候可以从jvm角度回答**

- Java虚拟机的角度来理解：Java虚拟机的运行时数据区包含堆、方法区、虚拟机栈、本地方法栈、程
  序计数器。各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是
  相互独立的，这个线程会共享进程的堆和方法区，但这些线程不会共享虚拟机栈、本地方法栈、程序计
  数器。即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、
  程序计数器，如图所示，假设某个进程包含三个线程。 

![1631509794280](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/130955-642341.png)

由上面可知以下进程和线程在以下几个方面的区别：

- 内存分配：进程之间的地址空间和资源是相互独立的，同一个进程之间的线程会共享线程的地址空间和
  资源（堆和方法区）。
- 资源开销：每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共
  享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间的切换资源开销较小。 

### 并行和并发的区别？ 

并行：单位时间多个处理器同时处理多个任务。
并发：一个处理器处理多个任务，按时间片轮流处理多个任务。 

### 多线程的优缺点（为什么使用多线程、多线程会引发什么问题） 
优点：当一个线程进入等待状态或者阻塞时，CPU可以先去执行其他线程，提高CPU的利用率 

缺点：

- 上下文切换：频繁的上下文切换会影响多线程的执行速度。
- 多个线程抢占某一个资源会引起死锁
- 资源限制：在进行并发编程时，程序的执行速度受限于计算机的硬件或软件资源。在并发编程中，
  程序执行变快的原因是将程序中串行执行的部分变成并发执行，如果因为资源限制，并发执行的部
  分仍在串行执行，程序执行将会变得更慢，因为程序并发需要上下文切换和资源调度。 

### 线程的上下文切换 

- 即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是
  CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。 

- CPU会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切
  换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务
  保存到在加载的过程就是一次上下文切换。 

### Java中守护线程和用户线程的区别？ 

任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(bool on) 设置， true 则
是将该线程设置为守护线程， false 则是将该线程设置为用户线程。同时， Thread.setDaemon() 必须
在 Thread.start() 之前调用，否则运行时会抛出异常。 

- 用户线程：平时使用到的线程均为用户线程。 
- 守护线程：用来服务用户线程的线程，例如垃圾回收线程。 
- 守护线程和用户线程的区别主要在于Java虚拟机是否存活 
- 用户线程：当任何一个用户线程未结束，Java虚拟机是不会结束的。
- 守护线程：如果只剩守护线程未结束，Java虚拟机结束 

### 线程死锁是如何产生的，如何避免 

**产生死锁的原因**

死锁：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程同时
被阻塞 

**死锁产生的条件：**

- 互斥条件：一个资源在同一时刻只由一个线程占用。
- 请求与保持条件：一个线程在请求被占资源时发生阻塞，并对已获得的资源保持不放。
- 循环等待条件：发生死锁时，所有的线程会形成一个死循环，一直阻塞。
- 不剥夺条件：线程已获得的资源在未使用完不能被其他线程剥夺，只能由自己使用完释放资源。 

**避免死锁的方法主要是破坏死锁产生的条件。**

- 破坏互斥条件：这个条件无法进行破坏，锁的作用就是使他们互斥。
- 破坏请求与保持条件：一次性申请所有的资源。
- 破坏循环等待条件：按顺序来申请资源。
- 破坏不剥夺条件：线程在申请不到所需资源时，主动放弃所持有的资源。 

### 用Java实现死锁，并给出避免死锁的解决方案 

**代码演示**

~~~ java
class DeadLockDemo {
	private static Object resource1 = new Object();
	private static Object resource2 = new Object();
	public static void main(String[] args) {
		new Thread(() -> {
			synchronized (resource1) {
				System.out.println(Thread.currentThread() + "get resource1");
				try {
					ead.sleep(1000); //线程休眠，保证线程2先获得资源2
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread() + "waiting getresource2");
				synchronized (resource2) {
					System.out.println(Thread.currentThread() + "getresource2");
				}
			}
		}, "线程 1").start();
		
		new Thread(() -> {
			synchronized (resource2) {
				System.out.println(Thread.currentThread() + "get resource2");
				try {
					Thread.sleep(1000); //线程休眠，保证线程1先获得资源1
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread() + "waiting getresource1");
				synchronized (resource1) {
					System.out.println(Thread.currentThread() + "getresource1");
				}
			}
		}, "线程 2").start();
	}
}
//结果
Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]waiting get resource1
Thread[线程 1,5,main]waiting get resource2
~~~

上面代码产生死锁的原因主要是线程1获取到了资源1，线程2获取到了资源2，线程1继续获取资源2而产
生阻塞，线程2继续获取资源1而产生阻塞。解决该问题最简单的方式就是两个线程按顺序获取资源，线
程1和线程2都先获取资源1再获取资源2，无论哪个线程先获取到资源1，另一个线程都会因无法获取线
程1产生阻塞，等到先获取到资源1的线程释放资源1，另一个线程获取资源1，这样两个线程可以轮流获
取资源1和资源2。代码如下： 

~~~ java
private static Object resource1 = new Object();
private static Object resource2 = new Object();
public static void main(String[] args) {
	new Thread(() -> {
		synchronized (resource1) {
			System.out.println(Thread.currentThread() + "get resource1");
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			System.out.println(Thread.currentThread() + "waiting getresource2");
			synchronized (resource2) {
				System.out.println(Thread.currentThread() + "getresource2");
			}
		}
	}, "线程 1").start();
	new Thread(() -> {
		synchronized (resource1) {
			System.out.println(Thread.currentThread() + "get resource1");
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
			e.printStackTrace();
			}
			System.out.println(Thread.currentThread() + "waiting getresource2");
			synchronized (resource2) {
				System.out.println(Thread.currentThread() + "getresource2");
			}
		}
	}, "线程 2").start();
	}
}
~~~

### Java中的死锁、活锁、饥饿有什么区别？ 

活锁：任务或者执行者没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、
失败。例如，线程1和线程2都需要获取一个资源，但他们同时让其他线程先获取该资源，两个线程一直
谦让，最后都无法获取 

活锁和死锁的区别：

- 活锁是在不断地尝试、死锁是在一直等待。
- 活锁有可能自行解开、死锁无法自行解开。 

饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。以打印机打
印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任
务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生
的饥饿，忙式等待就是不进入等待状态的等待。
**产生饥饿的原因：**

- 高优先级的线程占用了低优先级线程的CPU时间
- 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进
  行访问。
- 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait() 方法)，因为其他线程
  总是被持续地获得唤醒。

> 死锁、饥饿的区别：饥饿可自行解开，死锁不行。 

### 线程的生命周期和状态  

线程状态的划分并不唯一，但是都大同小异，这里参考《Java并发编程的艺术》，主要有以下几种状
态： 

![1631511097439](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/133139-556884.png)

线程转化过程如下： 

![1631511128745](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/133210-20783.png)

### 创建线程一共有哪几种方法？ 

- 继承 Thread 类创建线程
- 实现 Runnable 接口创建线程
- 使用 Callable 和 Future 创建线程
- 使用线程池例如用 Executor 框架 

1. 继承Thread类创建线程，首先继承Thread类，重写 run() 方法，在 main() 函数中调用子类实实例的**
   start() 方法。*

~~~ java
public class ThreadDemo extends Thread {
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName() + " run()方法正在执行");
	}
}
public class TheadTest {
	public static void main(String[] args) {
		ThreadDemo threadDemo = new ThreadDemo();
		threadDemo.start();
		System.out.println(Thread.currentThread().getName() + " main()方法执行结束");
	}
}
//结果
main main()方法执行结束
Thread-0 run()方法正在执行
~~~

2. 实现Runnable接口创建线程：首先创建实现 Runnable 接口的类 RunnableDemo ，重写 run() 方法；
   创建类 RunnableDemo 的实例对象 runnableDemo ，以 runnableDemo 作为参数创建 Thread 对象，调用 Thread 对象的 start() 方法。 

~~~ java
public class RunnableDemo implements Runnable {
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName() + " run()方法执行中");
	}
}
public class RunnableTest {
	public static void main(String[] args) {
		RunnableDemo runnableDemo = new RunnableDemo ();
		Thread thread = new Thread(runnableDemo);
		thread.start();
		System.out.println(Thread.currentThread().getName() + " main()方法执行完成");
	}
}
//结果
main main()方法执行完成
Thread-0 run()方法执行中
~~~

3. 使用Callable和Future创建线程： 
   1. 创建Callable接口的实现类 CallableDemo ，重写 call() 方法。
   2. 以类 CallableDemo 的实例化对象作为参数创建 FutureTask 对象。
   3. 以 FutureTask 对象作为参数创建 Thread 对象。
   4. 调用 Thread 对象的 start() 方法。 

~~~ java
class CallableDemo implements Callable<Integer> {
	@Override
	public Integer call() {
		System.out.println(Thread.currentThread().getName() + " call()方法执行中");
	return 0;
	}
}
class CallableTest {
	public static void main(String[] args) throws ExecutionException,InterruptedException {
		FutureTask<Integer> futureTask = new FutureTask<Integer>(newCallableDemo());
		Thread thread = new Thread(futureTask);
		thread.start();
		System.out.println("返回结果 " + futureTask.get());
		System.out.println(Thread.currentThread().getName() + " main()方法执行完成");
	}
}
~~~

4. 使用线程池例如用Executor框架： Executors 可提供四种线程池，分别为：
   1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
   2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
   3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
   4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。

下面以创建一个定长线程池为例进行说明:

~~~ java
class ThreadDemo extends Thread {
	@Override
	public void run() {
		System.out.println(Thread.currentThread().getName() + "正在执行");
	}
}
class TestFixedThreadPool {
	public static void main(String[] args) {
	//创建一个可重用固定线程数的线程池
	ExecutorService pool = Executors.newFixedThreadPool(2);
	//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
	Thread t1 = new ThreadDemo();
	Thread t2 = new ThreadDemo();
	Thread t3 = new ThreadDemo();
	Thread t4 = new ThreadDemo();
	Thread t5 = new ThreadDemo();
	//将线程放入池中进行执行
	pool.execute(t1);
	pool.execute(t2);
	pool.execute(t3);
	pool.execute(t4);
	pool.execute(t5);
	//关闭线程池
	pool.shutdown();
	}
}
//结果
pool-1-thread-2正在执行
pool-1-thread-1正在执行
pool-1-thread-1正在执行
pool-1-thread-2正在执行
pool-1-thread-1正在执行
~~~

### runnable 和 callable 有什么区别？ 

**相同点：**

- 两者都是接口
- 两者都需要调用 Thread.start 启动线程

**不同点：**

- callable的核心是 call() 方法，允许返回值， runnable 的核心是 run() 方法，没有返回值
- call() 方法可以抛出异常，但是 run() 方法不行 
- callable 和 runnable 都可以应用于 executors ， thread 类只支持 runnable 

### 线程的run()和start()有什么区别？ 

- 线程是通过 Thread 对象所对应的方法 run() 来完成其操作的，而线程的启动是通过 start() 方法执行的。
- run() 方法可以重复调用， start() 方法只能调用一次 

### 为什么调用start()方法时会执行run()方法，而不直接执行run()方法？ 

1. start() 方法来启动线程，真正实现了多线程运行，这时无需等待 run() 方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 start() 方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行 run() 方法，这里方法 run() 称为线程体，它包含了要执行的这个线程的内容， run() 方法运行结束，此线程随即终止。
2. run() 方法只是类的一个普通方法而已，如果直接调用 run 方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待 run() 方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。
3. 调用 start() 方法可以开启一个线程，而 run() 方法只是thread类中的一个普通方法，直接调用run() 方法还是在主线程中执行的。 

### 线程同步和线程调度

#### 线程同步以及线程调度相关的方法有哪些？ 

1. wait() ：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
2. sleep() ：使当前线程进入指定毫秒数的休眠，暂停执行，需要处理 InterruptedException 。
3. notify() ：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。
4. notifyAll() ：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。
5. join() ：与 sleep() 方法一样，是一个可中断的方法，在一个线程中调用另一个线程的 join()方法，会使得当前的线程挂起，直到执行 join() 方法的线程结束。例如在B线程中调用A线程的join() 方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间。
6. yield() ：提醒调度器愿意放弃当前的CPU资源，使得当前线程从 RUNNING 状态切换到 RUNABLE状态 

#### 线程的sleep()方法和yield()方法有什么不同？ 

1. sleep() 方法会使得当前线程暂停指定的时间，没有消耗CPU时间片。
2. sleep() 使得线程进入到阻塞状态， yield() 只是对CPU进行提示，如果CPU没有忽略这个提示，会使得线程上下文的切换，进入到就绪状态。
3. sleep() 一定会完成给定的休眠时间， yield() 不一定能完成。
4. sleep() 需要抛出InterruptedException，而 yield() 方法无需抛出异常 

#### sleep()方法和wait()方法的区别？ 

**相同点：**

- wait() 方法和 sleep() 方法都可以使得线程进入到阻塞状态。
- wait() 和 sleep() 方法都是可中断方法，被中断后都会收到中断异常。 

**不同点：**

- wait() 是Object的方法， sleep() 是Thread的方法。
- wait() 必须在同步方法中进行， sleep() 方法不需要。
- 线程在同步方法中执行 sleep() 方法，不会释放monitor的锁，而 wait() 方法会释放monitor的锁。
- sleep() 方法在短暂的休眠之后会主动退出阻塞，而 wait() 方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。 

#### wait()方法一般在循环块中使用还是if块中使用？ 

在JDK官方文档中明确要求了要在循环中使用，否则可能出现虚假唤醒的可能。官方文档中给出的代码示例如下： 

~~~ java
synchronized(obj){
  while(<condition does not hold>){
  	obj.wait();
  }
//满足while中的条件后执行业务逻辑
}
~~~

如果讲 while 换成 if 

~~~ java
synchronized(obj){
  if(<condition does not hold>){
  	obj.wait();
  }
//满足if中的条件后执行业务逻辑
}
~~~

当线程被唤醒后，可能 if() 中的条件已经不满足了，出现虚假唤醒。 

#### 线程通信的方法有哪些？  

- 锁与同步
- wait() / notify() 或 notifyAll()
- 信号量
- 管道 

#### 为什么wait()、notify()、notifyAll()被定义在Object类中而不是在Thread类中？ 
- 因为这些方法在操作同步线程时，都必须要标识他们操作线程的锁，只有同一个锁上的被等待线程，可以被同一个锁上的 notify() 或 notifyAll() 唤  

  醒，不可以对不同锁中的线程进行唤醒，也就是说等待和唤醒必须是同一锁。而锁可以是任意对象，所以可以被任意对象调用的方法是定义在 Object 类中。

- 如果把 wait() 、 notify() 、 notifyAll() 定义在Thread类中，则会出现一些难以解决的问题，例如如何让一个线程可以持有多把锁？如何确定线程等

  待的是哪把锁？既然是当前线程去等待某个对象的锁，则应通过操作对象来实现而不是操作线程，而Object类是所有对象的父类，所以将这三种方法定义在Object类中最合适。 

#### 为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？  
因为 wait() 暂停的是持有锁的对象， notify() 或 notifyAll() 唤醒的是等待锁的对象。所以wait() 、 notify() 、 notifyAll() 都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用 。

#### 为什么Thread类的sleep()和yield()方法是静态的？ 

sleep() 和 yield() 都是需要正在执行的线程调用的，那些本来就阻塞或者等待的线程调用这个方法是无意义的，所以这两个方法是静态的 

#### 如何停止一个正在运行的线程？ 

1. 中断： Interrupt 方法中断线程
2. 使用 volatile boolean 标志位停止线程：在线程中设置一个 boolean 标志位，同时用 volatile修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个 boolean 值。
3. 使用 stop() 方法停止线程，但该方法已经被废弃。因为这样线程不能在停止前保存数据，会出现数据完整性问题。 

#### 如何唤醒一个阻塞的线程

如果线程是由于 wait() 、 sleep() 、 join() 、 yield() 等方法进入阻塞状态的，是可以进行唤醒的。如果线程是IO阻塞是无法进行唤醒的，因为IO是操作系统层面的，Java代码无法直接接触操作系统。 

- wait() ：可用 notify() 或 notifyAll() 方法唤醒。
- sleep() ：调用该方法使得线程在指定时间内进入阻塞状态，等到指定时间过去，线程再次获取到CPU时间片进而被唤醒。
- join() ：当前线程A调用另一个线程B的 join() 方法，当前线程转A入阻塞状态，直到线程B运行结束，线程A才由阻塞状态转为可执行状态。
- yield() ：使得当前线程放弃CPU时间片，但随时可能再次得到CPU时间片进而激活 

#### Java如何实现两个线程之间的通信和协作

- syncrhoized 加锁的线程的 Object 类的 wait() / notify() / notifyAll()
- ReentrantLock 类加锁的线程的 Condition 类的 await() / signal() / signalAll()
- 通过管道进行线程间通信：1）字节流；2）字符流 ，就是一个线程发送数据到输出管道，另一个线程从输入管道读数据 

#### 同步方法和同步方法块哪个效果更好？ 

同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象 

#### 什么是线程同步？什么是线程互斥？他们是如何实现的？ 

- 线程的互斥是指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是乱序的。
- 线程的同步是指在互斥的基础上使得访问者对资源进行有序访问，防止多个线程之间抢占而发生死锁。

**线程同步的实现方法： **

- 同步方法
- 同步代码块
- wait() 和 notify()
- 使用volatile实现线程同步
- 使用重入锁实现线程同步
- 使用局部变量实现线程同步
- 使用阻塞队列实现线程同步 

#### 在Java程序中如何保证线程的运行安全？ 

线程安全问题 主要体现在原子性、可见性和有序性。

- 原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性。线程切换带来的原子性问题。
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。缓存导致的可见性问题。
- 有序性：程序执行的顺序按照代码的先后顺序执行。编译优化带来的有序性问题。

**解决方法：**

- 原子性问题：可用JDK Atomic 开头的原子类、 synchronized 、 LOCK 来解决
- 可见性问题：可用 synchronized 、 volatile 、 LOCK 来解决
- 有序性问题：可用 Happens-Before 规则来解决 ，使用colatile关键字防止指令排序。

#### 线程类的构造方法、静态块是被哪个线程调用的？ 

线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run() 方法里面的代码才是被线程自身所调用的。

一个很经典的例子：

- 假设 main() 函数中 new 了一个线程Thread1，那么Thread1的构造方法、静态块都是 main 线程调用的，Thread1中的 run() 方法是自己调用的。
  假设在Thread1中 new 了一个线程Thread2，那么Thread2的构造方法、静态块都是Thread1线程调用的，Thread2中的 run() 方法是自己调用的。 

#### 一个线程运行时异常会发生什么? 

Java中的 Throwable 主要分为 Exception 和 Error 。 Exception 分为**运行时异常和非运行时异常**。运行时异常可以不进行处理，代码也能通过编译，但

运行时会报错。非运行时异常必须处理，否则代码无法通过编译。出现Error代码会直接报错。

#### 线程数量过多会造成什么异常？ 

- 消耗更多的内存和CPU
- 频繁进行上下文切换 

#### 三个线程T1、T2、T3，如何让他们按顺序执行？  

这是一道面试中常考的并发编程的代码题，与它相似的问题有：

- 三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABCABC.......
- 两个线程交替打印1-100的奇偶数
- N个线程循环打印1-100
- ......

其实这类问题本质上都是线程通信问题，思路基本上都是一个线程执行完毕，阻塞该线程，唤醒其他线程，按顺序执行下一个线程。下面先来看最简单的，如何按顺序执行三个线程。 

**方案一：synchronized+wait/notify **

基本思路就是线程A、线程B、线程C三个线程同时启动，因为变量 num 的初始值为 0 ，所以线程B或线程C拿到锁后，进入 while() 循环，然后执行 wait() 方法，线程B线程C阻塞，释放锁。只有线程A拿到锁后，不进入 while() 循环，执行 num++ ，打印字符 A ，最后唤醒线程B和线程C。此时 num 值为 1 ，只有线程B拿到锁后，不被阻塞，执行 num++ ，打印字符 B ，最后唤醒线程A和线程C，后面以此类推。

~~~ java
class Wait_Notify_ACB 
{
	private int num;
	private static final Object LOCK = new Object();
	private void printABC(String name, int targetNum) {
		synchronized (LOCK) {
			while (num % 3 != targetNum) { //想想这里为什么不能用if代替while，
				try {
				LOCK.wait();
				} catch (InterruptedException e) {
				e.printStackTrace();
				}
			}
			num++;
			System.out.print(name);
			LOCK.notifyAll();
		}
	}
	public static void main(String[] args) {
		Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB ();
		new Thread(() -> {
		wait_notify_acb.printABC("A", 0);
		}, "A").start();
		new Thread(() -> {
		wait_notify_acb.printABC("B", 1);
		}, "B").start();
		new Thread(() -> {
		wait_notify_acb.printABC("C", 2);
		}, "C").start();
	}
}
//输出结果
ABC
~~~

接下来看看第一个问题，三个线程T1、T2、T3轮流打印ABC，打印n次。其实只需要将上述代码加一个循环即可，这里假设n=10。 

~~~ java
class Wait_Notify_ACB {
	private int num;
	private static final Object LOCK = new Object();
	private void printABC(String name, int targetNum) {
		for (int i = 0; i < 10; i++) {
			synchronized (LOCK) {
			while (num % 3 != targetNum) { //想想这里为什么不能用if代替，想不起来可
					try {
						LOCK.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				num++;
				System.out.print(name);
				LOCK.notifyAll();
			}
		}
	}
	public static void main(String[] args) {
		Wait_Notify_ACB wait_notify_acb = new Wait_Notify_ACB ();
		new Thread(() -> {
		wait_notify_acb.printABC("A", 0);
		}, "A").start();
		
		new Thread(() -> {
		wait_notify_acb.printABC("B", 1);
		}, "B").start();
		
		new Thread(() -> {
		wait_notify_acb.printABC("C", 2);
		}, "C").start();
	}
}
//输出结果
ABCABCABCABCABCABCABCABCABCABC
~~~

下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100 改成了10。基本思路上面类似，线程odd先拿到锁——打印数字——唤醒线程even——阻塞线程odd，以此循环。 

~~~ java
class Wait_Notify_Odd_Even{
	private Object monitor = new Object();
	private volatile int count;
	Wait_Notify_Odd_Even(int initCount) {
		this.count = initCount;
	}
	private void printOddEven() {

		synchronized (monitor) {
			while (count < 10) {
				try {
					System.out.print( Thread.currentThread().getName() + "：");
					System.out.println(++count);
					monitor.notifyAll();
					monitor.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			//防止count=10后，while()循环不再执行，有子线程被阻塞未被唤醒，导致主线程不能退
			monitor.notifyAll();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Wait_Notify_Odd_Even waitNotifyOddEven = new Wait_Notify_Odd_Even(0);
		
		new Thread(waitNotifyOddEven::printOddEven, "odd").start();
		
		Thread.sleep(10);
		new Thread(waitNotifyOddEven::printOddEven, "even").start();
	}
}
~~~

大家都是用的synchronized+wait/notify，你能不能换个方法解决该问题？ 

> 使用join方法也可以实现

**方案二：join() **

join() 方法：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。基于这个原理，我们使得三个线程按顺序执

行，然后循环多次即可。无论线程1、线程2、线程3哪个先执行，最后执行的顺序都是线程1——>线程2——>线程3。代码如下： 

~~~ java
class Join_ABC {
	public static void main(String[] args) throws InterruptedException {
		for (int i = 0; i < 10; i++) {
			Thread t1 = new Thread(new printABC(null),"A");
			Thread t2 = new Thread(new printABC(t1),"B");
			Thread t3 = new Thread(new printABC(t2),"C");
			t0.start();
			t1.start();
			t2.start();
			Thread.sleep(10); //这里是要保证只有t1、t2、t3为一组，进行执行才能保证t1->t2->t3的执行顺序。
		}
	}
	static class printABC implements Runnable{
		private Thread beforeThread;
		public printABC(Thread beforeThread) {
			this.beforeThread = beforeThread;
		}
		@Override
		public void run() {
			if(beforeThread!=null) {
				try {
					beforeThread.join();
					System.out.print(Thread.currentThread().getName());
				}catch(Exception e){
					e.printStackTrace();
				}
			}else {
				System.out.print(Thread.currentThread().getName());
			}
		}
	}	
}
//结果
ABCABCABCABCABCABCABCABCABCABC
~~~

**方案三：Lock **

该方法很容易理解，其实现代码和synchronized+wait/notify方法的很像。不管哪个线程拿到锁，只有符合条件的才能打印。代码如下 ：

~~~ java
class Lock_ABC {
	private int num; // 当前状态值：保证三个线程之间交替打印
	private Lock lock = new ReentrantLock();
	private void printABC(String name, int targetNum) {
		for (int i = 0; i < 10; ) {
			lock.lock();
			if (num % 3 == targetNum) {
				num++;
				i++;
				System.out.print(name);
			}
			lock.unlock();
		}
	}
	public static void main(String[] args) {
		Lock_ABC lockABC = new Lock_ABC();
		new Thread(() -> {
		lockABC.printABC("A", 0);
		}, "A").start();
		new Thread(() -> {
		lockABC.printABC("B", 1);
		}, "B").start();
		new Thread(() -> {
		lockABC.printABC("C", 2);
		}, "C").start();
	}
}
//结果
ABCABCABCABCABCABCABCABCABCABC
~~~

该方法还可以使用Lock+Condition实现对线程的精准唤醒，减少对其他线程无意义地唤醒，浪费资源。 

**方案四：Lock+Condition**

该思路和synchronized+wait/notify方法的更像了，synchronized对应lock，await/signal方法对应wait/notify方法。下面的代码为了能精准地唤醒下一个线程，创建了多个Condition对象。 

~~~ java
class LockConditionABC {
	private int num;
	private static Lock lock = new ReentrantLock();
	private static Condition c1 = lock.newCondition();
	private static Condition c2 = lock.newCondition();
	private static Condition c3 = lock.newCondition();
	private void printABC(String name, int targetNum, Condition currentThread,Condition nextThread) {

		for (int i = 0; i < 10; ) {
			lock.lock();
			try {
				while (num % 3 != targetNum) {
					currentThread.await();
				}
				num++;
				i++;
				System.out.print(name);
				nextThread.signal();
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				lock.unlock();
			}
		}
	}
	public static void main(String[] args) {
		LockConditionABC print = new LockConditionABC();
		new Thread(() -> {
			print.printABC("A", 0, c1, c2);
		}, "A").start();
		new Thread(() -> {
			print.printABC("B", 1, c2, c3);
		}, "B").start();
		new Thread(() -> {
			print.printABC("C", 2, c3, c1);
		}, "C").start();
	}
}
~~~

**方案五：信号量Semaphore **

- Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。
- Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。
- 一个线程要访问共享资源，先使用 acquire() 方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，使用 release() 释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。 

~~~ java
class SemaphoreABC {
	private static Semaphore s1 = new Semaphore(1); //先打印A，所以设s1中的计数器值为1
	private static Semaphore s2 = new Semaphore(0);
	private static Semaphore s3 = new Semaphore(0);
	private void printABC(String name, Semaphore currentThread, Semaphore nextThread) {
		for (int i = 0; i < 10; i++) {
			try {
				currentThread.acquire(); //阻塞当前线程，即调用当前线程acquire()，计数器减1为0
				System.out.print(name);
				nextThread.release(); //唤醒下一个线程，即调用下一个线程线程
				release()//计数器加1
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		SemaphoreABC printer = new SemaphoreABC();
		new Thread(() -> {
		printer.printABC("A", s1, s2);
		}, "A").start();
		
		Thread.sleep(10);
		new Thread(() -> {
		printer.printABC("B", s2, s3);
		}, "B").start();
		
		Thread.sleep(10);
		new Thread(() -> {
		printer.printABC("C", s3, s1);
		}, "C").start();
	}
}
~~~

> 除了上面的方法，还有LockSupport、CountDownLatch、AtomicInteger等等也可以实现。

### synchronized关键字 

#### 什么是synchronized关键字 ？

在多线程的环境下，多个线程同时访问共享资源会出现一些问题，而synchronized关键字则是用来保证线程同步的 。

#### Java内存的可见性问题 

在了解synchronized关键字的底层原理前，需要先简单了解下Java的内存模型，看看synchronized关键字是如何起作用的。 

![1631518540214](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/153542-810239.png)

这里的本地内存并不是真实存在的，只是Java内存模型的一个抽象概念，它包含了控制器、运算器、缓存等。同时Java内存模型规定，线程对共享变量

的操作必须在自己的本地内存中进行，不能直接在主内存中操作共享变量。这种内存模型会出现什么问题呢？ 

1. 线程A获取到共享变量X的值，此时本地内存A中没有X的值，所以加载主内存中的X值并缓存到本地内存A中，线程A修改X的值为1，并将X的值刷

   新到主内存中，这时主内存及本地内存中的X的值都为1。

2. 线程B需要获取共享变量X的值，此时本地内存B中没有X的值，加载主内存中的X值并缓存到本地内存B中，此时X的值为1。线程B修改X的值为2，

  并刷新到主内存中，此时主内存及本地内存B中的X值为2，本地内存A中的X值为1。

3. 线程A再次获取共享变量X的值，此时本地内存中存在X的值，所以直接从本地内存中A获取到了X为1的值，但此时主内存中X的值为2，到此出现了

  所谓内存不可见的问题。 

该问题Java内存模型是通过synchronized关键字和volatile关键字就可以解决，那么synchronized关键字是如何解决的呢，其实进入synchronized块就是

把在synchronized块内使用到的变量从线程的本地内存中擦除，这样在synchronized块中再次使用到该变量就不能从本地内存中获取了，需要从主内存

中获取，解决了内存不可见问题 。

#### synchronized关键字三大特性是什么？ 

> 面试时经常拿synchronized关键字和volatile关键字的特性进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性、有序性，而volatile关键字只能保证可见性和有序性，不能保证原子性，也称为是轻量级的synchronized 

- 原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。
- 可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock 、unlock原子操作，保证可见性。
- 有序性：程序的执行顺序会按照代码的先后顺序执行。 

#### synchronized关键字可以实现什么类型的锁？ 

- 悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。
- 非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。
- 可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。
- 独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。 

#### synchronized关键字的使用方式 

synchronized主要有三种使用方式：修饰普通同步方法、修饰静态同步方法、修饰同步方法块。

**修饰普通同步方法（实例方法）** 

~~~ java
class syncTest implements Runnable {
	private static int i = 0; //共享资源
	private synchronized void add() {
		i++;
	}
	@Override
	public void run() {
		for (int j = 0; j < 10000; j++) {
			add();
		}
	}
	public static void main(String[] args) throws Exception {
		syncTest syncTest = new syncTest();
		Thread t1 = new Thread(syncTest);
		Thread t2 = new Thread(syncTest);
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(i);
	}
}
~~~

这是一个非常经典的例子，多个线程操作 i++ 会出现线程不安全问题，这段代码的结果很容易得到 ,结果是2000。

大家可以再看看这段代码，猜一猜它的运行结果 ：

~~~ java
class syncTest implements Runnable {
	private static int i = 0; //共享资源
	private synchronized void add() {
		i++;
	}
	@Override
	public void run() {
		for (int j = 0; j < 10000; j++) {
			add();
		}
	}
	public static void main(String[] args) throws Exception {
		// syncTest syncTest = new syncTest();
		Thread t1 = new Thread(new syncTest());
		Thread t2 = new Thread(new syncTest());
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(i);
	}
}
//结果不确定
~~~

第二个示例中的 add() 方法虽然也使用synchronized关键字修饰了，但是因为两次 new syncTest() 操作建立的是两个不同的对象，也就是说存在两个不

同的对象锁，线程t1和t2使用的是不同的对象锁，所以不能保证线程安全。那这种情况应该如何解决呢？因为每次创建的实例对象都是不同的，而类对

象却只有一个，如果synchronized关键字作用于类对象，即用synchronized修饰静态方法，问题则迎刃而解。 

**修饰静态方法 **

只需要在 add() 方法前用static修饰即可，即当synchronized作用于静态方法，锁就是当前的class对象。 

~~~ java
class syncTest implements Runnable {
	private static int i = 0; //共享资源
	private static synchronized void add() {//锁住的是类的方法
		i++;
	}
	@Override
	public void run() {
		for (int j = 0; j < 10000; j++) {
			add();
		}
	}
	public static void main(String[] args) throws Exception {
		// syncTest syncTest = new syncTest();
		Thread t1 = new Thread(new syncTest());
		Thread t2 = new Thread(new syncTest());
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(i);
	}
}
//结果是2000
~~~

**修饰代码块 **

如果某些情况下，整个方法体比较大，需要同步的代码只是一小部分，如果直接对整个方法体进行同步，会使得代码性能变差，这时只需要对一小部分代码进行同步即可。代码如下：

~~~ java
class syncTest implements Runnable {
	static int i = 0; //共享资源
	@Override
	public void run() {
		//其他操作.......
		synchronized (this){ //this表示当前对象实例，这里还可以使用syncTest.class，表示class对象锁
			for (int j = 0; j < 10000; j++) {
				i++;
			}
		}
	}
	public static void main(String[] args) throws Exception {
		syncTest syncTest = new syncTest();
		Thread t1 = new Thread(syncTest);
		Thread t2 = new Thread(syncTest);
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(i);
	}
}
//结果
2000
~~~

#### synchronized底层原理 

> 这个问题也是面试比较高频的一个问题，也是比较难理解的，理解synchronized需要一定的Java虚拟机的知识 

在jdk1.6之前，synchronized被称为重量锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁。下面先介绍jdk1.6之前

的synchronized原理。 

**对象头**

在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：**对象头、实例数据和填充对齐**。因为synchronized用的锁是存在对象头里的，所

以我们需要重点了解对象头。如果对象头是数组类型，则对象头由Mark Word、Class MetadataAddress和Array length组成，如果对象头非数组类型，

对象头则由Mark Word和Class MetadataAddress组成。在32位虚拟机中，数组类型的Java对象头的组成如下表：

![1631521620111](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/162701-134415.png)

这里我们需要重点掌握的是Mark Word。 

**Mark Word **

在运行期间，Mark Word中存储的数据会随着锁标志位的变化而变化，在32位虚拟机中，不同状态下的组成如下： 

![1631521678744](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/162759-445253.png)

其中线程ID表示持有偏向锁线程的ID，Epoch表示偏向锁的时间戳，偏向锁和轻量级锁是在jdk1.6中引入的 

**重量级锁的底部实现原理：Monitor **

在jdk1.6之前，synchronized只能实现重量级锁，Java虚拟机是基于Monitor对象来实现重量级锁的，所以首先来了解下Monitor，在Hotspot虚拟机中，

Monitor是由ObjectMonitor实现的，其源码是用C++语言编写的 ,首先我们先下载Hotspot的源码，源码下载链接：http://hg.openjdk.java.net/jdk8/jd

k8/hotspot，找到ObjectMonitor.hpp文件，路径是 src/share/vm/runtime/objectMonitor.hpp ，这里只是简单介绍下其数据结构 :

![1631521884865](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/163125-331257.png)

其中 `_owner`、`_WaitSet`和`_EntryList `字段比较重要，它们之间的转换关系如下图 

![1631521941833](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/163222-40094.png)

从上图可以总结获取Monitor和释放Monitor的流程如下：
1. 当多个线程同时访问同步代码块时，首先会进入到EntryList中，然后通过CAS的方式尝试将Monitor中的owner字段设置为当前线程，同时count加

  1，若发现之前的owner的值就是指向当前线程的，recursions也需要加1。如果CAS尝试获取锁失败，则进入到EntryList中。 

2. 当获取锁的线程调用 wait() 方法，则会将owner设置为null，同时count减1，recursions减1，当前线程加入到WaitSet中，等待被唤醒 。

3. 当前线程执行完同步代码块时，则会释放锁，count减1，recursions减1。当recursions的值为0时，说明线程已经释放了锁 

> 之前提到过一个常见面试题，为什么 wait() 、 notify() 等方法要在同步方法或同步代码块中来执行呢，这里就能找到原因，是因为 wait() 、 notify() 方法需要借助ObjectMonitor对象内部方法来完成。 

**synchronized作用于同步代码块的实现原理 **

前面已经了解Monitor的实现细节，而Java虚拟机则是通过进入和退出Monitor对象来实现方法同步和代码块同步的。这里为了更方便看程序字节码执行

指令，我先在IDEA中安装了一个 jclasslib Bytecodeviewer 插件。我们先来看这个synchronized作用于同步代码块的代码。 

~~~ java
public void run() {
	//其他操作.......
	synchronized (this){ //this表示当前对象实例，这里还可以使用syncTest.class，表
		示class对象锁
		for (int j = 0; j < 10000; j++) {
			i++;
		}
	}
}
~~~

查看字节码如下：

~~~ java
1 dup
2 astore_1
3 monitorenter //进入同步代码块的指令
4 iconst_0
5 istore_2
6 iload_2
7 sipush 10000
10 if_icmpge 27 (+17)
13 getstatic #2 <com/company/syncTest.i>
16 iconst_1
17 iadd
18 putstatic #2 <com/company/syncTest.i>
21 iinc 2 by 1
24 goto 6 (-18)
27 aload_1
28 monitorexit //结束同步代码块的指令
29 goto 37 (+8)
32 astore_3
33 aload_1
34 monitorexit //遇到异常时执行的指令
35 aload_3
36 athrow
37 return
~~~

从上述字节码中可以看到同步代码块的实现是由monitorenter 和 monitorexit 指令完成的，其中monitorenter指令所在的位置是同步代码块开始的位置，

第一个monitorexit 指令是用于正常结束同步代码块的指令，第二个monitorexit 指令是用于异常结束时所执行的释放Monitor指令。 

**synchronized作用于同步方法原理 **

~~~ java
private synchronized void add() {
	i++;
}
~~~

查看字节码：

~~~ java
0 getstatic #2 <com/company/syncTest.i>
3 iconst_1
4 iadd
5 putstatic #2 <com/company/syncTest.i>
8 return
~~~

发现这个没有monitorenter 和 monitorexit 这两个指令了，而在查看该方法的class文件的结构信息时发现了Access flags后边的synchronized标识，该标

识表明了该方法是一个同步方法。Java虚拟机通过该标识可以来辨别一个方法是否为同步方法，如果有该标识，线程将持有Monitor，在执行方法，最

后释放Monitor。 

![1631522370064](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/163931-73209.png)

> 原理大概就是这样，最后总结一下，面试中应该简洁地如何回答synchroized的底层原理这个问题。
>
> 答：Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，代码块同步使用的是monitorenter 和 monitorexit 指令实现的，而
>
> 方法同步是通过Access flags后面的标识来确定该方法是否为同步方法。 

#### Jdk1.6为什么要对synchronized进行优化？ 

因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现

线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。

#### jDK1.6对synchronized做了哪些优化？

锁的升级

在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，无锁状态，偏向锁状态、轻量级锁状态和重

量级锁状态。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级  。

#### Java中都有哪几种锁

- 乐观锁和悲观锁
- 独占锁和共享锁
- 互斥锁和读写锁
- 公平锁和非公平锁
- 可重入锁
- 自旋锁
- 分段锁
- 锁升级（无锁|偏向锁|轻量级锁|重量级锁）
- 锁优化技术（锁粗化、锁消除）

##### 乐观锁和悲观锁

**悲观锁**

`悲观锁`对应于生活中悲观的人，悲观的人总是想着事情往坏的方向发展。

举个生活中的例子，假设厕所只有一个坑位了，悲观锁上厕所会第一时间把门反锁上，这样其他人上厕所只能在门外等候，这种状态就是「阻塞」了。

回到代码世界中，一个共享数据加了悲观锁，那线程每次想操作这个数据前都会假设其他线程也可能会操作这个数据，所以每次操作前都会上锁，这样其他线程想操作这个数据拿不到锁只能阻塞了。

![1631530330224](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185211-18966.png)

在 Java 语言中 `synchronized` 和 `ReentrantLock`等就是典型的悲观锁，还有一些使用了 synchronized 关键字的容器类如 `HashTable` 等也是悲观锁的应用。

**乐观锁**

`乐观锁` 对应于生活中乐观的人，乐观的人总是想着事情往好的方向发展。

举个生活中的例子，假设厕所只有一个坑位了，乐观锁认为：这荒郊野外的，又没有什么人，不会有人抢我坑位的，每次关门上锁多浪费时间，还是不加锁好了。你看乐观锁就是天生乐观！

回到代码世界中，乐观锁操作数据时不会上锁，在更新的时候会判断一下在此期间是否有其他线程去更新这个数据。

![1631530383507](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185305-990070.png)

乐观锁可以使用`版本号机制`和`CAS算法`实现。在 Java 语言中 `java.util.concurrent.atomic`包下的原子类就是使用CAS 乐观锁实现的。

**两种锁的使用场景**

- 悲观锁和乐观锁没有孰优孰劣，有其各自适应的场景。

- 乐观锁适用于写比较少（冲突比较小）的场景，因为不用上锁、释放锁，省去了锁的开销，从而提升了吞吐量。

- 如果是写多读少的场景，即冲突比较严重，线程间竞争激励，使用乐观锁就是导致线程不断进行重试，这样可能还降低了性能，这种场景下使用悲观锁就比较合适。

##### 独占锁和共享锁

**独占锁**

`独占锁`是指锁一次只能被一个线程所持有。如果一个线程对数据加上排他锁后，那么其他线程不能再对该数据加任何类型的锁。获得独占锁的线程即能读数据又能修改数据。

![1631530486766](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185448-590598.png)

JDK中的`synchronized`和`java.util.concurrent(JUC)`包中Lock的实现类就是独占锁。

**共享锁**

`共享锁`是指锁可被多个线程所持有。如果一个线程对数据加上共享锁后，那么其他线程只能对数据再加共享锁，不能加独占锁。获得共享锁的线程只能读数据，不能修改数据。

![1631530535776](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185537-131617.png)

在 JDK 中 `ReentrantReadWriteLock` 就是一种共享锁。

##### 互斥锁和读写锁

**互斥锁**

`互斥锁`是独占锁的一种常规实现，是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。

![1631530587865](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185629-704057.png)

互斥锁一次只能一个线程拥有互斥锁，其他线程只有等待。

**读写锁**

`读写锁`是共享锁的一种具体实现。读写锁管理一组锁，一个是只读的锁，一个是写锁。

读锁可以在没有写锁的时候被多个线程同时持有，而写锁是独占的。写锁的优先级要高于读锁，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。

读写锁相比于互斥锁并发程度更高，每次只有一个写线程，但是同时可以有多个线程并发读。

![1631530636566](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185718-112875.png)

在 JDK 中定义了一个读写锁的接口：`ReadWriteLock`,`ReentrantReadWriteLock` 实现了`ReadWriteLock`接口

##### 公平锁和非公平锁

**公平锁**

`公平锁`是指多个线程按照申请锁的顺序来获取锁，这里类似排队买票，先来的人先买，后来的人在队尾排着，这是公平的。

![1631530707557](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185829-159836.png)

在 java 中可以通过构造函数初始化公平锁

~~~ java
/**
* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
*/
Lock lock = new ReentrantLock(true);
~~~

**非公平锁**

`非公平锁`是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的状态（某个线程一直得不到锁）。

![1631530756054](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/185917-731214.png)

在 java 中 synchronized 关键字是非公平锁，ReentrantLock默认也是非公平锁。

~~~ java
/**
* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
*/
Lock lock = new ReentrantLock(false);
~~~

##### 可重入锁

`可重入锁`又称之为`递归锁`，是指同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。

![1631530826317](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/190027-725722.png)

对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁。对于Synchronized而言，也是一个可重入锁。

可重入锁的一个好处是可一定程度避免死锁。

以 synchronized 为例，看一下下面的代码：

~~~ java
public synchronized void mehtodA() throws Exception{
 // Do some magic tings
 mehtodB();
}

public synchronized void mehtodB() throws Exception{
 // Do some magic tings
}
~~~

上面的代码中 methodA 调用 methodB，如果一个线程调用methodA 已经获取了锁再去调用 methodB 就不需要再次获取锁了，这就是可重入锁的特性。如果不是可重入锁的话，mehtodB 可能不会被当前线程执行，可能造成死锁。

##### 自旋锁

`自旋锁`是指线程在没有获得锁时不是被直接挂起，而是执行一个忙循环，这个忙循环就是所谓的自旋。

![1631530931219](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/190212-442821.png)

自旋锁的目的是为了减少线程被挂起的几率，因为线程的挂起和唤醒也都是耗资源的操作。

如果锁被另一个线程占用的时间比较长，即使自旋了之后当前线程还是会被挂起，忙循环就会变成浪费系统资源的操作，反而降低了整体性能。因此自旋锁是不适应锁占用时间长的并发情况的。

在 Java 中，`AtomicInteger` 类有自旋的操作，我们看一下代码：

~~~ java
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
~~~

CAS 操作如果失败就会一直循环获取当前 value 值然后重试。

另外自适应自旋锁也需要了解一下。

在JDK1.6又引入了自适应自旋，这个就比较智能了，自旋时间不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。如果虚拟机认为这次自旋也很有可能再次成功那就会次序较多的时间，如果自旋很少成功，那以后可能就直接省略掉自旋过程，避免浪费处理器资源。

##### 分段锁

`分段锁` 是一种锁的设计，并不是具体的一种锁。分段锁设计目的是将锁的粒度进一步细化，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

![1631531016803](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631531016803.png)

在 Java 语言中 CurrentHashMap 底层就用了分段锁，使用Segment，就可以进行并发使用了。

##### 锁升级（无锁|偏向锁|轻量级锁|重量级锁）

JDK1.6 为了提升性能减少获得锁和释放锁所带来的消耗，引入了4种锁的状态：`无锁`、`偏向锁`、`轻量级锁`和`重量级锁`，它会随着多线程的竞争情况逐渐升级，但不能降级。

**无锁**

`无锁`状态其实就是上面讲的乐观锁，这里不再赘述。

**偏向锁**

Java偏向锁(Biased Locking)是指它会偏向于第一个访问锁的线程，如果在运行过程中，只有一个线程访问加锁的资源，不存在多线程竞争的情况，那么线程是不需要重复获取锁的，这种情况下，就会给线程加一个偏向锁。

偏向锁的实现是通过控制对象`Mark Word`的标志位来实现的，如果当前是`可偏向状态`，需要进一步判断对象头存储的线程 ID 是否与当前线程 ID 一致，如果一致直接进入。

**轻量级锁**

当线程竞争变得比较激烈时，偏向锁就会升级为`轻量级锁`，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过`自旋方式`等待上一个线程释放锁。

**重量级锁**

如果线程并发进一步加剧，线程的自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为`重量级锁`，重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。

升级到重量级锁其实就是互斥锁了，一个线程拿到锁，其余线程都会处于阻塞等待状态。

在 Java 中，synchronized 关键字内部实现原理就是锁升级的过程：无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁。这一过程在后续讲解 synchronized 关键字的原理时会详细介绍。

##### 锁优化技术（锁粗化、锁消除）

**锁粗化**

`锁粗化`就是将多个同步块的数量减少，并将单个同步块的作用范围扩大，本质上就是将多次上锁、解锁的请求合并为一次同步请求。

举个例子，一个循环体中有一个代码同步块，每次循环都会执行加锁解锁操作。

~~~ java
private static final Object LOCK = new Object();

for(int i = 0;i < 100; i++) {
    synchronized(LOCK){
        // do some magic things
    }
}
~~~

经过`锁粗化`后就变成下面这个样子了：

~~~ java
 synchronized(LOCK){
     for(int i = 0;i < 100; i++) {
        // do some magic things
    }
}
~~~

**锁消除**

`锁消除`是指虚拟机编译器在运行时检测到了共享数据没有竞争的锁，从而将这些锁进行消除。

举个例子让大家更好理解。

~~~ java
public String test(String s1, String s2){
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(s1);
    stringBuffer.append(s2);
    return stringBuffer.toString();
}
~~~

上面代码中有一个 test 方法，主要作用是将字符串 s1 和字符串 s2 串联起来。

test 方法中三个变量s1, s2, stringBuffer， 它们都是局部变量，局部变量是在栈上的，栈是线程私有的，所以就算有多个线程访问 test 方法也是线程安全的。

我们都知道 StringBuffer 是线程安全的类，append 方法是同步方法，但是 test 方法本来就是线程安全的，为了提升效率，虚拟机帮我们消除了这些同步锁，这个过程就被称为`锁消除`。

~~~ java
StringBuffer.class

// append 是同步方法
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
~~~

**总结**

![1631531251684](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/190737-165662.png)

### volatile 

#### volatile的作用是什么？ 

volatile 是一个轻量级的 synchronized ，一般作用与变量，在多处理器开发的过程中保证了内存的**可见性**。相比于 synchronized 关键字， volatile 关键字的执行成本更低，效率更高 。

#### volatile的特性有哪些？ 

> 并发编程的三大特性为可见性、有序性和原子性。通常来讲 volatile 可以保证可见性和有序性 

- 可见性： volatile 可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。
- 有序性： volatile 会通过禁止指令重排序进而保证有序性。
- 原子性：对于单个的 volatile 修饰的变量的读写是可以保证原子性的，但对于 i++ 这种复合操作并不能保证原子性。这句话的意思基本上就是说 volatile 不具备原子性了。 

#### Java内存的可见性问题 

Java的内存模型如下图所示。 

![1631531465862](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/191115-817041.png)

这里的本地内存并不是真实存在的，只是Java内存模型的一个抽象概念，它包含了控制器、运算器、缓
存等。同时Java内存模型规定，线程对共享变量的操作必须在自己的本地内存中进行，不能直接在主内
存中操作共享变量。这种内存模型会出现什么问题呢？ 

1. 线程A获取到共享变量X的值，此时本地内存A中没有X的值，所以加载主内存中的X值并缓存到本地内存A中，线程A修改X的值为1，并将X的值刷新到主内存中，这时主内存及本地内存A中的X的值都为1。

2. 线程B需要获取共享变量X的值，此时本地内存B中没有X的值，加载主内存中的X值并缓存到本地内存B中，此时X的值为1。线程B修改X的值为2，并刷新到主内存中，此时主内存及本地内存B中的X值为2，本地内存A中的X值为1。
3. 线程A再次获取共享变量X的值，此时本地内存中存在X的值，所以直接从本地内存中A获取到了X为1的值，但此时主内存中X的值为2，到此出现了所谓内存不可见的问题。该问题Java内存模型是通过 synchronized 关键字和 volatile 关键字就可以解决。 

#### 为什么代码会重排序？ 

计算机在执行程序的过程中，编译器和处理器通常会对指令进行重排序，这样做的目的是为了提高性能。具体可以看下面这个例子。 

~~~ java
int a = 1;
int b = 2;
int a1 = a;
int b1 = b;
int a2 = a + a;
int b2 = b + b;
~~~

像这段代码，不断地交替读取a和b，会导致寄存器频繁交替存储a和b，使得代码性能下降，可对其进入如下重排序:

~~~ java
int a = 1;
int b = 2;
int a1 = a;
int a2 = a + a;
int b1 = b;
int b2 = b + b;
~~~

按照这样地顺序执行代码便可以避免交替读取a和b，这就是重排序地意义。

指令重排序一般分为**编译器优化重排、指令并行重拍和内存系统重排**三种。 

- 编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重新排序。
- 指令并行重排：现代处理器多采用指令级并行技术来将多条指令重叠执行。对于不存在数据依赖的程序，处理器可以对机器指令的执行顺序进行重新排列。
- 内存系统重排：因为处理器使用缓存和读/写缓冲区，使得加载（load）和存储（store）看上去像是在乱序执行。 

注：简单解释下数据依赖性：如果两个操作访问了同一个变量，并且这两个操作有一个是写操作，这两个操作之间就会存在数据依赖性，例如： 

~~~ java
a = 1;
b = a;
~~~

如果对这两个操作的执行顺序进行重排序的话，那么结果就会出现问题。

> 其实，这三种指令重排说明了一个问题，就是指令重排在单线程下可以提高代码的性能，但在多线程下可以会出现一些问题  。

#### 重排序会引发什么问题？ 

前面已经说过了，在单线程程序中，重排序并不会影响程序的运行结果，而在多线程场景下就不一定了。可以看下面这个经典的例子，该示例出自《Java并发编程的艺术》 

~~~ java
class ReorderExample{
	int a = 0;
	boolean flag = false;
	public void writer(){
		a = 1; // 操作1
		flag = true; // 操作2
	}
	public void reader(){
		if(flag){ // 操作3
			int i = a + a; // 操作4
		}
	}
}
~~~

假设线程1先执行 writer() 方法，随后线程2执行 reader() 方法，最后程序一定会得到正确的结果吗？

答案是不一定的，如果代码按照下图的执行顺序执行代码则会出现问题。

![1631531886203](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/191808-33628.png) 

操作1和操作2进行了重排序，线程1先执行 flag=true ，然后线程2执行操作3和操作4，线程2执行操作4时不能正确读取到 a 的

值，导致最终程序运行结果出问题。这也说明了在多线程代码中，重排序会破坏多线程程序的语义 

#### as-if-serial规则和happens-before规则的区别 

区别：

- as-if-serial定义：无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变。

- happens-before定义：一个操作happens-before另一个操作，表示第一个的操作结果对第二个操作可见，并且第一个操作的

  执行顺序也在第二个操作之前。但这并不意味着Java虚拟机必须按照这个顺序来执行程序。如果重排序的后的执行结果与按

  happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。happens-before关系保证了同步的多线程程序的

  执行结果不被改变，as-if-serial保证了单线程内程序的执行结果不被改变。

相同点：happens-before和as-if-serial的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度。

#### voliatile的实现原理？ 

> 前面已经讲述 volatile 具备可见性和有序性两大特性，所以 volatile 的实现原理也是围绕如何实现可见性和有序性展开的 

#### volatile实现内存可见性原理 

> 导致内存不可见的主要原因就是Java内存模型中的本地内存和主内存之间的值不一致所导致，例如上面所说线程A访问自己本地内存A的X值时，但此时主内存的X值已经被线程B所修改，所以线程A所访问到的值是一个脏数据。那如何解决这种问题呢？ 

volatile 可以保证内存可见性的关键是 volatile 的读/写实现了缓存一致性，缓存一致性的主要内容为：

- 每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。
- 当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。

那缓存一致性是如何实现的呢？可以发现通过 volatile 修饰的变量，生成汇编指令时会比普通的变量多出一个 Lock 指令，这个 Lock 指令就是 volatile 关键字可以保证内存可见性的关键，它主要有两个作用：

- 将当前处理器缓存的数据刷新到主内存。
- 刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效 

#### volatile实现有序性原理 

> 前面提到重排序可以提高代码的执行效率，但在多线程程序中可以导致程序的运行结果不正确，那 volatile 是如何解决这一问题的呢？ 

- 为了实现 volatile 的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。
- 内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行 ,防止发生指令重排列。

#### Java虚拟机插入内存屏障的策略 

Java内存模型把内存屏障分为4类，如下表所示： 

![1631532338152](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631532338152.png)

> 注：StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令。

Java内存模型对编译器指定的 volatile 重排序规则为： 

- 当第一个操作是 volatile 读时，无论第二个操作是什么都不能进行重排序。
- 当第二个操作是 volatile 写时，无论第一个操作是什么都不能进行重排序。
- 当第一个操作是 volatile 写，第二个操作为 volatile 读时，不能进行重排序。 

根据 volatile 重排序规则，Java内存模型采取的是保守的屏障插入策略， volatile 写是在前面和后面分别插入内存屏障， volatile 读是在后面插入两个内存屏障，具体如下： 

- volatile 读：在每个 volatile 读后面分别插入LoadLoad屏障及LoadStore屏障（根据volatile 重排序规则第一条），如下图所示 :

![1631532488831](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/192810-401672.png)

LoadLoad屏障的作用：禁止上面的所有普通读操作和上面的 volatile 读操作进行重排序。 

LoadStore屏障的作用：禁止下面的普通写和上面的 volatile 读进行重排序。 

- volatile 写：在每个 volatile 写前面插入一个StoreStore屏障（为满足 volatile 重排序规则第二条），在每个 volatile 写后面插入一个StoreLoad屏障（为满足 volatile 重排序规则第三条），如下图所示 

![1631532583507](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/192945-330101.png)

StoreStore屏障的作用：禁止上面的普通写和下面的 volatile 写重排序

StoreLoad屏障的作用：防止上面的 volatile 写与下面可能出现的 volatile 读/写重排序。 

#### 编译器对内存屏障插入策略的优化 

> 因为Java内存模型所采用的屏障插入策略比较保守，所以在实际的执行过程中，只要不改变volatile 读/写的内存语义，编译器通常会省略一些不必要的内存屏障。 

**代码演示**

~~~ java
public class volatileBarrierDemo{
int a;
volatile int b = 1;
volatile int c = 2;
public void test(){
  int i = b; //`volatile`读
  int j = c; //`volatile`读
  a = i + j; //普通写
  }
}
~~~

指令序列示意图如下： 

![1631532747889](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/193229-614286.png)

从上图可以看出，通过指令优化一共省略了两个内存屏障（虚线表示），省略第一个内存屏障LoadStore的原因是最后的普通写

不可能越过第二个 volatile 读，省略第二个内存屏障LoadLoad的原因是下面没有涉及到普通读的操作。 

#### volatile能使一个非原子操作变成一个原子操作吗？ 

volatile 只能保证可见性和有序性，但可以保证64位的 long 型和 double 型变量的原子性。

对于32位的虚拟机来说，每次原子读写都是32位的，会将 long 和 double 型变量拆分成两个32位的操作来执行，这样 long 和 double 型变量的读写就不能保证原子性了，而通过 volatile 修饰的long和double型变量则可以保证其原子性。 

#### volatile、synchronized的区别？ 

- volatile 主要是保证内存的可见性，即变量在寄存器中的内存是不确定的，需要从主存中读取。
- synchronized 主要是解决多个线程访问资源的同步性。
- volatile 作用于变量， synchronized 作用于代码块或者方法。
- volatile 仅可以保证数据的可见性，不能保证数据的原子性。 synchronized 可以保证数据的可见性和原子性。
- volatile 不会造成线程的阻塞， synchronized 会造成线程的阻塞 

### ConcurrentHashMap 

#### 什么是ConcurrentHashMap？相比于HashMap和HashTable有什么优势 
CocurrentHashMap 可以看作线程安全且高效的 HashMap ，相比于 HashMap 具有线程安全的优势，相比于 HashTable 具有效率高的优势。 

#### java中ConcurrentHashMap是如何实现的？ 

> 这里经常会将jdk1.7中的 ConcurrentHashMap 和jdk1.8中的 ConcurrentHashMap 的实现方式进行对比。 

**JDK1.7**

在JDK1.7版本中， ConcurrentHashMap 的数据结构是由一个 Segment 数组和多个 HashEntry 数组组成， Segment 存储的是链表数组的形式，如图所示。 

![1631533019511](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/193701-968298.png)

从上图可以看出， ConcurrentHashMap 定位一个元素的过程需要两次Hash的过程，第一次Hash的目的是定位到Segment，第二次Hash的目的是定位到链表的头部。第二次Hash所使用的时间比一次Hash的时间要长，但这样做可以在写操作时，只对元素所在的segment枷锁，不会影响到其他segment，这样可以大大提高并发能力。 

**JDK1.8**

JDK1.8不在采用segment的结构，而是使用Node数组+链表/红黑树的数据结构来实现的（和 HashMap一样，链表节点个数大于8，链表会转换为红黑树）
如下图所示 ：

![1631533115608](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/193837-979469.png)

从上图可以看出，对于 ConcurrentHashMap 的实现，JDK1.8的实现方式可以降低锁的粒度，因为JDLK1.7所实现的 ConcurrentHashMap 的锁的粒度是基于Segment，而一个Segment包含多个HashEntry 

#### ConcurrentHashMap结构中变量使用volatile和final修饰有什么作用？ 

final 修饰变量可以保证变量不需要同步就可以被访问和共享， volatile 可以保证内存的可见性，配合CAS操作可以在不加锁的前提支持并发。 

#### ConcurrentHashMap有什么缺点？ 

因为 ConcurrentHashMap 在更新数据时只会锁住部分数据，并不会将整个表锁住，读取的时候也并不能保证读取到最近的更新，只能保证读取到已经顺利插入的数据 

#### ConcurrentHashMap默认初始容量是多少？每次扩容为原来的几倍？ 
默认的初始容量为16，每次扩容为之前的两倍。 

#### ConCurrentHashMap 的key，value是否可以为null？为什么？HashMap中的key、value是否可以为null？ 

ConCurrentHashMap 中的 key 和 value 为 null 会出现空指针异常，而 HashMap 中的 key 和 value 值是可以为 null 的。

原因如下： ConCurrentHashMap 是在多线程场景下使用的，如果 ConcurrentHashMap.get(key) 的值为 null ，那么无法判断到底是 key 对应的 value 的值为 null 还是不存在对应的 key 值。而在单线程场景下的 HashMap 中，可以使用 containsKey(key) 来判断到底是不存在这个 key 还是 key 对应的value 的值为 null 。在多线程的情况下使用 containsKey(key) 来做这个判断是存在问题的，因为在containsKey(key) 和 ConcurrentHashMap.get(key) 两次调用的过程中， key 的值已经发生了改变。 

#### ConCurrentHashmap在JDK1.8中，什么情况下链表会转化为红黑树？ 
当链表长度大于8，Node数组数大于64时 。

#### ConcurrentHashMap在JDK1.7和JDK1.8版本中的区别？ 

**实现结构上的不同**，JDK1.7是基于Segment实现的，JDK1.8是基于Node数组+链表/红黑树实现的。

**保证线程安全方面**：JDK1.7采用了分段锁的机制，当一个线程占用锁时，会锁住一个Segment对象，不会影响其他Segment对

象。JDK1.8则是采用了CAS和 synchronize 的方式来保证线程安全。

**在存取数据方面：** 

JDK1.7中的 put() 方法：
1. 先计算出 key 的 hash 值，利用 hash 值对segment数组取余找到对应的segment对象。
2. 尝试获取锁，失败则自旋直至成功，获取到锁，通过计算的 hash 值对hashentry数组进行取余，找到对应的entry对象。
3. 遍历链表，查找对应的 key 值，如果找到则将旧的value直接覆盖，如果没有找到，则添加到链表中。（JDK1.7是插入到链表头部，JDK1.8是插入到链表尾部，这里可以思考一下为什么这样）

JDK1.8中的 put() 方法:

1. 计算 key 值的 hash 值，找到对应的 Node ，如果当前位置为空则可以直接写入数据。
2. 利用CAS尝试写入，如果失败则自旋直至成功，如果都不满足，则利用 synchronized 锁写入数据 

#### ConcurrentHashMap迭代器是强一致性还是弱一致性？ 

与HashMap不同的是， ConcurrentHashMap 迭代器是弱一致性。

> 这里解释一下弱一致性是什么意思，当 ConcurrentHashMap 的迭代器创建后，会遍历哈希表中的元素，在遍历的过程中，哈希表中的元素可能发生变化，如果这部分变化发生在已经遍历过的地方，迭代器则不会反映出来，如果这部分变化发生在未遍历过的地方，迭代器则会反映出来。换种说法就是put() 方法将一个元素加入到底层数据结构后， get() 可能在某段时间内还看不到这个元素。这样的设计主要是为 ConcurrenthashMap 的性能考虑，如果想做到强一致性，就要到处加锁，性能会下降很多。所以 ConcurrentHashMap 是支持在迭代过程中，向map中添加元素的，而 HashMap 这样操作则会抛出异常 

### ThreadLocal 

#### 什么是ThreadLocal？有哪些应用场景？ 

ThreadLocal 是 JDK java.lang 包下的一个类， ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的局部变量冲突，实现了线程间的数据隔离。

ThreadLocal 的应用场景主要有以下几个方面： 

- 保存线程上下文信息，在需要的地方可以获取。
- 线程间数据隔离
- 数据库连接 

#### ThreadLocal原理和内存泄露？ 

ThreadLocal 的原理可以概括为下图： 

![1631533687385](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/194809-910371.png)

从上图可以看出每个线程都有一个 ThreadLocalMap ， ThreadLocalMap 中保存着所有的ThreadLocal ，而 ThreadLocal 本身只是一个引用本身并不保存值，值都是保存在 ThreadLocalMap中的，其中 ThreadLocal 为 ThreadLocalMap 中的 key 。其中图中的虚线表示弱引用。

这里简单说下Java中的引用类型，Java的引用类型主要分为强引用、软引用、弱引用和虚引用。

- 强引用：发生 gc 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用：无法通过虚引用获得对象，虚引用的用途是在 gc 时返回一个通知。 

**为什么ThreadLocal会发生内存泄漏呢？**

- 因为 ThreadLocal 中的 key 是弱引用，而 value 是强引用。当 ThreadLocal 没有被强引用时，在进行垃圾回收时， key 会被清理掉，而 value 不会被清理掉，这时如果不做任何处理， value 将永远不会被回收，产生内存泄漏。 

**如何解决ThreadLocal的内存泄漏？**

- 其实在 ThreadLocal 在设计的时候已经考虑到了这种情况，在调用 set() 、 get() 、 remove() 等方法时就会清理掉 key 为 null 的记录，所以在使用完 ThreadLocal 后最好手动调用 remove() 方法。

**为什么要将key设计成ThreadLocal的弱引用？**

- 如果 ThreadLocal 的 key 是强引用，同样会发生内存泄漏的。如果 ThreadLocal 的 key 是强引用，引用的 ThreadLocal 的对象被回收了，但是 ThreadLocalMap 还持有 ThreadLocal 的强引用，如果没有手动删除， ThreadLocal 不会被回收，发生内存泄漏。 
- 如果是弱引用的话，引用的 ThreadLocal 的对象被回收了，即使没有手动删除， ThreadLocal 也会被回收。 value 也会在 ThreadLocalMap 调用 set() 、 get() 、 remove() 的时候会被清除。
- 所以两种方案比较下来，还是 ThreadLoacl 的 key 为弱引用好一些 

### 线程池

#### 什么是线程池？为什么使用线程池 

线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交给线程池来管理。 

**为什么使用线程池？**

- 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度，当任务到达时，任务可以不需要等到线程创建就立即执行。
- 提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一分配。 

#### 创建线程池的方式

线程池的常用创建方式主要有两种，通过Executors工厂方法创建和通过new ThreadPoolExecutor方法创建。 

**Executors工厂方法创建，在工具类 Executors 提供了一些静态的工厂方法：**

1. newSingleThreadExecutor ：创建一个单线程的线程池。
2. newFixedThreadPool ：创建固定大小的线程池。
3. newCachedThreadPool ：创建一个可缓存的线程池。
4. newScheduledThreadPool ：创建一个大小无限的线程池。 

**new ThreadPoolExecutor 方法创建：** 

~~~ java
new ThreadPoolExecutor(
  int corePoolSize,
  int maximumPoolSize, 
  long keepAliveTime, 
  TimeUnit unit, 
  BlockingQueue<Runnable> workQueue，
	ThreadFactory threadFactory,
  RejectedExecutionHandler handler) 
~~~

#### ThreadPoolExecutor构造函数的重要参数分析 

**三个比较重要的参数：**

- corePoolSize ：核心线程数，定义了最小可以同时运行的线程数量。
- maximumPoolSize ：线程中允许存在的最大工作线程数量
- workQueue ：存放任务的阻塞队列。新来的任务会先判断当前运行的线程数是否到达核心线程数，如果到达的话，任务就会先放到阻塞队列。

**其他参数：**

- keepAliveTime ：当线程池中的数量大于核心线程数时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到时间超过 keepAliveTime 时才会被销毁。
- unit ： keepAliveTime 参数的时间单位。
- threadFactory ：为线程池提供创建新线程的线程工厂。
- handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略 

#### ThreadPoolExecutor的饱和策略（拒绝策略 )

当同时运行的线程数量达到最大线程数量并且阻塞队列也已经放满了任务时， ThreadPoolExecutor 会指定一些饱和策略。主要有以下四种类型：

- AbortPolicy 策略：该策略会直接抛出异常拒绝新任务
- CallerRunsPolicy 策略：当线程池无法处理当前任务时，会将该任务交由提交任务的线程来执行。
- DiscardPolicy 策略：直接丢弃新任务。
- DiscardOleddestPolicy 策略：丢弃最早的未处理的任务请求。 

#### 线程池的执行流程 

创建线程池创建后提交任务的流程如下图所示： 

![1631534178687](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/13/195619-279990.png)

#### execute()方法和submit()方法的区别 

> 这个地方首先要知道Runnable接口和Callable接口的区别，之前有写到过 

execute() 和 submit() 的区别主要有两点：

- execute() 方法只能执行 Runnable 类型的任务。 submit() 方法可以执行 Runnable 和Callable 类型的任务。
- submit() 方法可以返回持有计算结果的 Future 对象，同时还可以抛出异常，而 execute() 方法不可以。
- 换句话说就是， execute() 方法用于提交不需要返回值的任务， submit() 方法用于需要提交返回值的
  任务。 

## 数据库

### 什么是Mysql数据库

MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），使用最常用的数据库管理语言--**结构化查询语言（SQL）**进行数据库管理。MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。 

### Mysql常用的存储引擎有哪些，他们都有什么特点？

**InnoDB**

- InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。

**MyISAM**

- MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。 

两种引擎对比：

![1631753040455](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/084403-805112.png)

### 数据库的三大范式

- 第一范式：确保每列保持原子性，数据表中的所有字段值都是不可分解的原子值。在任何一个关系型数据库中，满足第一范式是最基本的要求，
  - 1NF是对属性的**原子性**，要求属性具有原子性，不可再分解；
  - 如学生（学号，姓名，性别，出生日期），可以看到每一个列属性都是不可在分割的单位，这就是原子性的含义。
  - 解决方法：对可以再分的列字段，进行拆分，划分为多个表。
- 第二范式：确保表中的每列都和主键相关
  - 2NF是对记录的**唯一性**，要求记录有唯一标识，即实体的唯一性，即**不存在部分依赖，必须是完全依赖，也就是所有的非主属性必须完全依赖于主属性**；
  - 如表：（学号，课程号，姓名，学分），这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里**学分依赖课程号**，**姓名依赖与学号**，所以不符合二范式。所以我们要对表进行拆分，让其符合第二范式，学生：`Student`(学号, 姓名)；课程：`Course`(课程号, 学分)；选课关系：`StudentCourse`(学号, 课程号, 成绩)。
  - 解决方法：一般是把表拆分为两个表，一张表只管理一件事。
  - 如果不符合第二范式，可能会存在的问题：
    - `数据冗余:`，每条记录都含有相同信息；
    - `删除异常：`删除所有学生成绩，就把课程信息全删除了；
    - `插入异常：`学生未选课，无法记录进数据库；
    - `更新异常：`调整课程学分，所有行都调整。
- 第三范式：确保每列都和主键列直接相关而不是间接相关 
  - 3NF是对字段的**冗余性**，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即**不存在传递依赖**，不存在属性对主键的**传递依赖**。；
  - 表: 学号, 姓名, 年龄, 学院名称, 学院电话，因为存在**依赖传递**: (学号) → (学生)→(所在学院) → (学院电话) 。所以对表进行拆分，消除传递函数依赖，学生：(学号, 姓名, 年龄, 所在学院)；学院：(学院, 电话)。
  - **可能会存在问题：**
    - `数据冗余:`有重复值；
    - `更新异常：`有重复的冗余信息，修改时需要同时修改多条记录，否则会出现**数据不一致的情况** 。
    - `插入异常`：学生未选课，无法记录进数据库；
    - `删除异常`:删除所有学生成绩，就把课程信息全删除了；

### Mysql的数据类型都有哪些？

**整数**

- TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别占用8、16、24、32、64位存储空间。值得注意的是，INT(10)中的10只是表示显示字符的个数，并无实际意义。一般和UNSIGNED ZEROFILL配合使用才有实际意义，例如，数据类型INT(3)，属性为UNSIGNED ZEROFILL，如果插入的数据为3的话，实际存储的数据为003。

**浮点数**

- FLOAT、DOUBLE及DECIMAL为浮点数类型，DECIMAL是利用字符串进行处理的，能存储精确的小数。相比于FLOAT和DOUBLE，DECIMAL的效率更低些。FLOAT、DOUBLE及DECIMAL都可以指定列宽，例如FLOAT(5,2)表示一共5位，两位存储小数部分，三位存储整数部分。

**字符串**

- 字符串常用的主要有CHAR和VARCHAR，VARCHAR主要用于存储可变长字符串，相比于定长的CHAR更节省空间。CHAR是定长的，根据定义的字符串长度分配空间。
  - 应用场景：对于经常变更的数据使用CHAR更好，CHAR不容易产生碎片。对于非常短的列也是使用CHAR更好些，CHAR相比于VARCHAR在效率上更高些。一般避免使用TEXT/BLOB等类型，因为查询时会使用临时表，造成严重的性能开销。

**日期**

- 比较常用的有year、time、date、datetime、timestamp等，datetime保存从1000年到9999年的时间，精度位秒，使用8字节的存储空间，与时区无关。timestamp和UNIX的时间戳相同，保存从1970年1月1日午夜到2038年的时间，精度到秒，使用四个字节的存储空间，并且与时区相关。
  - 应用场景：尽量使用timestamp，相比于datetime它有着更高的空间效率。 

### 索引

#### 什么是索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引的一个主要目的就是加快检索表中数据，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

**分 类：** 聚簇索引 、非聚簇索引

**目 的：** 加快对表中记录的查找或排序

#### 索引的优缺点

**索引的特点：**

1. 索引可以加快数据库的检索速度

2. 索引降低了数据库插入、修改、删除等维护任务的速度

3. 索引创建在表上，不能创建在视图上

4. 索引既可以直接创建，也可以间接创建

5. 可以在优化隐藏中，使用索引

**优点：**

- 大大加快数据检索的速度，这个是建立索引的主要原因。
- 创建唯一性索引，保证数据库表中每一行数据的唯一性
- 将随机I/O变成顺序I/O(因为B+树的叶子节点是连接在一起的)
- 加速表与表之间的连接 
- 索引降低了数据库插入、修改、删除等维护任务的速度、
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

- 索引创建在表上，不能创建在视图上
- 索引既可以直接创建，也可以间接创建

> 总之建立索引就是为了提高数据库的性能。

**缺点：**

1. 从时间角度来考虑：建立索引和维护索引都需要时间开销，会影响数据库的性能，特别是随着数据量增加的时候。
2. 从屋里空间考虑：索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度

**索引分类**

1. 直接创建索引和间接创建索引
   - 直接创建索引： `CREATE INDEX mycolumn_index ON mytable (myclumn)`,直接在某一张表的列上面建立索引。
   - 间接创建索引：  定义主键约束或者唯一性键约束，可以间接创建索引。

2. 普通索引和唯一性索引
   - 普通索引：`CREATE INDEX mycolumn_index ON mytable (myclumn)`
   - 唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用

​         　`CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn)`

3. 单个索引和复合索引
   - 单个索引：即非复合索引,通常使用一个字段创建索引。
   - 复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，最多16个字段

　　　　`CREATE INDEX name_index ON username(firstname,lastname)`

4. 聚簇索引和非聚簇索引(聚集索引，群集索引)

   - 聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列

     `CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH`

     　　　　`ALLOW_DUP_ROW(允许有重复记录的聚簇索引)`

   - 非聚簇索引：

　　　　`CREATE UNCLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn)`

#### 索引的数据结构

索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类
型有B+树索引和哈希索引，默认的索引类型为B+树索引 。

**B+树索引**

熟悉数据结构的同学都知道，B+树、平衡二叉树、红黑树都是经典的数据结构。在B+树中，所有的记录节点都是按照键值大小的顺序放在叶子节点上，如下图。 

![1631755572547](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/092644-99595.png)

关于B树B+树这种数据结构，请参考文章：[数据结构-（2-3树，2-3-4树，B-树，B+树）](https://blog.csdn.net/qq_38163244/article/details/109704712)

从上图可以看出 ，因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。
B+树的索引又可以分为**主索引和辅助索引**。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇索引是以主键作为B+ 树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记录；非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。上图中叶子节点存储的是数据记录，为聚簇索引的结构图，非聚簇索引的结构图如下: 

![1631755805924](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631755805924.png)

上图中的字母为数据的非主键的列值，假设要查询该列值为B的信息，则需先找到主键7，在到聚簇索引中查询主键7所对应的数据域。
**哈希索引**
哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是o(1)，一般多用于精确查找 。

#### Hash索引和B+树的区别？

因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。

- 哈希索引不支持排序，因为哈希表是无序的。
- 哈希索引不支持范围查找。
- 哈希索引不支持模糊查询及多列索引的最左前缀匹配。
- 因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点 。

#### 索引的类型有哪些

MySQL主要的索引类型主要有FULLTEXT，HASH，BTREE，RTREE。
**FULLTEXT**

- FULLTEXT即全文索引，MyISAM存储引擎和InnoDB存储引擎在MySQL5.6.4以上版本支持全文索引，一般用于查找文本中的关键字，而不是直接比较是否相等，多在CHAR，VARCHAR，TAXT等数据类型上创建全文索引。全文索引主要是用来解决WHERE name LIKE "%zhang%"等针对文本的模糊查询效率低的问题。

**HASH**

- HASH即哈希索引，哈希索引多用于等值查询，时间复杂夫为o(1)，效率非常高，但不支持排序、范围查询及模糊查询等。

**BTREE**

- BTREE即B+树索引，INnoDB存储引擎默认的索引，支持排序、分组、范围查询、模糊查询等，并且性能稳定。

**RTREE**

- RTREE即空间数据索引，多用于地理数据的存储，相比于其他索引，空间数据索引的优势在于范围查找 

#### 索引的种类有哪些？

1. 主键索引：数据列不允许重复，不能为NULL，一个表只能有一个主键索引

2. 组合索引：由多个列值组成的索引。

3. 唯一索引：数据列不允许重复，可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。

4. 全文索引：对文本的内容进行搜索。

5. 普通索引：基本的索引类型，可以为NULL 。

#### B树和B+树的区别？

B树和B+树最主要的区别主要有两点：

- B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值。

- B＋树的叶子节点是通过相连在一起的，方便顺序检索。

两者的结构图如下：

**B树**

![1631756434279](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/094038-927137.png)

**B+树**

![1631756460901](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/094111-18813.png)

关于B树B+树这种数据结构，请参考文章：[数据结构-（2-3树，2-3-4树，B-树，B+树）](https://blog.csdn.net/qq_38163244/article/details/109704712)

#### 数据库为什么使用B+树而不是B树？ 

1. B树适用于随机检索，而B+树适用于随机检索和顺序检索

2. B+树的空间利用率更高，因为B树每个节点要存储键和值，而B+树的内部节点只存储键，这样B+树的一个节点就可以存储更多的索引，从而使树的高度变低，减少了I/O次数，使得数据检索速度更快。

3. B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便

4. B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的值可能不在叶子节点，在内部节点就已经找到。

那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地

方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引 

#### 什么是聚簇索引，什么是非聚簇索引？

聚簇索引和非聚簇索引最主要的区别是**数据和索引是否分开存储**。

- 聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。

- 非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。

在InnoDB存储引擎中，默认的索引为B+树索引，利用主键创建的索引为主索引，也是聚簇索引，在主索引之上创建的索引为辅助索引，也是非聚簇索引。为什么说辅助索引是在主索引之上创建的呢，因为辅助索引中的叶子节点存储的是主键。

在MyISAM存储引擎中，默认的索引也是B+树索引，但主索引和辅助索引都是非聚簇索引，也就是说索引结构的叶子节点存储的都是一个指向数据行的地址。并且使用辅助索引检索无需访问主键的索引。可以从非常经典的两张图看看它们的区别(图片来源于网络)： 

![1631756839489](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/094730-925250.png)

![1631756868658](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/094750-68141.png)

#### 非聚簇索引一定会进行回表查询吗？

上面是说了非聚簇索引的叶子节点存储的是主键，也就是说要先通过非聚簇索引找到主键，再通过聚簇索引找到主键所对应的数据，后面这个再通过聚簇索引找到主键对应的数据的过程就是回表查询，那么非聚簇索引就一定会进行回表查询吗 ？

答案是不一定的，这里涉及到一个索引覆盖的问题，如果查询的数据再辅助索引上完全能获取到便不需要回表查询。例如有一张表存储着个人信息包括id、name、age等字段。假设聚簇索引是以ID为键值构建的索引，非聚簇索引是以name为键值构建的索引， `select id,name from user where name =zhangsan`; 这个查询便不需要进行回表查询因为，通过非聚簇索引已经能全部检索出数据，这就是索引覆盖的情况。如果查询语句是这样， `select id,name,age from user where name ='zhangsan`; 则需要进行回表查询，因为通过非聚簇索引不能检索出age的值。那应该如何解决那呢？只需要将索引覆盖即可，建立age和name的联合索引再使用 `select id,name,age from user where name = 'zhangsan`; 进行查询即可。所以通过索引覆盖能解决非聚簇索引回表查询的问题。 

#### 索引的使用场景有哪些？

- 对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。

- 对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。

- 如果表的增删改非常多，而查询需求非常少的话，那就没有必要建立索引了，因为维护索引也是需要代价的。

- 一般不会出现再where条件中的字段就没有必要建立索引了。

- 多个字段经常被查询的话可以考虑联合索引。

- 字段多且字段值没有重复的时候考虑唯一索引。

- 字段多且有重复的时候考虑普通索引 

#### 索引的设计原则有哪些？

1. 最适合索引的列是在*where*后面出现的列或者连接句子中指定的列，而不是出现在SELECT关键字后面的选择列表中的列。

2. 索引列的基数越大，索引的效果越好，换句话说就是索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差，因为列的基数最多也就是三种，大多不是男性就是女性。

3. 尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。尽量利用最左前缀。
4. 不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。 

#### 如何对索引进行优化

1. 对索引的优化其实最关键的就是要符合索引的设计原则和应用场景，将不符合要求的索引优化成符合索引设计原则和应用场景的索引。

2. 除了索引的设计原则和应用场景那几点外，还可以从以下两方面考虑。

3. 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，因为这样无法使用索引。例如 `select * from table_name where a + 1 = 2`。
   将区分度最高的索引放在前面

4. 尽量少使用`select*`。

索引的使用场景、索引的设计原则和如何对索引进行优化可以看成一个问题。 

#### 如何创建删除索引？

**创建索引：**

1. 使用CREATE INDEX 语句

~~~ sql
CREATE INDEX index_name ON table_name (column_list);
~~~

2. 在CREATE TABLE时创建 

~~~ sql
CREATE TABLE user(
  id INT PRIMARY KEY,
  information text,
  FULLTEXT KEY (information)
);
~~~

3. 使用ALTER TABLE创建索引 

~~~ sql
ALTER TABLE table_name ADD INDEX index_name (column_list);
~~~

**删除索引**

1. 删除主键索引 

~~~ sql
alter table 表名 drop primary key
~~~

2. 删除其他索引

~~~ sql
alter table 表名 drop key 索引名
~~~

#### 使用索引查询时性能一定会提升吗？

不一定，前面在索引的使用场景和索引的设计原则中已经提到了如何合理地使用索引，因为创建和维护索引需要花费空间和时间上的代价，如果不合理地使用索引反而会使查询性能下降 。

#### 什么是前缀索引

前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

- 使用场景：前缀的区分度比较高的情况下。

- 建立前缀索引的方式

~~~ sql
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
~~~

这里面有个prefix_length参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确定，先计算全列的区分度。

~~~ sql
SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
~~~

然后在计算前缀长度为多少时和全列的区分度最相似。

~~~ sql
SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name
~~~


不断地调整`prefix_length`的值，直到和全列计算出区分度相近。 

#### 什么是最左匹配原则

最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（<、>、between、like）会停止匹配。

例如建立索引(a,b,c)，大家可以猜测以下几种情况是否用到了索引 

**第一种**

~~~ sql
select * from table_name where a = 1 and b = 2 and c = 3
select * from table_name where b = 2 and a = 1 and c = 3 -- 调动索引字段顺序不会影响查询效率
~~~

上面两次查询过程中所有值都用到了索引，where后面字段调换不会影响查询结果，因为MySQL中的优化器会自动优化查询顺序。 

**第二种**

~~~ sql
select * from table_name where a = 1
select * from table_name where a = 1 and b = 2
select * from table_name where a = 1 and b = 2 and c = 3
~~~

答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。 

**第三种**

~~~sql
select * from table_name where b = 1
select * from table_name where b = 1 and c = 2
~~~

答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的 ,建立的索引a没有生效，所以索引b,c都失效。

**第四种**

~~~ sql
select * from table_name where a = 1 and c = 2
~~~

这个查询语句只有a列用到了索引，c列没有用到索引，因为中间跳过了b列，不是从最左开始连续匹配的,这里索引c失效。

**第五种**

~~~ sql 
select * from table_name where a = 1 and b < 3 and c < 1
~~~

这个查询中只有a列和b列使用到了索引，而c列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。

**第六种**

 ~~~ sql 
select * from table_name where a like 'ab%';
select * from table_name where a like '%ab'
select * from table_name where a like '%ab%'
 ~~~

对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描 .

#### 索引在什么情况下会失效？

在上面介绍了几种不符合最左匹配原则的情况会导致索引失效，除此之外，以下这几种情况也会导致索引失效。

1. 条件中有or，例如 `select * from table_name where a = 1 or b = 3`

2. 在索引上进行计算会导致索引失效，例如 `select * from table_name where a + 1 = 2`

3. 在索引的类型上进行数据类型的隐形转换，会导致索引失效，例如字符串一定要加引号，假设`select * from table_name where a = '1' `会使用到索引，如果写成 `select * from table_name where a = 1 `则会导致索引失效。

4. 在索引中使用函数会导致索引失效，例如 `select * from table_name where abs(a) = 1`

5. 在使用like查询时以%开头会导致索引失效

6. 索引上使用`！、=、<>`进行判断时会导致索引失效，例如` select * from table_name where a!= 1`

7. 索引字段上使用` is null/is not null`判断时会导致索引失效，例如 `select * from table_namewhere a is null `

### 数据库事务

#### 什么是数据库事务？

百度百科的解释：数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成 

#### 事务的四大特性是什么？

- 原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚 。
- 隔离性：一致性指事务在执行前后状态是一致的 。
- 一致性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的 。
- 持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。 

#### 数据库的并发一致性问题

当多个事务并发执行时，可能会出现以下问题：

- 脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。

- 不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。

- 幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。

- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。

不可重复度和幻读看起来比较像，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被更新了。在幻读中，发现数据不一致主要是数据增多或者减少了。

#### 数据库的隔离级别有哪些？

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的。

- 提交读：一个事务提交之后，它的修改才能被其他事务看到。

- 可重复读：在同一个事务中多次读取到的数据是一致的。

- 串行化：需要加锁实现，会强制事务串行执行。  

数据库的隔离级别可以解决数据库的脏读、不可重复读、幻读等问题。 

![1631760013652](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/104026-432676.png)

> MySQL的默认隔离级别是可重复读。 

#### 隔离级别是如何实现的？

事务的隔离机制主要是依靠锁机制和MVCC(多版本并发控制)实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。

#### 什么是MVCC

MVCC(multiple version concurrent control)是一种控制并发的方法，主要用来提高数据库的并发性能。

在了解MVCC时应该先了解当前读和快照读。

- 当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对读取的记录加锁。

- 快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。  

可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。 

**MVCC的实现原理：**

- 版本号
  - 系统版本号：是一个自增的ID，每开启一个事务，系统版本号都会递增。
  - 事务版本号：事务版本号就是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时间顺序。

- 行记录隐藏的列
  - DB_ROW_ID：所需空间6byte，隐含的自增ID，用来生成聚簇索引，如果数据表没有指定聚簇索引，InnoDB会利用这个隐藏ID创建聚簇索引。
  - DB_TRX_ID：所需空间6byte，最近修改的事务ID，记录创建这条记录或最后一次修改这条记录的事务ID。
  - DB_ROLL_PTR：所需空间7byte，回滚指针，指向这条记录的上一个版本。

它们大致长这样，省略了具体字段的值。 

![1631766785769](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/123308-756365.png)



- undo日志
  - MVCC使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。它们大致长这样。 

![1631766852666](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/123415-295865.png)

举一个简单的例子说明下，比如最开始的某条记录长这样 

![1631766895125](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631766895125.png)

现在来了一个事务对他的年龄字段进行了修改，变成了这样 

![1631766934174](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/123537-241262.png)

现在又来了一个事务2对它的性别进行了修改，它又变成了这样

![1631766991560](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631766991560.png)

从上面的分析可以看出，事务对同一记录的修改，记录的各个会在Undo日志中连接成一个线性表，在表头的就是最新的旧纪录。

在重复读的隔离级别下，InnoDB的工作流程： 

**SELECT**
作为查询的结果要满足两个条件：

1. 当前事务所要查询的数据行快照的创建版本号必须小于当前事务的版本号，这样做的目的是保证当前事务读取的数据行的快照要么是在当前事务开始前就已经存在的，要么就是当前事务自身插入或者修改过的。
2. 当前事务所要读取的数据行快照的删除版本号必须是大于当前事务的版本号，如果是小于等于的话，表示该数据行快照已经被删除，不能读取。 

**INSERT**

1. 将当前系统版本号作为数据行快照的创建版本号。

**DELETE**

1. 将当前系统版本号作为数据行快照的删除版本号。

**UPDATE**

1. 保存当前系统版本号为更新前的数据行快照创建行版本号，并保存当前系统版本号为更新后的数据行快照的删除版本号，其实就是，先删除在插入即为更新。

总结一下，MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现提交读和可重复度两个隔离级 

### 数据库锁

#### 什么是数据库锁

当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。

  #### 数据库锁与隔离级别的关系

![1631760422588](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/104705-556986.png)

#### 数据库锁类型有哪些？

按照锁的粒度可以将MySQL锁分为三种： 

![1631760479883](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/104802-550350.png)

MyISAM默认采用**表级锁**，InnoDB默认采用**行级锁**。

从锁的类别上区别可以分为共享锁和排他锁

- 共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。

- 排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁 

![1631761336017](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/110219-912400.png)

#### MySQL中InnoDB引擎的行锁模式及其是如何实现的？ 

**行锁模式**
在存在行锁和表锁的情况下，一个事务想对某个表加X锁时，需要先检查是否有其他事务对这个表加了锁或对这个表的某一行加了锁，对表的每一行都进行检测一次这是非常低效率的，为了解决这种问题，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，两种意向锁都是表锁 。

- 意向共享锁：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。 
- 意向排他锁：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的IX锁。

有了意向锁，一个事务想对某个表加X锁，只需要检查是否有其他事务对这个表加了X/IX/S/IS锁即可。

**锁的兼容性如下：** 

![1631765862542](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1631765862542.png)

行锁实现方式：INnoDB的行锁是通过给索引上的索引项加锁实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录进行加锁。 

InnoDB行锁主要分三种情况：

- Record lock：对索引项加锁

- Grap lock：对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的间隙加锁。

- Next-key lock：前两种放入组合，对记录及前面的间隙加锁。

InnoDB行锁的特性：如果不通过索引条件检索数据，那么InnoDB将对表中所有记录加锁，实际产生的效果和表锁是一样的。

MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题 

#### 什么是数据库的乐观锁和悲观锁，如何实现？ 

- 乐观锁：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。
  - 乐观锁实现方式：一般通过版本号和CAS算法实现。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。
  - 悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata。 

#### 什么是死锁？如何避免？ 

死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。

如何避免MySQL发生死锁或锁冲突： 

- 如果不同的程序并发存取多个表，尽量以相同的顺序访问表。
- 在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。 
- 在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。 
- 尽量使用较低的隔离级别。
- 尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会
- 合理选择事务的大小，小事务发生锁冲突的概率更低
- 尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。
- 不要申请超过实际需要的锁级别，查询时尽量不要显示加锁
- 对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。 

### Sql基础

#### SQL语句主要分为哪几类 

1. 数据据定义语言DDL（Data Definition Language）：主要有CREATE，DROP，ALTER等对逻辑结构有操作的，包括表结构、视图和索引。

2. 数据库查询语言DQL（Data Query Language）：主要以SELECT为主

3. 数据操纵语言DML（Data Manipulation Language）：主要包括INSERT，UPDATE，DELETE

4. 数据控制功能DCL（Data Control Language）：主要是权限控制能操作，包括GRANT，REVOKE，COMMIT，ROLLBACK等。 

#### SQL约束有哪些

- 主键约束：主键为在表中存在一列或者多列的组合，能唯一标识表中的每一行。一个表只有一个主键，并且主键约束的列不能为空。

- 外键约束：外键约束是指用于在两个表之间建立关系，需要指定引用主表的哪一列。只有主表的主键可以被从表用作外键，被约束的从表的列可以不是主键，所以创建外键约束需要先定义主表的主键，然后定义从表的外键。

- 唯一约束：确保表中的一列数据没有相同的值，一个表可以定义多个唯一约束。

- 默认约束：在插入新数据时，如果该行没有指定数据，系统将默认值赋给该行，如果没有设置没默认值，则为NULL。

- Check约束：Check会通过逻辑表达式来判断数据的有效性，用来限制输入一列或者多列的值的范围。在列更新数据时，输入的内容必须满足Check约束的条件 

#### 什么是子查询

子查询：把一个查询的结果在另一个查询中使用。

子查询可以分为以下几类： 

- 标量子查询：指子查询返回的是一个值，可以使用 =,>,<,>=,<=,<>等操作符对子查询标量结果进行比较，一般子查询会放在比较式的右侧。 

~~~ sql
SELECT * FROM user WHERE age = (SELECT max(age) from user) //查询年纪最大的人
~~~

- 列子查询：指子查询的结果是n行一列，一般应用于对表的某个字段进行查询返回。可以使用IN、ANY、SOME和ALL等操作符，不能直接使用 

~~~sql 
SELECT num1 FROM table1 WHERE num1 > ANY (SELECT num2 FROM table2)
~~~

- 行子查询：指子查询返回的结果一行n列 

~~~ sql 
SELECT * FROM user WHERE (age,sex) = (SELECT age,sex FROM user WHERE name="zhangsan")
~~~

- 表子查询：指子查询是n行n列的一个数据表 

~~~ sql
SELECT * FROM student WHERE (name,age,sex) IN (SELECT name,age,sex FROM class1) --在学生表中找到班级在1班的学生
~~~

#### 了解MySQL的几种连接查询吗？ 

MySQl的连接查询主要可以分为外连接，内连接，交叉连接 

**外连接**

- 外连接主要分为左外连接(LEFT JOIN)、右外连接(RIGHT JOIN)、全外连接。
- 左外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。 

![1631770721000](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/133844-129480.png)

- 右外连接：显示左表中所有的数据及右表中符合条件的数据，右表中不符合条件的数据为null。

![1631770758813](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/133921-621905.png)

> MySQL中不支持全外连接。 

- 内连接：只显示符合条件的数据 

![1631770802566](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134004-950015.png)

- 交叉连接：使用笛卡尔积的一种连接。

  笛卡尔积，百度百科的解释：两个集合X和Y的笛卡尔积表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员 。例如：`A={a,b}，B={0,1,2}，A × B = {(a,0)，(a,1)，(a,2)，(b,0)，(b,1)，(b,2)} `

**举例如下：有两张表分为L表和R表。 **

![1631770886115](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134129-364648.png)

左外连接 ： select L.`*`,R.`*` from L left join R on L.b=R.b 

![1631770941267](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134237-74660.png)

右外连接： select L.`*`,R.`*` from L right join R on L.b=R.b 

![1631770987482](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134309-60073.png)

内连接： select L.`*`,R.`*` from L inner join R on L.b=R.b 

![1631771057312](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134420-270738.png)

交叉连接： select L.`*`,R.`*` from L,R 

![1631771090537](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/134453-312816.png)

#### mysql中in和exists的区别？ 

in和exists一般用于子查询。

- 使用exists时会先进行外表查询，将查询到的每行数据带入到内表查询中看是否满足条件；使用in一般会先进行内表查询获取结果集，然后对外表查询匹配结果集，返回数据。
- in在内表查询或者外表查询过程中都会用到索引。
- exists仅在内表查询时会用到索引
- 一般来说，当子查询的结果集比较大，外表较小使用exist效率更高；当子查询寻得结果集较小，外表较大时，使用in效率更高。

- 对于not in和not exists，not exists效率比not in的效率高，与子查询的结果集无关，因为not in对于内外表都进行了全表扫描，没有使用到索引。not exists的子查询中可以用到表上的索引。 

#### varchar和char的区别？ 

- varchar表示变长，char表示长度固定。当所插入的字符超过他们的长度时，在严格模式下，会拒绝插入并提示错误信息，在一般模式下，会截取后插入。如char(5)，无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则用空格补充。对于varchar(5)，如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，不会填充。 
- 存储容量不同，对于char来说，最多能存放的字符个数为255。对于varchar，最多能存放的字符个数是65532。
- 存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。 

#### MySQL中int(10)和char(10)和varchar(10)的区别？ 

int(10)中的10表示的是显示数据的长度，而char(10)和varchar(10)表示的是存储数据的大小。 

#### drop、delete和truncate的区别？  

![1631771405632](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/135008-639495.png)

> 一般来讲，删除整个表，使用drop，删除表的部分数据使用delete，保留表结构删除表的全部数据使用truncate 

#### UNION和UNION ALL的区别？ 

union和union all的作用都是将两个结果集合并到一起。

- union会对结果去重并排序，union all直接直接返回合并后的结果，不去重也不进行排序。
- union all的性能比union性能好。 

#### 什么是临时表，什么时候会使用到临时表，什么时候删除临时表？ 

MySQL在执行SQL语句的时候会临时创建一些存储中间结果集的表，这种表被称为临时表，临时表只对当前连接可见，在连接关闭后，临时表会被删除并释放空间。

临时表主要分为内存临时表和磁盘临时表两种。内存临时表使用的是MEMORY存储引擎，磁盘临时表使用的是MyISAM存储引擎。

一般在以下几种情况中会使用到临时表：

1. FROM中的子查询

2. DISTINCT查询并加上ORDER BY

3. ORDER BY和GROUP BY的子句不一样时会产生临时表

4. 使用UNION查询会产生临时表 

#### 大表数据查询如何进行优化？ 

1. 索引优化
2. SQL语句优化
3. 水平拆分
4. 垂直拆分
5. 建立中间表 
6. 使用缓存技术
7. 固定长度的表访问起来更快
8. 越小的列访问越快 

#### 了解慢日志查询吗？统计过慢查询吗？对慢查询如何优化？ 

慢查询一般用于记录执行时间超过某个临界值的SQL语句的日志。

**相关参数：**

- slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。
- slow_query_log_file：MySQL数据库慢查询日志存储路径。
- long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。
- log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。
- log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE”表示将日志存入数据库。

**如何对慢查询进行优化？**

- 分析语句的执行计划，查看SQL语句的索引是否命中
- 优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。
- 优化LIMIT分页。 

#### 为什么要设置主键？

主键是唯一区分表中每一行的唯一标识，如果没有主键，更新或者删除表中特定的行会很困难，因为不能唯一准确地标识某一行。 

##### 主键一般用自增ID还是UUID？ 

**使用自增ID的好处：**

1. 字段长度较uuid会小很多。
2. 数据库自动编号，按顺序存放，利于检索
3. 无需担心主键重复问题 

**使用自增ID的缺点：**

1. 因为是自增，在某些业务场景下，容易被其他人查到业务量。
2. 发生数据迁移时，或者表合并时会非常麻烦
3. 在高并发的场景下，竞争自增锁会降低数据库的吞吐能力 

UUID：通用唯一标识码，UUID是基于当前时间、计数器和硬件标识等数据计算生成的。

**使用UUID的优点：**

1. 唯一标识，不会考虑重复问题，在数据拆分、合并时也能达到全局的唯一性。
2. 可以在应用层生成，提高数据库的吞吐能力。
3. 无需担心业务量泄露的问题。

**使用UUID的缺点：**

1. 因为UUID是随机生成的，所以会发生随机IO，影响插入速度，并且会造成硬盘的使用率较低。
2. UUID占用空间较大，建立的索引越多，造成的影响越大。
3. UUID之间比较大小较自增ID慢不少，影响查询速度。 

最后说下结论，一般情况MySQL推荐使用自增ID。因为在MySQL的InnoDB存储引擎中，主键索引是一种聚簇索引，主键索引的B+树的叶子节点按照顺

序存储了主键值及数据，如果主键索引是自增ID，只需要按顺序往后排列即可，如果是UUID，ID是随机生成的，在数据插入时会造成大量的数据移

动，产生大量的内存碎片，造成插入性能的下降。 

#### 字段为什么要设置成not null? 

首先说一点，NULL和空值是不一样的，空值是不占用空间的，而NULL是占用空间的，所以字段设为NOT NULL后仍然可以插入空值。

字段设置成not null主要有以下几点原因： 

1. NULL值会影响一些函数的统计，如count，遇到NULL值，这条记录不会统计在内。 
2. B树不存储NULL，所以索引用不到NULL，会造成第一点中说的统计不到的问题 
3. NOT IN子查询在有NULL值的情况下返回的结果都是空值。 

例如user表如下 ：

![1631772205116](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/140348-975886.png)

~~~ sql
select * from `user` where username NOT IN (select username from `user` where id != 0) ，
--这条查询语句应该查到zhangsan这条数据，但是结果显示为null。
~~~

MySQL在进行比较的时候，NULL会参与字段的比较，因为NULL是一种比较特殊的数据类型，数据库在处理时需要进行特数处理，增加了数据库处理记录的复杂性。 

#### 如何优化查询过程中的数据访问？ 

从减少数据访问方面考虑：

- 正确使用索引，尽量做到索引覆盖
- 优化SQL执行计划

从返回更少的数据方面考虑：

- 数据分页处理
- 只返回需要的字段

从减少服务器CPU开销方面考虑：

- 合理使用排序
- 减少比较的操作
- 复杂运算在客户端处理

从增加资源方面考虑：

- 客户端多进程并行访问
- 数据库并行处理 

#### 如何优化长难的查询语句？ 

- 将一个大的查询分解为多个小的查询
- 分解关联查询，使缓存的效率更高 

#### 如何优化LIMIT分页？ 

- 在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大ID，下次查询时可以利用ID进行查询
- 建立复合索引 

#### 如何优化UNION查询 

- 如果不需要对结果集进行去重或者排序建议使用UNION ALL，会好一些。 

#### 如何优化WHERE子句 

1. 不要在where子句中使用!=和<>进行不等于判断，这样会导致放弃索引进行全表扫描。
2. 不要在where子句中使用null或空值判断，尽量设置字段为not null。
3. 尽量使用union all代替or
4. 在where和order by涉及的列建立索引
5. 尽量减少使用in或者not in，会进行全表扫描
6. 在where子句中使用参数会导致全表扫描
7. 避免在where子句中对字段及进行表达式或者函数操作会导致存储引擎放弃索引进而全表扫描 

#### SQL语句执行的很慢原因是什么？ 

1. 如果SQL语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是redo log日志写满了，要将redo log中的数据同步到磁盘中去。
2. 如果SQL语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。 

#### SQL语句的执行顺序?  

~~~ sql
SELECT DISTINCT
	select_list
FROM
	left_table
LEFT JOIN
	right_table ON join_condition
WHERE
	where_condition
GROUP BY
	group_by_list
HAVING
	having_condition
ORDER BY
	order_by_condition
~~~

执行顺序如下：

![1631772654483](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/141057-986872.png)

1. FROM：对SQL语句执行查询时，首先对关键字两边的表以笛卡尔积的形式执行连接，并产生一个虚表V1。虚表就是视图，数据会来自多张表的执行结果。
2. ON：对FROM连接的结果进行ON过滤,并创建虚表V2
3. JOIN：将ON过滤后的左表添加进来，并创建新的虚拟表V3
4. WHERE：对虚拟表V3进行WHERE筛选，创建虚拟表V4
5. GROUP BY：对V4中的记录进行分组操作，创建虚拟表V5
6. HAVING：对V5进行过滤，创建虚拟表V6
7. SELECT：将V6中的结果按照SELECT进行筛选，创建虚拟表V7
8. DISTINCT：对V7表中的结果进行去重操作，创建虚拟表V8，如果使用了GROUP BY子句则无需使用DISTINCT，因为分组的时候是将列中唯一的值分成一组，并且每组只返回一行记录，所以所有的记录都h是不同的。
9. ORDER BY：对V8表中的结果进行排序。 

### 数据库优化

#### 大表如何优化？

1. 限定数据的范围：避免不带任何限制数据范围条件的查询语句。
2. 读写分离：主库负责写，从库负责读。
3. 垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。
4. 水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。
5. 对单表进行优化：对表中的字段、索引、查询SQL进行优化。
6. 添加缓存 

#### 什么是垂直分表、垂直分库、水平分表、水平分库？ 

**垂直分表：**

将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。

垂直分表的优势： 

- 避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。
- 可以更好地提升热门数据的查询效率 

**垂直分库：**

按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。

垂直分库的优势：

- 降低业务中的耦合，方便对不同的业务进行分级管理。
- 可以提升IO、数据库连接数、解决单机硬件资源的瓶颈问题 

**垂直拆分（分库、分表）的缺点：**

- 主键出现冗余，需要管理冗余列
- 事务的处理变得复杂
- 仍然存在单表数据量过大的问题 

**水平分表：**

- 在同一个数据库内，把同一个表的数据按照一定规则拆分到多个表中。

水平分表的优势：

- 解决了单表数据量过大的问题

- 避免IO竞争并减少锁表的概率


**水平分库：**

- 把同一个表的数据按照一定规则拆分到不同的数据库中，不同的数据库可以放到不同的服务器上 

**水平分库的优势：**

- 解决了单库大数据量的瓶颈问题
- IO冲突减少，锁的竞争减少，某个数据库出现问题不影响其他数据库（可用性），提高了系统的稳
  定性和可用性

**水平拆分（分表、分库）的缺点：**

- 分片事务一致性难以解决
- 跨节点JOIN性能差，逻辑会变得复杂
- 数据扩展难度大，不易维护 

在系统设计时应根据业务耦合来确定垂直分库和垂直分表的方案，在数据访问压力不是特别大时应考虑缓存、读写分离等方法，若数据量很大，或持续增长可考虑水平分库分表，水平拆分所涉及的逻辑比较复杂，常见的方案有客户端架构和恶代理架构。 

#### 分库分表后，ID键如何处理？ 

分库分表后不能每个表的ID都是从1开始，所以需要一个全局ID，设置全局ID主要有以下几种方法： 

- UUID：优点：本地生成ID，不需要远程调用；全局唯一不重复。缺点：占用空间大，不适合作为索引。
- 数据库自增ID：在分库分表表后使用数据库自增ID，需要一个专门用于生成主键的库，每次服务接收到请求，先向这个库中插入一条没有意义的数据，获取一个数据库自增的ID，利用这个ID去分库分表中写数据。优点：简单易实现。缺点：在高并发下存在瓶颈。系统结构如下图（图片来源于网络） 

![1631773359001](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/142306-337629.png)

- Redis生成ID：优点：不依赖数据库，性能比较好。缺点：引入新的组件会使得系统复杂度增加 
- Twitter的snowflake算法：是一个64位的long型的ID，其中有1bit是不用的，41bit作为毫秒数，
  - 10bit作为工作机器ID，12bit作为序列号。
  - 1bit：第一个bit默认为0，因为二进制中第一个bit为1的话为负数，但是ID不能为负数.
  - 41bit：表示的是时间戳，单位是毫秒。
  - 10bit：记录工作机器ID，其中5个bit表示机房ID，5个bit表示机器ID。
  - 12bit：用来记录同一毫秒内产生的不同ID。 
- 美团的Leaf分布式ID生成系统 ：[美团点评分布式ID生成系统 ]([Leaf——美团点评分布式ID生成系统 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2017/04/21/mt-leaf.html))

#### MySQL的复制原理及流程？如何实现主从复制？ 

MySQL复制：为保证主服务器和从服务器的数据一致性，在向主服务器插入数据后，从服务器会自动将主服务器中修改的数据同步过来。
主从复制的原理：

主从复制主要有三个线程：binlog线程，I/O线程，SQL线程。

- binlog线程：负责将主服务器上的数据更改写入到二进制日志（Binary log）中。
- I/O线程：负责从主服务器上读取二进制日志（Binary log），并写入从服务器的中继日志（Relaylog）中。
- SQL线程：负责读取中继日志，解析出主服务器中已经执行的数据更改并在从服务器中重放

复制过程如下（图片来源于网络）： 

![1631773590615](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/142632-32820.png)

1. Master在每个事务更新数据完成之前，将操作记录写入到binlog中。

2. Slave从库连接Master主库，并且Master有多少个Slave就会创建多少个binlog dump线程。当Master节点的binlog发生变化时，binlog dump会通知所有的Slave，并将相应的binlog发送给Slave。
3. I/O线程接收到binlog内容后，将其写入到中继日志（Relay log）中。
4. SQL线程读取中继日志，并在从服务器中重放。 

**补充图**

![1631773727821](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/142851-785544.png)

**主从复制的作用：**

1. 高可用和故障转移
2. 负载均衡
3. 数据备份
4. 升级测试 

#### 了解读写分离吗？ 

读写分离主要依赖于主从复制，主从复制为读写分离服务。

读写分离的优势：

- 主服务器负责写，从服务器负责读，缓解了锁的竞争
- 从服务器可以使用MyISAM，提升查询性能及节约系统开销
- 增加冗余，提高可用性 

## 网络

### 什么是网络协议，为什么要对网络协议分层 

网络协议是计算机在通信过程中要遵循的一些约定好的规则。

网络分层的原因：

- 易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。
- 有利于标准化的制定 

### 计算机网络的各层协议及作用  

> 计算机网络体系可以大致分为一下三种，七层模型、五层模型和TCP/IP四层模型，一般面试能流畅回答出五层模型就可以了，表示层和会话层被问到的不多。 

![1631774040923](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/143403-116784.png)

**应用层**

- 应用层的任务是通过应用进程之间的交互来完成特定的网络作用，常见的应用层协议有域名系统DNS，HTTP协议等。

**表示层**

- 表示层的主要作用是数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

**会话层**

- 会话层的主要作用是建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。

**传输层**

- 传输层的主要作用是负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议TCP和用户数据协议UDP。

**网络层**

- 网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。

**数据链路层**

- 数据链路层的作用是在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。 常见的协议有SDLC、HDLC、PPP等。

**物理层**

- 物理层的主要作用是实现相邻计算机结点之间比特流的透明传输，并尽量屏蔽掉具体传输介质和物理设备的差异。 

### URI和URL的区别 

- URI(Uniform Resource Identifier)：中文全称为统一资源标志符，主要作用是唯一标识一个资源。
- URL(Uniform Resource Location)：中文全称为统一资源定位符，主要作用是提供资源的路径。

> 有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人 

### DNS的工作流程 

DNS的定义：DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。比如大家访问百度，更多地肯定是访问`www.baidu.com`，而不是访问112.80.248.74，因为这几乎无规则的IP地址实在太难记了。DNS要做的就是将`www.baidu.com`解析成112.80.248.74。 

**DNS是集群式的工作方式还是 单点式的，为什么？ **

是集群式的，是一个分布式的数据库系统，很容易想到的一个方案就是只用一个DNS服务器，包含了所有域名和IP地址的映射。尽管这种设计方式看起

来很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，DNS系统采用的是

分布式的层次数据数据库模式，还有缓存的机制也能解决这种问题。 

**DNS的工作流程 **

主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。递归查询主机向本地域名发送查询请求报

文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。迭

代查询是，本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名

发送查询请求报文。

> 简单来说，递归查询就是，小明问了小红一个问题，小红不知道，但小红是个热心肠，小红就去问小王了，小王把答案告诉小红后，小红又去把答案告诉了小明。迭代查询就是，小明问了小红一个问题，小红也不知道，然后小红让小明去问小王，小明又去问小王了，小王把答案告诉了小明。 

**小结：**

1. 在浏览器中输入`www.baidu.com`域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

2. 如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析。
3. 如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。
4. 如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器。
5. 本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器。
6. 本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器`www.baidu.com`所对应的IP地址。
7. 本地域名服务器告诉主机`www.baidu.com`所对应的IP地址。 

### 了解ARP协议吗? 

ARP协议属于网络层的协议，主要作用是实现从IP地址转换为MAC地址。在每个主机或者路由器中都建有一个ARP缓存表，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。

- IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
- MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。 

数据在传输过程中，会先从高层传到底层，然后在通信链路上传输。从下图可以看到TCP报文在网络层会被封装成IP数据报，在数据链路层被封装成MAC帧，然后在通信链路中传输。在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。MAC帧在传送时的源地址和目的地址使用的都是MAC地址，在通信链路上的主机或路由器也都是根据MAC帧首部的MAC地址接收MAC帧。并且在数据链路层是看不到IP地址的，只有当数据传到网络层时去掉MAC帧的首部和尾部时才能在IP数据报的首部中找到源IP地址和目的地址。 

![1631774611402](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/144334-802940.png)

网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变 。

![1631774655585](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/144436-3994.png)

ARP的工作流程(面试时问ARP协议主要说这个就可以了)：
1. 在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。
2. 如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。
3. 主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。
4. 主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。
5. 如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。
6. 如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路 。

### 有了IP地址，为什么还要用MAC地址？ 

- 简单来说，标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但计算机的IP地址可由用户自行更改，管理起来相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。具体是如何组合使用的在上面的ARP协议中已经讲的很清楚了。

- 那只用MAC地址不用IP地址可不可以呢？其实也是不行的，因为在最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可，这个过程就是上面说的ARP协议。

- 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地 址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。

- IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。 
- 在通信过程中，ip地址封装在帧中，是无法看到ip地址的，所以需要根据mac地址进行转发。

### 说一下ping的过程 

ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。

ping的工作过程：

1. 向目的主机发送多个ICMP回送请求报文
2. 根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。 

### 路由器和交换机的区别？ 

![1631774959914](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/144921-788749.png)

### TCP与UDP有什么区别 

![1631774988603](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/144950-319839.png)

TCP首部(图片来源于网络)：

- 前20个字节是固定的，后面有4n个字节是根据需而增加的选项，所以TCP首部最小长度为20字节。 

![1631775029831](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/145031-494243.png)

UDP首部(图片来源于网络)：

- UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节。 

![1631775057533](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/145059-437600.png)

### TCP协议如何保证可靠传输 

> 主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法 

- 校验和：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。
- 序列号：TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。

![1631775310795](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/145512-63465.png)

- 超时重传：在上面说了序列号的作用，但如果发送方在发送数据后一段时间内（可以设置重传计时器规定这段时间）没有收到确认序号ACK，那么发送方就会重新发送数据。
  - 这里发送方没有收到ACK可以分两种情况，如果是发送方发送的数据包丢失了，接收方收到发送方重新发送的数据包后会马上给发送方发送ACK；如果是接收方之前接收到了发送方发送的数据包，而返回给发送方的ACK丢失了，这种情况，发送方重传后，接收方会直接丢弃发送重传的数据包，然后再次发送ACK响应报文。
  - 如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。 
- 流量控制：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗
  口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。 
- 拥塞控制：如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复，如下图(图片来源于网络) 

![1631775419280](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/145700-721708.png)

这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。
1. 慢开始：为了避免一开始发送大量的数据而产生网络阻塞，会先初始化cwnd为1，当收到ACK后到下一个传输轮次，cwnd为2，以此类推成指数形式增长。
2. 拥塞避免：因为cwnd的数量在慢开始是指数增长的，为了防止cwnd数量过大而导致网络阻塞，会设置一个慢开始的门限值ssthresh，当cwnd>=ssthresh时，进入到拥塞避免阶段，cwnd每个传输轮次加1。但网络出现超时，会将门限值ssthresh变为出现超时cwnd数值的一半，cwnd重新设置为1，如上图，在第12轮出现超时后，cwnd变为1，ssthresh变为12。
3. 快重传：在网络中如果出现超时或者阻塞，则按慢开始和拥塞避免算法进行调整。但如果只是丢失某一个报文段，如下图(图片来源于网络)，则使用快重传算法。 

![1631775482017](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/145803-732452.png)

从上图可知，接收方正确地接收到M1和M2，而M3丢失，由于没有接收到M3，在接收方收到M5、M6和M7时，并不会进行确认，也就是不会发送ACK。这时根据前面说的保证TCP可靠性传输中的序列号的作用，接收方这时不会接收M5，M6，M7，接收方可以什么都不会，因为发送方长时间未收到M3的确认报文，会对M3进行重传。除了这样，接收方也可以重复发送M2的确认报文，这样发送端长时间未收到M3的确认报文也会继续发送M3报文。但是根据快重传算法，要求在这种情况下，需要快速向发送端发送M2的确认报文，在发送方收到三个M2的确认报文后，无需等待重传计时器所设置的时间，可直接进行M3的重传，这就是快重传。(面试时说这一句就够了，前面是帮助理解)
4. 快恢复：从上上图圈4可以看到，当发送收到三个重复的ACK，会进行快重传和快恢复。快恢复是指将ssthresh设置为发生快重传时的cwnd数量的一半，而cwnd不是设置为1而是设置为为门限值ssthresh，并开始拥塞避免阶段。 

### TCP的三次握手及四次挥手 

在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。

- 序号：seq，占32位，用来标识从发送端到接收端发送的字节流。
- 确认号：ack，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

**标志位：**

- SYN：发起一个新连接。
- FIN：释放一个连接。
- ACK：确认序号有效。 

#### 三次握手

三次握手的本质就是确定发送端和接收端具备收发信息的能力，在能流畅描述三次握手的流程及其中的字段含义作用的同时还需要记住每次握手时接收端和发送端的状态。这个比较容易忽略。 

先看一张很经典的图（图片来源于网络），发送端有CLOSED、SYN-SENT、ESTABLISHED三种状态，接收端有CLOSED、LISTEN、SYN-RCVD、ESTABLISHED四种状态。 

![1631775740170](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/150221-102001.png)

假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是CLOSE。

- 第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，客户端向服务端发送的字段中包含标志位SYN=1，序列号seq=100。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT。此时服务端的状态为LISTEN
- 第二次握手：服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT。（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）
- 第三次握手：客户端收到服务端发来的报文后，会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1。第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。 

> 需要注意的一点是，第一次握手，客户端向服务端发起建立连接报文，会占一个序列号。但是第三次握手，同样是客户端向服务端发送报文，这次却不占序列号，所以建立连接后，客户端向服务端发送的第一个数据的序列号为x+1。 

#### 四次挥手

和三次握手一样，先看一张非常经典的图（图片来源于网络），客户端在四次挥手过程中有ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSED等五个状态，服务端有ESTABLISHED、CLOSE-WAIT、LAST-ACK、CLOSED等四种状态。最好记住每次挥手时服务端和客户端的状态。 

![1631778996334](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/155637-840984.png)

假设客户端首先发起的断开连接请求

- 第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN=1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。
- 第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1。此时客户端到服务端的连接已经释放掉，客户端不能像服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。
- 第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。
- 第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。 

#### 为什么TCP连接的时候是3次？两次是否可以？ 

不可以，主要从以下两方面考虑（假设客户端是首先发起连接请求）：
1. 假设建立TCP连接仅需要两次握手，那么如果第二次握手时，服务端返回给客户端的确认报文丢失了，客户端这边认为服务端没有和他建立连接，而服务端却以为已经和客户端建立了连接，并且可能向服务端已经开始向客户端发送数据，但客户端并不会接收这些数据，浪费了资源。如果是三次握手，不会出现双方连接还未完全建立成功就开始发送数据的情况。
2. 如果服务端接收到了一个早已失效的来自客户端的连接请求报文，会向客户端发送确认报文同意建立TCP连接。但因为客户端并不需要向服务端发送数据，所以此次TCP连接没有意义并且浪费了资源。 

#### 为什么TCP连接的时候是3次，关闭的时候却是4次？ 

因为需要确保通信双方都能通知对方释放连接，假设客服端发送完数据向服务端发送释放连接请求，当客服端并不知道，服务端是否已经发送完数据，所以此次断开的是客服端到服务端的单向连接，服务端返回给客户端确认报文后，服务端还能继续单向给客户端发送数据。当服务端发送完数据后还需要向客户端发送释放连接请求，客户端返回确认报文，TCP连接彻底关闭。所以断开TCP连接需要客户端和服务端分别通知对方并分别收到确认报文，一共需要四次。 

#### TIME_WAIT和CLOSE_WAIT的区别在哪? 

默认客户端首先发起断开连接请求

- 从上图可以看出，CLOSE_WAIT是被动关闭形成的，当客户端发送FIN报文，服务端返回ACK报文后进入CLOSE_WAIT。
- TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。 

#### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？ 

MSL的意思是报文的最长寿命，可以从两方面考虑：
1. 客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
2. 考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。 

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？ 

- 如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。
- 保活机制原理：设置TCP保活机制的保活时间keepIdle，即在TCP链接超过该时间没有任何数据交互时，发送保活探测报文；设置保活探测报文的发送时间间隔keepInterval；设置保活探测报文的总发送次数keepCount。如果在keepCount次的保活探测报文均没有收到客户端的回应，则服务器端即关闭与客户端的TCP链接。 

[TCP通信过程中异常情况整理]([TCP通信过程中异常情况整理_YYC的专栏-CSDN博客_tcp异常](https://blog.csdn.net/yyc1023/article/details/80242815))

### HTTP 与 HTTPS 的区别 

![1631779267626](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/160110-8605.png)

### 什么是对称加密与非对称加密 

**对称加密**
对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有DES、AES等等。

**非对称加密**
非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA、ECC等等。

非对称加密的工作流程：A生成一对非堆成密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。 

### HTTPS的加密过程 

上面已经介绍了对称加密和非对称加密的优缺点，HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密算法。具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。

简化的工作流程：服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。通信双方就可以通过对称密钥进行高效地通信了。

但是仔细想想这其中存在一个很大地问题，就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？

这就需要证书上场了，服务端会向一个权威机构申请一个证书来证明自己的身份，到时候将证书（证书中包含了公钥）发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。 

HTTPS的加密过程：
1. 客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客服端。
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。
6. 服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。
7. 通信双方可用对称密钥来加密解密信息。

上述流程存在的一个问题是客户端哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。

**流程图如下：**

![1631779443660](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/160404-448223.png)

### 常用HTTP状态码 

![1631779477806](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/160440-642074.png)

常见的HTTP状态码:
**1XX**

- 100 Continue：表示正常，客户端可以继续发送请求
- 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。

**2XX**

- 200 OK：请求成功
- 201 Created：已创建，表示成功请求并创建了新的资源
- 202 Accepted：已接受，已接受请求，但未处理完成。
- 204 No Content：无内容，服务器成功处理，但未返回内容。
- 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。 
- 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容 

**3XX**

- zy Moved Permanently：永久性重定向
- 302 Found：临时重定向
- 303 See Other：和zy功能类似，但要求客户端采用get方法获取资源
- 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
- 305 Use Proxy：所请求的资源必须通过代理访问
- 307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。

**4XX**

- 400 Bad Request：客户端请求的语法错误，服务器无法理解。
- 401 Unauthorized：表示发送的请求需要有认证信息。
- 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求
- 404 Not Found：服务器无法根据客户端的请求找到资源。
- 405 Method Not Allowed：客户端请求中的方法被禁止
- 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求
- 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时

**5XX**

- 500 Internal Server Error：服务器内部错误，无法完成请求
- 501 Not Implemented：服务器不支持请求的功能，无法完成请求 

### 常见的HTTP方法 

![1631779657740](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/160739-863031.png)

为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。

- PUT：上传文件，向服务器添加数据，可以看作增
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源 

### GET和POST区别 

作用

- GET用于获取资源，POST用于传输实体主体

参数位置

- GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。

安全性

- GET方法因为参数放在URL中，安全性相对于POST较差一些

幂等性

- GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的. 

### HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么 

**HTTP 1.0和HTTP 1.1的区别**

- 长连接
  - HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，
  - HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。

- 缓存处理
  - 在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，
  - HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。

- 错误状态码
  - 在HTTP 1.1新增了24个错误状态响应码

- HOST域
  - 在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。

- 带宽优化及网络连接的使用
- 在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。
- 在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。

**HTTP 2.0的新特性**

- 新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。
- 多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。
- header压缩：在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。
- 服务端推送：客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。 

### Session、Cookie和Token的主要区别 

HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。 

**Cookie**
Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。 

**Session**
Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。 

**Token**
客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。看到这里很多人感觉这不是和sessionid作用一样吗？其实是不一样的，但是本文章主要针对面试，知识点很多，篇幅有限，几句话也解释不清楚，大家可以看看这篇文章，我觉得说的非常清楚了。 

[cookie、session与token的真正区别]([cookie、session与token的真正区别_一个假的程序员-CSDN博客_session和token的区别](https://blog.csdn.net/whl190412/article/details/90024671))

**小结：**

![1631780077302](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202109/16/161439-896816.png)

### 如果客户端禁止 cookie 能实现 session 还能用吗？ 

可以，Session的作用是在服务端来保持状态，通过sessionid来进行确认身份，但sessionid一般是通过Cookie来进行传递的。如果Cooike被禁用了，可以通过在URL中传递sessionid。 

### 在浏览器中输⼊url地址到显示主⻚的过程 

> 面试超高频的一道题，一般能说清楚流程就可以。

1. 对输入到浏览器的url进行DNS解析，将域名转换为IP地址。
2. 和目的服务器建立TCP连接
3. 向目的服务器发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析并渲染页面 

### Servlet是线程安全的吗 

Servlet不是线程安全的，多线程的读写会导致数据不同步的问题 