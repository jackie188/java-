# 数据与预处理和特征选择

## 数据挖掘的五大流程

### 获取数据

获取原始数据

### 数据预处理

数据预处理是从数据中检测，纠正或删除损坏，不准确或不适用于模型的记录的过程，可能面对的问题有：数据类型不同，比如有的是文字，有的是数字，有的含时间序列，有的连续，有的间断。也可能，数据的质量不行，有噪声，有异常，有缺失，数据出错，量纲不一，有重复，数据是偏态，数据量太大或太小

数据预处理的目的：让数据适应模型，匹配模型的需求

### 特征工程

特征工程是将原始数据转换为更能代表预测模型的潜在问题的特征的过程，可以通过挑选最相关的特征，提取特征以及创造特征来实现。其中创造特征又经常以降维算法的方式实现。

可能面对的问题有：特征之间有相关性，特征和标签无关，特征太多或太小，或者干脆就无法表现出应有的数据现象或无法展示数据的真实面貌

特征工程的目的：

1. 降低计算成本
2. 提升模型上限

### 建模

建模，测试模型并预测出结果

### 上线

上线，验证模型效果

## sklearn中的数据预处理和特征工程

sklearn中包含众多数据预处理和特征工程相关的模块，虽然刚接触sklearn时，大家都会为其中包含的各种算法的广度深度所震惊，但其实sklearn六大板块中有两块都是关于数据预处理和特征工程的，两个板块互相交互，为建模之前的全部工程打下基础。

![1632990417135](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1632990417135.png)

- 模块preprocessing：几乎包含数据预处理的所有内容
- 模块Impute：填补缺失值专用
- 模块feature_selection：包含特征选择的各种方法的实践
- 模块decomposition：包含降维算法

## 数据预处理 Preprocessing & Impute

### 数据无量纲化

在机器学习算法实践中，我们往往有着将不同规格的数据转换到同一规格，或不同分布的数据转换到某个特定分布的需求，这种需求统称为将数据“无量纲化”。譬如梯度和矩阵为核心的算法中，譬如逻辑回归，支持向量机，神经网络，无量纲化可以加快求解速度；而在距离类模型，譬如K近邻，K-Means聚类中，无量纲化可以帮我们提升模型精度，避免某一个取值范围特别大的特征对距离计算造成影响。（**一个特例是决策树和树的集成算法们，对决策树我们不需要无量纲化，决策树可以把任意数据都处理得很好**。）

> 数据的无量纲化可以是线性的，也可以是非线性的。线性的无量纲化包括中心化（Zero-centered或者Meansubtraction）
> 处理和缩放处理（Scale）。中心化的本质是让所有记录减去一个固定值，即让数据样本数据平移到某个位置。缩放的本质是通过除以一个固定值，将数据固定在某个范围之中，取对数也算是一种缩放处理。

#### preprocessing.MinMaxScaler（归一化）

当数据(x)按照最小值中心化后，再按极差（最大值 - 最小值）缩放，数据移动了最小值个单位，并且会被收敛到[0,1]之间，而这个过程，就叫做数据归一化(Normalization，又称Min-Max Scaling)。注意，Normalization是归一化，不是正则化，真正的正则化是regularization，不是数据预处理的一种手段。归一化之后的数据服从正态分布，公式如下：

![1632990698911](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1632990698911.png)

在sklearn当中，我们使用preprocessing.MinMaxScaler来实现这个功能。MinMaxScaler有一个重要参数，feature_range，控制我们希望把数据压缩到的范围，默认是[0,1]。

**归一化案例**

~~~ python
# 导入归一化模块
from sklearn.preprocessing import MinMaxScaler
# 二维数组数据
data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]

# 放到表格中查看数据
import pandas as pd
pd.DataFrame(data)

# 数据归一化
#实现归一化
scaler = MinMaxScaler() #实例化模型
scaler = scaler.fit(data) #fit，在这里本质是生成min(x)和max(x)
result = scaler.transform(data) #通过接口导出结果
result
# 归一化后的结果
array([[0.  , 0.  ],
       [0.25, 0.25],
       [0.5 , 0.5 ],
       [1.  , 1.  ]])

# 使用接口一部实现归一化
# 也可以直接一步到位
result=scaler.fit_transform(data)
result

# 也可以将归一化后的数据进行逆转
# 将归一化后的矩阵进行逆转
scaler.inverse_transform(result)

# 将数据归一化到其他区间
#使用MinMaxScaler的参数feature_range实现将数据归一化到[0,1]以外的范围中
data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]
scaler = MinMaxScaler(feature_range=[5,10]) #依然实例化,但是归一化的范围是[5 10]
result = scaler.fit_transform(data) #fit_transform一步导出结果
result
#当X中的特征数量非常多的时候，fit会报错并表示，数据量太大了我计算不了
#此时使用partial_fit作为训练接口
#scaler = scaler.partial_fit(data)
~~~

#### preprocessing.StandardScaler（标准化）

> 标准化后数据服从正态分布

当数据(x)按均值(μ)中心化后，再按标准差(σ)缩放，数据就会服从为均值为0，方差为1的正态分布（即标准正态分布），而这个过程，就叫做数据标准化(Standardization，又称Z-score normalization)，公式如下：

![1632991005304](C:\Users\MrR\AppData\Roaming\Typora\typora-user-images\1632991005304.png)

**标准化案例**

~~~ python
# 导入标准化模块
# 标准化（服从标准正态分布）
from sklearn.preprocessing import StandardScaler
data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]
pd.DataFrame(data)

scaler = StandardScaler() #实例化
scaler.fit(data) #fit，本质是生成均值和方差

scaler.mean_ #查看均值的属性mean_

scaler.var_ #查看方差的属性var_

x_std = scaler.transform(data) #通过接口导出结果
# 输出标准化后的结果
x_std

array([[-1.18321596, -1.18321596],
       [-0.50709255, -0.50709255],
       [ 0.16903085,  0.16903085],
       [ 1.52127766,  1.52127766]])

scaler.fit_transform(data) #使用fit_transform(data)一步达成结果

# 标准化逆转
scaler.inverse_transform(x_std) #使用inverse_transform逆转标准化
~~~

对于StandardScaler和MinMaxScaler来说，空值NaN会被当做是缺失值，在fit的时候忽略，在transform的时候保持缺失NaN的状态显示。并且，尽管去量纲化过程不是具体的算法，但在fit接口中，依然只允许导入至少二维数组，一维数组导入会报错。通常来说，我们输入的X会是我们的特征矩阵，现实案例中特征矩阵不太可能是一维所以不会存在这个问题。

#### StandardScaler和MinMaxScaler选哪个？

看情况。大多数机器学习算法中，会选择StandardScaler来进行特征缩放，因为MinMaxScaler对异常值非常敏感。在PCA，聚类，逻辑回归，支持向量机，神经网络这些算法中，StandardScaler往往是最好的选择。

MinMaxScaler在不涉及距离度量、梯度、协方差计算以及数据需要被压缩到特定区间时使用广泛，比如数字图像处理中量化像素强度时，都会使用MinMaxScaler将数据压缩于[0,1]区间之中。

除了StandardScaler和MinMaxScaler之外，sklearn中也提供了各种其他缩放处理（中心化只需要一个pandas广播一下减去某个数就好了，因此sklearn不提供任何中心化功能）。比如，在希望压缩数据，却不影响数据的稀疏性时（不影响矩阵中取值为0的个数时），我们会使用MaxAbsScaler；在异常值多，噪声非常大时，我们可能会选用分位数来无量纲化，此时使用RobustScaler。更多详情请参考以下列表。

![1632991601123](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/135154-74453.png)

### 缺失值

机器学习和数据挖掘中所使用的数据，永远不可能是完美的。很多特征，对于分析和建模来说意义非凡，但对于实际收集数据的人却不是如此，因此数据挖掘之中，常常会有重要的字段缺失值很多，但又不能舍弃字段的情况。因此，数据预处理中非常重要的一项就是处理缺失值。

~~~ python
# 缺失值处理
import pandas as pd
data = pd.read_csv(r"C:\Users\MrR\Desktop\sklearn\菜菜的sklearn课堂课件\03数据预处理和特征工程\Narrativedata.csv",index_col=0)
data.head()
~~~

![1634373299497](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/163500-918518.png)

在这里，我们使用从泰坦尼克号提取出来的数据，这个数据有三个特征，一个数值型，两个字符型，标签也是字符型。

#### impute.SimpleImputer

~~~ python
class sklearn.impute.SimpleImputer (missing_values=nan, strategy=’mean’, fill_value=None, verbose=0,
copy=True)
~~~

在讲解随机森林的案例时，我们用这个类和随机森林回归填补了缺失值，对比了不同的缺失值填补方式对数据的影响。这个类是专门用来填补缺失值的。它包括四个重要参数：

![1634373109068](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/163150-562358.png)

~~~ python
#填补年龄
Age = data.loc[:,"Age"].values.reshape(-1,1) #sklearn当中特征矩阵必须是二维
# reshape(-1,1)将数据进行升维度
~~~

**填充年龄**

~~~ python
from sklearn.impute import SimpleImputer
imp_mean = SimpleImputer() #实例化，默认均值填补
imp_median = SimpleImputer(strategy="median") #用中位数填补
imp_0 = SimpleImputer(strategy="constant",fill_value=0) #用0填补

# 导出结果
imp_mean = imp_mean.fit_transform(Age) #fit_transform一步完成调取结果
imp_median = imp_median.fit_transform(Age)
imp_0 = imp_0.fit_transform(Age)
// 在这里我们使用中位数结果进行填充
#在这里我们使用中位数填补Age
data.loc[:,"Age"] = imp_median
data.info()
~~~

**使用众数填补Embarked**

~~~ python
#使用众数填补Embarked
Embarked = data.loc[:,"Embarked"].values.reshape(-1,1)
imp_mode = SimpleImputer(strategy = "most_frequent")
data.loc[:,"Embarked"] = imp_mode.fit_transform(Embarked)
data.info()
~~~

### 处理分类型特征：编码与哑变量

在机器学习中，大多数算法，譬如逻辑回归，支持向量机SVM，k近邻算法等都只能够处理数值型数据，不能处理文字，在sklearn当中，除了专用来处理文字的算法，其他算法在fit的时候全部要求输入数组或矩阵，也不能够导入文字型数据（其实手写决策树和普斯贝叶斯可以处理文字，但是sklearn中规定必须导入数值型）。

#### preprocessing.LabelEncoder

preprocessing.LabelEncoder：标签专用，能够将分类转换为分类数值

~~~ python
# LabelEncoder是标签专用的编码方式，所以可以导入一位数组
from sklearn.preprocessing import LabelEncoder
y = data.iloc[:,-1] #要输入的是标签，不是特征矩阵，所以允许一维
y # 二分类
le = LabelEncoder() #实例化，不仅可以处理二分类，还可以处理多分类
le = le.fit(y) #导入数据
label = le.transform(y) #transform接口调取结果

le.classes_ #属性.classes_查看标签中究竟有多少类别

label #查看获取的结果label

le.fit_transform(y) #也可以直接fit_transform一步到位

le.inverse_transform(label) #使用inverse_transform可以逆转

data.iloc[:,-1] = label #让标签等于我们运行出来的结果
data.head()
~~~

#### preprocessing.OrdinalEncoder

preprocessing.OrdinalEncoder：特征专用，能够将分类特征转换为分类数值

~~~ python
from sklearn.preprocessing import OrdinalEncoder
#接口categories_对应LabelEncoder的接口classes_，一模一样的功能
# OrdinalEncoder特征专用，所以不可以导入一维数组
data_ = data.copy()
data_.head()

OrdinalEncoder().fit(data_.iloc[:,1:-1]).categories_
# categories_可以查看每一个特征中有多少个类别
# [:,1:-1])取出所有行，然后取出从第一列开始的到最后一列，不包含最后一列
[array(['female', 'male'], dtype=object), array(['C', 'Q', 'S'], dtype=object)]
data_.iloc[:,1:-1] = OrdinalEncoder().fit_transform(data_.iloc[:,1:-1])
data_.head()
~~~

#### preprocessing.OneHotEncoder

preprocessing.OneHotEncoder：独热编码，创建哑变量

类别OrdinalEncoder可以用来处理有序变量，但对于名义变量，我们只有使用哑变量的方式来处理，才能够尽量向算法传达最准确的信息：

![1634374299768](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/165140-693248.png)

这样的变化，让算法能够彻底领悟，原来三个取值是没有可计算性质的，是“有你就没有我”的不等概念。在我们的数据中，性别和舱门，都是这样的名义变量。因此我们需要使用独热编码，将两个特征都转换为哑变量。

~~~ python
from sklearn.preprocessing import OneHotEncoder

X = data.iloc[:,1:-1] # 获取需要编码的列数据
X

enc = OneHotEncoder(categories='auto').fit(X)
result = enc.transform(X).toarray()
# 两个特征一共有5个类别，所以有5个数
result
array([[0., 1., 0., 0., 1.],
       [1., 0., 1., 0., 0.],
       [1., 0., 0., 0., 1.],
       ...,
       [1., 0., 0., 0., 1.],
       [0., 1., 1., 0., 0.],
       [0., 1., 0., 1., 0.]])

#依然可以直接一步到位，但为了给大家展示模型属性，所以还是写成了三步
OneHotEncoder(categories='auto').fit_transform(X).toarray()
#依然可以还原
pd.DataFrame(enc.inverse_transform(result))

#依然可以直接一步到位，但为了给大家展示模型属性，所以还是写成了三步
OneHotEncoder(categories='auto').fit_transform(X).toarray()
#依然可以还原
pd.DataFrame(enc.inverse_transform(result))
array(['x0_female', 'x0_male', 'x1_C', 'x1_Q', 'x1_S'], dtype=object)

newdata.head()
newdata.drop(["Sex","Embarked"],axis=1,inplace=True)
newdata.columns =["Age","Survived","Female","Male","Embarked_C","Embarked_Q","Embarked_S"]
newdata.head()
~~~

特征可以做哑变量，标签也可以吗？可以，使用类sklearn.preprocessing.LabelBinarizer可以对做哑变量，许多算法都可以处理多标签问题（比如说决策树）。

![1634374632956](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/165714-335191.png)

**数据类型以及常用的统计量**

![1634374616949](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202110/16/165716-179433.png)