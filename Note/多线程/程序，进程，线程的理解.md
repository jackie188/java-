
<!-- TOC -->

- [程序，进程，线程的理解](#程序进程线程的理解)
  - [**进程**](#进程)
  - [**线程**](#线程)
  - [**程序**](#程序)
  - [**进程和程序的对比**](#进程和程序的对比)
- [并行与并发](#并行与并发)
  - [单`cpu`与多`cpu`的理解](#单cpu与多cpu的理解)
  - [并发](#并发)
  - [并行](#并行)
  - [小结](#小结)
- [同步和异步](#同步和异步)
- [思维导图总结](#思维导图总结)

<!-- /TOC -->
## 程序，进程，线程的理解

### **进程**

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 `IO` 的
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）
- 程序的一次执行过程，或是正在运行的一个程序。 说明：**进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域**，**进程是一个动态的。**
- 一个`java`程序就是一个进程。

### **线程**

- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，可以把线程看作是一组指令的集合。将指令流中的一条条指令以一定的顺序交给 `CPU` 执行
- `Java` 中，线程作为最小调度单位，**进程作为资源分配的最小单位**。 在` windows `中进程是不活动的，只是作
  为线程的容器，而线程是作为**调度的基本单位**，负责运行程序。
- 进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：**线程作为CPU调度和执行的单位，每个线程拥独立的运行栈和程序计数器(`pc`)，线程切换的开销小。**
- **每一个线程都拥有计数器，`java`虚拟机栈，本地方法栈。**

### **程序**

程序(`programm`) 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码,程序是静态的，而进程是动态的。

**图示理解**

![1608032529430](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/thread/202012/15/194211-295050.png)

- 从`jvm`角度考虑

![1608032587778](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/thread/202012/15/194308-722759.png)

==进程可以细化为多个线程。每个线程，拥有自己独立的：栈、程序计数器，多个线程，共享同一个进程中的结构：方法区、堆。==

### **进程和程序的对比**

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信称为 `IPC（Inter-process communication）`
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如` HTTP`
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

## 并行与并发

### 单`cpu`与多`cpu`的理解

- 单核`CPU`，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么`CPU`就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”,但是因为`CPU`时间单元特别短，因此感觉不出来。
- 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
- 一个`Java`应用程序`java.exe`，其实至少三个线程：**`main()`主线程，`gc()`垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。**

### 并发

单核` cpu` 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将` cpu `的时间片（`windows`
下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于` cpu `在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是： **微观串行，宏观并行 ，**

一般会将这种 线程轮流使用` CPU` 的做法称为并发，` concurrent`。

| cpu  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| 核   | 线程1   | 线程2   | 线程3   | 线程4   |

**图解**

![1608038646230](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/thread/202012/15/212407-899688.png)

### 并行

多核` cpu`下(也就是一个`cpu`中有多个核，核心数越多，可以提高程序的吞吐量)，每个 核（`core`） 都可以调度运行线程，这时候线程可以是并行的。

| cpu  | 时间片1 | 时间片2 | 时间片3 | 时间片4 |
| ---- | ------- | ------- | ------- | ------- |
| 核1  | 线程1   | 线程1   | 线程3   | 线程3   |
| 核2  | 线程2   | 线程4   | 线程2   | 线程4   |

**图解**

![1608038923948](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/thread/202012/15/212845-8130.png)

### 小结

- 并发（`concurrent`）是同一时间应对（`dealing with`）多件事情的能力
- 并行（`parallel`）是同一时间动手做（`doing`）多件事情的能力

## 同步和异步

**以调用的角度来讲**

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

**设计**

- 多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒`cpu` 什么都做不了，其它代码都得暂停...

**案例**

- 充分利用多核 `cpu` 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。

```java
计算 1 花费 10 ms
计算 2 花费 11 ms
计算 3 花费 9 ms
汇总需要 1 ms
```

- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = `31ms`
- 但如果是四核 `cpu`，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 `11ms `最后加上汇总时间只会花费 `12ms`

> 注意
> 需要在多核 `cpu` 才能提高效率，单核仍然时是轮流执行

**结论**

- 单核` cpu `下，多线程不能实际提高程序运行效率，**只是为了能够在不同的任务之间切换，不同线程轮流使用`cpu `，不至于一个线程总占用`cpu`，别的线程没法干活**
- 多核 `cpu `可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
  - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）
  - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义
- `IO `操作不占用` cpu`，只是我们一般拷贝文件使用的是【阻塞` IO`】，这时相当于线程虽然不用`cpu`，但需要一直等待` IO `结束，没能充分利用线程。所以才有后面的【非阻塞 `IO`】和【异步 `IO`】优化

## 思维导图总结

![1610274193742](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202101/10/182315-326361.png)