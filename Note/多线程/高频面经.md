# 面试题

<!-- TOC -->

- [面试题](#面试题)
  - [volatile是什么](#volatile是什么)
  - [JMM内存模型](#jmm内存模型)
    - [可见性](#可见性)
    - [原子性](#原子性)
      - [volatile不保证原子性理论解释](#volatile不保证原子性理论解释)
      - [volatile不保证原子性问题解决](#volatile不保证原子性问题解决)
    - [指令重排](#指令重排)
      - [volatile指令重排案例1](#volatile指令重排案例1)
      - [volatile指令重排案例2](#volatile指令重排案例2)
      - [禁止指令重排小总结](#禁止指令重排小总结)
    - [单例模式在多线程环境下可能存在安全问题](#单例模式在多线程环境下可能存在安全问题)
      - [**使用重量级锁解决**](#使用重量级锁解决)
      - [**单例模式volatile分析**](#单例模式volatile分析)
  - [CAS](#cas)
    - [CAS底层原理-上](#cas底层原理-上)
    - [CAS底层原理-下](#cas底层原理-下)
    - [CAS缺点](#cas缺点)
    - [ABA问题](#aba问题)
    - [AtomicReference原子引用](#atomicreference原子引用)
    - [AtomicStampedReference版本号原子引用](#atomicstampedreference版本号原子引用)
    - [ABA问题的解决](#aba问题的解决)
  - [集合不安全类](#集合不安全类)
    - [集合类不安全之并发修改异常](#集合类不安全之并发修改异常)
    - [集合类不安全之写时复制](#集合类不安全之写时复制)
    - [集合类不安全之Set](#集合类不安全之set)
    - [集合类不安全之Map](#集合类不安全之map)
    - [小结](#小结)
  - [java锁](#java锁)
    - [公平和非公平锁](#公平和非公平锁)
    - [可重入锁和递归锁理论知识](#可重入锁和递归锁理论知识)
      - [java锁之可重入锁和递归锁代码验证](#java锁之可重入锁和递归锁代码验证)
    - [自旋锁理论](#自旋锁理论)
    - [读写锁理论](#读写锁理论)
  - [CountDownLatch](#countdownlatch)
  - [CyclicBarrierDemo](#cyclicbarrierdemo)
  - [Semaphore](#semaphore)
  - [阻塞队列](#阻塞队列)
    - [概述](#概述)
    - [架构介绍](#架构介绍)
    - [核心方法](#核心方法)
    - [阻塞队列之同步SynchronousQueue队列](#阻塞队列之同步synchronousqueue队列)
    - [应用](#应用)
      - [生产者消费者模式](#生产者消费者模式)
    - [Lock和Synchronized的区别](#lock和synchronized的区别)
    - [线程通信之生产者消费者阻塞队列版(消息中间件)](#线程通信之生产者消费者阻塞队列版消息中间件)

<!-- /TOC -->

## volatile是什么

volatile是JVM提供的**轻量级**的同步机制，有三大特性

1. 保证可见性
2. 不保证原子性
3. 禁止指令重排（保证有序性）

## JMM内存模型

JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定：

1. 线程解锁前，必须把共享变量的值刷新回主内存
2. 线程加锁前，必须读取主内存的最新值到自己的工作内存
3. 加锁解锁是同一把锁

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![1619347442594](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202104/25/184404-956520.png)

以上这种某一个线程对共享变量的修改后，然后对其他的线程可见，就叫做可见性。

### 可见性

- 通过前面对JMM的介绍，我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
- 这就可能存在一个线程AAA修改了共享变量X的值但还未写回主内存时，另外一个线程BBB又对主内存中同一个共享变量X进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题

**可见性代码验证说明**

~~~ java
/**
 * 假设是主物理内存
 */
class MyData {

    //volatile int number = 0;
     int number = 0;

    public void addTo60() {
        this.number = 60;
    }
}


/**
 * 验证volatile的可见性
 * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰
 下面的案例可以保证变量之间的可见性
 */
public class VolatileDemo {

    public static void main(String[] args) {
        // 资源类
        MyData myData = new MyData();

        // AAA线程 实现了Runnable接口的，lambda表达式
        new Thread(() -> {

            System.out.println(Thread.currentThread().getName() + "\t come in");

            // 线程睡眠3秒，假设在进行运算
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 修改number的值
            myData.addTo60();

            // 输出修改后的值
            System.out.println(Thread.currentThread().getName() + "\t update number value:" + myData.number);

        }, "AAA").start();

        // main线程就一直在这里等待循环，直到number的值不等于零,但是不可能为0，因为aaa线程对值的修改对main线程是不可见的
//        如果给number添加volatile关键字，就保证了其可见性
        while(myData.number == 0) {}

        // 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环
        // 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了
        System.out.println(Thread.currentThread().getName() + "\t mission is over");
    }
}
~~~

由于没有`volatile`修饰`MyData`类的成员变量`number`，`main`线程将会卡在`while(myData.number == 0) {}`，不能正常结束。若想正确结束，用`volatile`修饰`MyData`类的成员变量`number`。

**volatile类比**

没有volatile修饰变量效果，相当于A同学拷贝了老师同一课件，A同学对课件进一步的总结归纳，形成自己的课件，这就与老师的课件不同了。

有volatile修饰变量效果，相当于A同学拷贝了老师同一课件，A同学对课件进一步的总结归纳，形成自己的课件，并且与老师分享，老师认可A同学修改后的课件，并用它来作下一届的课件。

### 原子性

原子性指的是什么意思？

不可分割，完整性，也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割。需要整体完整要么同时成功，要么同时失败。

volatile不保证原子性案例演示：

~~~ java
class MyData2 {
    /**
     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
     */
    volatile int number = 0;


    public void addPlusPlus() {
        number ++;
    }
}

public class VolatileAtomicityDemo {

	public static void main(String[] args) {
        MyData2 myData = new MyData2();

        // 创建10个线程，线程里面进行1000次循环
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                // 里面
                for (int j = 0; j < 1000; j++) {
                    myData.addPlusPlus();
                }
            }, String.valueOf(i)).start();
        }

        // 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值
        // 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程
        while(Thread.activeCount() > 2) {
            // yield表示不执行
            Thread.yield();
        }

        // 查看最终的值
        // 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000
        System.out.println(Thread.currentThread().getName() + "\t finally number value: " + myData.number);

	}
}
~~~

#### volatile不保证原子性理论解释

`number++`在多线程下是非线程安全的。

我们可以将代码编译成字节码，可看出`number++`被编译成3条指令。

![1619423751322](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202104/26/160347-223924.png)

假设我们没有加 synchronized，那么第一步就可能存在着，三个线程同时通过getfield命令，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行 iadd 命令的时候，因为只能一个进行写，所以其它操作会被挂起，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是因为太快了，其它两个线程，陆续执行 iadd命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000。
#### volatile不保证原子性问题解决

可加synchronized解决，但它是重量级同步机制，性能上有所顾虑。

如何不加synchronized解决number++在多线程下是非线程安全的问题？使用AtomicInteger。

~~~ java
import java.util.concurrent.atomic.AtomicInteger;

class MyData2 {
    /**
     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
     */
	volatile int number = 0;
  //juc下的原子整数类
	AtomicInteger number2 = new AtomicInteger();

    public void addPlusPlus() {
        number ++;
    }
    //调用原子++操作
    public void addPlusPlus2() {
    	number2.getAndIncrement();
    }
}

public class VolatileAtomicityDemo {

	public static void main(String[] args) {
        MyData2 myData = new MyData2();

        // 创建10个线程，线程里面进行1000次循环
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                // 里面
                for (int j = 0; j < 1000; j++) {
                    myData.addPlusPlus();
                    myData.addPlusPlus2();
                }
            }, String.valueOf(i)).start();
        }

        // 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值
        // 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程
        while(Thread.activeCount() > 2) {
            // yield表示不执行
            Thread.yield();
        }

        // 查看最终的值
        // 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000
        System.out.println(Thread.currentThread().getName() + "\t finally number value: " + myData.number);
        System.out.println(Thread.currentThread().getName() + "\t finally number2 value: " + myData.number2);
	}
}

//输出结果是
main	 finally number value: 18766
main	 finally number2 value: 20000
~~~

concurrent包下的原子类：

![1620102635762](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/04/123037-627564.png)

### 指令重排

#### volatile指令重排案例1

计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：

![1619424963332](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202104/26/161605-304293.png)

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。

处理器在进行重排序时必须要考虑指令之间的**数据依赖性**

多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

就像考试答题的顺序和出题的顺序不同一样。

**重拍案例一**

~~~ java
public void mySort{
	int x = 11;//语句1
   int y = 12;//语句2
    × = × + 5;//语句3
    y = x * x;//语句4
}
~~~

可重排序列：多线程下程序执行的顺序是不确定的。

- 1234
- 2134
- 1324

问题：请问语句4可以重排后变成第一个条吗？答：不能。数据存在依赖性。

**重排案例二**

~~~ java
int a,b,x,y = 0
~~~

| 线程1                    | 线程2  |
| ------------------------ | ------ |
| x = a;                   | y = b; |
| b = 1;                   | a = 2; |
| 第一种结果：x = 0; y = 0 |        |

如果编译器对这段程序代码执行重排优化后，可能出现下列情况：

| 线程1                    | 线程2  |
| ------------------------ | ------ |
| b = 1;                   | a = 2; |
| x = a;                   | y = b; |
| 第二种结果：x = 2; y = 1 |        |

这也就说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。

#### volatile指令重排案例2

~~~ java
public class ReSortSeqDemo{
	int a = 0;
	boolean flag = false;
    
	public void method01(){
    //对下面两条指令可能重排序，导致flag=true，然后method02()方法陷入死循环
		a = 1;//语句1
		flag = true;//语句2
	}
    
    public void method02(){
        if(flag){
            a = a + 5; //语句3
        }
        System.out.println("retValue: " + a);//可能是6或1或5或0
    }
    
}

~~~

多线程环境中线程交替执行`method01()`和`method02()`，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

#### 禁止指令重排小总结

volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象

先了解一个概念，内存屏障(Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个:

- 保证特定操作的执行顺序，
- 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。

由于**编译器和处理器**都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回到主内存。

![1643084092004](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202201/25/121454-452542.png)

对Volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。

![1619426348461](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/03/195042-920624.png)

**线性安全性获得保证**

- 工作内存与主内存同步延迟现象导致的可见性问题 - 可以使用synchronized（只允许一个线程对数据进行操作）或volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。

- 对于指令重排导致的可见性问题和有序性问题 - 可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。

### 单例模式在多线程环境下可能存在安全问题

懒汉单例模式，在单机环境下不会有线程安全问题发生。

~~~ java
public class SingletonDemo {

    private static SingletonDemo instance = null;

    private SingletonDemo () {
        System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo");
    }

    public static SingletonDemo getInstance() {
        if(instance == null) {
            instance = new SingletonDemo();
        }
        return instance;
    }

    public static void main(String[] args) {
        // 这里的 == 是比较内存地址
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
    }
}
//输出结果，可以看到，只有一个对象
main    我是构造方法singletonDemo
true
true
true
true
~~~

**多线程下执行结果**

~~~ java
public class SingletonDemo {

    private static SingletonDemo instance = null;

    private SingletonDemo () {
        System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo");
    }

    public static SingletonDemo getInstance() {
        if(instance == null) {
            instance = new SingletonDemo();
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                SingletonDemo.getInstance();
            }, String.valueOf(i)).start();
        }
    }
}
//可以看到，构造方法执行了多次，也就是创建了多个对象
4	 我是构造方法SingletonDemo
2	 我是构造方法SingletonDemo
5	 我是构造方法SingletonDemo
6	 我是构造方法SingletonDemo
0	 我是构造方法SingletonDemo
3	 我是构造方法SingletonDemo
1	 我是构造方法SingletonDemo

~~~

#### **使用重量级锁解决**

用`synchronized`修饰方法`getInstance()`，但它属重量级同步机制，使用时慎重。

~~~ java
public synchronized static SingletonDemo getInstance() {
    if(instance == null) {
        instance = new SingletonDemo();
    }
    return instance;
}
~~~

#### **单例模式volatile分析**

解决方法之二：DCL（Double Check Lock双端检锁机制）

~~~ java
public class SingletonDemo{
	private SingletonDemo(){}
    
    private volatile static SingletonDemo instance = null;

    public static SingletonDemo getInstance() {
        if(instance == null) {
            synchronized(SingletonDemo.class){
                if(instance == null){
                    instance = new SingletonDemo();       
                }
            }
        }
        return instance;
    }
}

~~~

**DCL中volatile解析**

原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象**可能没有完成初始化**。`instance = new SingletonDemo();`可以分为以下3步完成(伪代码)：

~~~ java
memory = allocate(); //1.分配对象内存空间
instance(memory); //2.初始化对象
instance = memory; //3.设置instance指向刚分配的内存地址，此时instance != null
~~~

步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。

~~~ java
memory = allocate(); //1.分配对象内存空间
instance = memory;//3.设置instance指向刚分配的内存地址，此时instance! =null，但是对象还没有初始化完成!
instance(memory);//2.初始化对象
~~~

**但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。**所以对于多线程操作，需要考虑指令重排带来的线程安全问题。

所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，最后返回的instance就是null指，也就造成了线程安全问题。解决办法就是添加volatile关键字，禁止指令重拍操作。

## CAS

在多线程环境下，执行I++或者i–操作存在线程安全问题。所以在多线程环境下，一般使用AtomicInteger原子整数类来保证线程安全问题。

Compare And Set

### CAS底层原理-上

`atomiclnteger.getAndIncrement();`源码

~~~ java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    
    /**
     * Creates a new AtomicInteger with the given initial value.
     *
     * @param initialValue the initial value
     */
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }

    /**
     * Creates a new AtomicInteger with initial value {@code 0}.
     */
    public AtomicInteger() {
    }
    
    ...
            
    /**
     * Atomically increments by one the current value.
     *
     * @return the previous value
     */
    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
    
    ...
}
~~~

**UnSafe**

Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法

**注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务**。

变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。然后获取地址中的值和当前期望的值进行比较。

变量value用volatile修饰，保证了多线程之间的内存可见性。

**CAS是什么**

CAS的全称为Compare-And-Swap，它是一条CPU并发原语。

它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的，是在硬件层面操作部完成的。

CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。（原子性）

**源码角度理解**

调用unsafe类里面的方法相当于直接操作操作系统级别的代码，this表示当前的额对象，valueoffset表示当前对象中属性的地址偏移量，1表示每一次都自增1操作，在getAndAddInt()方法中，里面的while()循环相当于一个自旋操作，循环中首先获取当前内存中的值，注意value是有volatile修饰的，所以对各个线程都可见，这里首先获取的是最新的值，然后使用cas操作判断当前获取的值是否和期望的值一样，如果一样的话就在此基础上进行更新操作，然后退出循环，否则就一直循环，指导更新完成为止。最后返回更新过的值。

![1620046489633](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/03/205452-283346.png)

~~~ java
//具体的方法
public final int getAndSet(int newValue) {
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    }

 public final int getAndSetInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var4));

        return var5;
    }
~~~

### CAS底层原理-下

`UnSafe.getAndAddInt()`源码解释：

- `var1` AtomicInteger对象本身。
- `var2` 该对象值得引用地址。
- `var4` 需要变动的数量。
- `var5`是用过`var1`，`var2`找出的主内存中真实的值。
- 用该对象当前的值与`var5`比较： 
  - 如果相同，更新`var5+var4`并且返回`true`,
  - 如果不同，继续取值然后再比较，直到更新完成。

为什么要使用cas而不是用synchronized?

- 如果使用synchronized，那么同一个时间段只允许一个线程去访问，一致性得到保障，但是并发度比较低，但是如果使用cas算法，使用自旋的方法，就能保证一致性，又可以保证并发性高。

假设**线程A**和**线程B**两个线程同时执行getAndAddInt操作（分别跑在不同CPU上) ：

1. Atomiclnteger里面的value原始值为3，即主内存中Atomiclnteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。
2. 线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。
3. 线程B也通过getintVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。
4. 这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的值数字4不一致，说明该值己经被其它线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍了。
5. 线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwaplnt进行比较替换，直到成功。

**小结**

- CAS指令
  - CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。
  - 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

### CAS缺点

**循环时间长开销很大**

因为有自旋操作，如果比较失败的话，一直在这里循环等待。如果有多个线程都在做自旋操作，那么cpu的消耗很大。

~~~ java
// ursafe.getAndAddInt
public final int getAndAddInt(Object var1, long var2, int var4){
	int var5;
	do {
		var5 = this.getIntVolatile(var1, var2);
	}while(!this.compareAndSwapInt(varl, var2, var5，var5 + var4));
    return var5;
}
~~~

我们可以看到getAndAddInt方法执行时，有个do while，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。

只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

cas的缺点就是aba问题，**引出来ABA问题**

> cas--->unsafe—>cas底层思想--->cas缺点ABA问题—>原子引用更新--->如何规避ABA问题

### ABA问题

ABA问题怎么产生的

CAS会导致“ABA问题”。

CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。

比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B,然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。

尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。

### AtomicReference原子引用

~~~ java
import java.util.concurrent.atomic.AtomicReference;

class User{
	
	String userName;
	
	int age;
	
    public User(String userName, int age) {
		this.userName = userName;
		this.age = age;
	}

	@Override
	public String toString() {
		return String.format("User [userName=%s, age=%s]", userName, age);
	}
    
}

public class AtomicReferenceDemo {
    public static void main(String[] args){
        User z3 = new User( "z3",22);
        User li4 = new User("li4" ,25);
		AtomicReference<User> atomicReference = new AtomicReference<>();
        atomicReference.set(z3);
		System.out.println(atomicReference.compareAndSet(z3, li4)+"\t"+atomicReference.get().toString());
        System.out.println(atomicReference.compareAndSet(z3, li4)+"\t"+atomicReference.get().toString());
    }
}
//输出结果
true	User [userName=li4, age=25]
false	User [userName=li4, age=25]
~~~

原子引用类可以类比原子整数类，引用类就是对自定义的类型进行一个包装，保证在多线程环境下并发安全执行。

### AtomicStampedReference版本号原子引用

原子引用 + 新增一种机制，那就是修改版本号（类似时间戳），它用来解决ABA问题。如果只比较值的话，只能看到结果，无法看到中间过程是否进行变化，现在添加时间戳，只要中间过程变化，就更新时间戳。

### ABA问题的解决

~~~ JAVA
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

public class ABADemo {
	/**
	 * 普通的原子引用包装类
	 */
	static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);

	// 传递两个值，一个是初始值，一个是初始版本号
	static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 1);

	public static void main(String[] args) {

		System.out.println("============以下是ABA问题的产生==========");

		new Thread(() -> {
			// 把100 改成 101 然后在改成100，也就是ABA
			atomicReference.compareAndSet(100, 101);
			atomicReference.compareAndSet(101, 100);
		}, "t1").start();

		new Thread(() -> {
			try {
				// 睡眠一秒，保证t1线程，完成了ABA操作
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// 把100 改成 101 然后在改成100，也就是ABA
			System.out.println(atomicReference.compareAndSet(100, 2019) + "\t" + atomicReference.get());

		}, "t2").start();

		/
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (Exception e) {
			e.printStackTrace();
		}
		/

		
		System.out.println("============以下是ABA问题的解决==========");

		new Thread(() -> {

			// 获取版本号
			int stamp = atomicStampedReference.getStamp();
			System.out.println(Thread.currentThread().getName() + "\t 第一次版本号" + stamp);

			// 暂停t3一秒钟
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

			// 传入4个值，期望值，更新值，期望版本号，更新版本号
			atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(),
					atomicStampedReference.getStamp() + 1);

			System.out.println(Thread.currentThread().getName() + "\t 第二次版本号" + atomicStampedReference.getStamp());

			atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(),
					atomicStampedReference.getStamp() + 1);

			System.out.println(Thread.currentThread().getName() + "\t 第三次版本号" + atomicStampedReference.getStamp());

		}, "t3").start();

		new Thread(() -> {

			// 获取版本号
			int stamp = atomicStampedReference.getStamp();
			System.out.println(Thread.currentThread().getName() + "\t 第一次版本号" + stamp);

			// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题
			try {
				TimeUnit.SECONDS.sleep(3);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
//这里的修改肯定无法成功，期望修改的版本号是1，但是已经被修改版本号为3，所以无法修改成功
			boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);

			System.out.println(Thread.currentThread().getName() + "\t 修改成功否：" + result + "\t 当前最新实际版本号："
					+ atomicStampedReference.getStamp());

			System.out.println(Thread.currentThread().getName() + "\t 当前实际最新值" + atomicStampedReference.getReference());

		}, "t4").start();

	}
}
//输出结果
============以下是ABA问题的产生==========
true	2019
============以下是ABA问题的解决==========
t3	 第一次版本号1
t4	 第一次版本号1
t3	 第二次版本号2
t3	 第三次版本号3
t4	 修改成功否：false	 当前最新实际版本号：3
t4	 当前实际最新值100
~~~

## 集合不安全类

### 集合类不安全之并发修改异常

**说出几个常见的异常**

- java.util.ConcurrentModificationException，并发编程修改异常，
- 空指针异常
- 内存溢出异常
- 栈溢出异常

~~~ java
public class ArrayListNotSafeDemo {
	public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        //List<String> list = new Vector<>();
        //List<String> list = Collections.synchronizedList(new ArrayList<>());

        for (int i = 0; i < 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
	}
}
~~~

以前学习集合类都是在单机情况下，也就是在一个线程操作下，但是在多个线程下，就不能正常运行。

上述程序会抛java.util.ConcurrentModificationException，因为list是共享资源，多个线程访问没有被保护。

- 解决方法之一：Vector，线程安全的数组类。vector已经加锁，数据的一致性可以保证，但是并发程度很低。

- 解决方法之二：Collections.synchronizedList()
- 解决方法之三：CopyOnWriteArrayList（）使用写时复制类解决。

**收集故障从四个角度**

![1620099691711](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/04/114132-652170.png)

### 集合类不安全之写时复制

解决方法之三：CopyOnWriteArrayList（推荐）

~~~ java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {

    /** The array, accessed only via getArray/setArray. */
    private transient volatile Object[] array;
    
    final Object[] getArray() {
        return array;
    }

    final void setArray(Object[] a) {
        array = a;
    }
    
    ...
    
	public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        //获取锁
        lock.lock();
        try {
        //获取当前的数组的引用
            Object[] elements = getArray();
            //获取当前数组的长度
            int len = elements.length;
            //声明一个新的数组，数组长度等于老数组长度+1
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //添加当前的元素
            newElements[len] = e;
            //把新数组的引用给当前数组的引用
            setArray(newElements);
            return true;
        } finally {
        //解锁
            lock.unlock();
        }
    }
    
    ...
    
    public String toString() {
        return Arrays.toString(getArray());
    }
    
    ...
}
~~~

CopyOnWrite容器即写时复制的容器。待一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newELements，然后新的容器Object[ ] newELements里添加元素，添加完元素之后，再将原容器的引用指向新的容器setArray (newELements)。

这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁（区别于Vector和Collections.synchronizedList()），因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。读的时候可以多个线程一起读取，但是写的时候，只能有一个线程写入。

### 集合类不安全之Set

HashSet底层的数据结构就是HashMap结构。

HashSet也是非线性安全的。（HashSet内部是包装了一个HashMap的），HASHMAP底层是键值对，hashmap添加元素需要两个元素，但是hashSet只需要添加一个元素，添加的值作为建存储，而值存储的是一个常量`return map.put(e, PRESENT)`

~~~ java
public class SetNotSafeDemo {
	
	public static void main(String[] args) {
		//非线程安全的HashSet
		Set<String> set = new HashSet<>();
    //Collections集合中的线程安全HashSet
		//Set<String> set = Collections.synchronizedSet(new HashSet<>());
    //读写分离式的线程安全HashSet
		//Set<String> set = new CopyOnWriteArraySet<String>();
		
        for (int i = 0; i < 30; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(set);
            }, String.valueOf(i)).start();
        }
	}	
}
~~~

**解决方法：**

1. Collections.synchronizedSet(new HashSet<>())
2. CopyOnWriteArraySet<>()（推荐）

**CopyOnWriteArraySet源码**

~~~ java
public class CopyOnWriteArraySet<E> extends AbstractSet<E>
        implements java.io.Serializable {
    private static final long serialVersionUID = 5457747651344034263L;

    private final CopyOnWriteArrayList<E> al;

    /**
     * Creates an empty set.
     */
    public CopyOnWriteArraySet() {
    //底层结构是CopyOnWriteArrayList
        al = new CopyOnWriteArrayList<E>();
    }

    public CopyOnWriteArraySet(Collection<? extends E> c) {
        if (c.getClass() == CopyOnWriteArraySet.class) {
            @SuppressWarnings("unchecked") CopyOnWriteArraySet<E> cc =
                (CopyOnWriteArraySet<E>)c;
            al = new CopyOnWriteArrayList<E>(cc.al);
        }
        else {
            al = new CopyOnWriteArrayList<E>();
            al.addAllAbsent(c);
        }
    }
 
    //可看出CopyOnWriteArraySet包装了一个CopyOnWriteArrayList
    
    ...
    
    public boolean add(E e) {
        return al.addIfAbsent(e);
    }
    
    public boolean addIfAbsent(E e) {
        Object[] snapshot = getArray();
        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
            addIfAbsent(e, snapshot);
    }
    
    //暴力查找
    private static int indexOf(Object o, Object[] elements,
                               int index, int fence) {
        if (o == null) {
            for (int i = index; i < fence; i++)
                if (elements[i] == null)
                    return i;
        } else {
            for (int i = index; i < fence; i++)
                if (o.equals(elements[i]))
                    return i;
        }
        return -1;
    }

    private boolean addIfAbsent(E e, Object[] snapshot) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] current = getArray();
            int len = current.length;
            if (snapshot != current) {//还要检查多一次元素存在性，生怕别的线程已经插入了
                // Optimize for lost race to another addXXX operation
                int common = Math.min(snapshot.length, len);
                for (int i = 0; i < common; i++)
                    if (current[i] != snapshot[i] && eq(e, current[i]))
                        return false;
                if (indexOf(e, current, common, len) >= 0)
                        return false;
            }
            Object[] newElements = Arrays.copyOf(current, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
    
    ...
        
}
~~~

### 集合类不安全之Map

~~~ java
public class MapNotSafeDemo {

	public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();
//    Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
//		Map<String, String> map = new ConcurrentHashMap<>();
//		Map<String, String> map = new Hashtable<>();
        for (int i = 0; i < 30; i++) {
            new Thread(() -> {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }

	}

}
~~~

**解决方法：**

1. HashTable
2. Collections.synchronizedMap(new HashMap<>())
3. ConcurrencyMap<>()（推荐）

### 小结

对于并发不安全的集合有两种解决方法：

1. 在Collections中提供有线程安全的封装类工具。

![1620102432458](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/04/122713-303652.png)

2. 在concurrent包下有线程安全的集合类。

![1620102894417](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/04/123455-621963.png)

## java锁

### 公平和非公平锁

什么是公平锁和非公平锁？

- **公平锁**―是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。类似于队列。
- **非公平锁**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后中请的线程比先中请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象。可以认为获取锁中有抢占。

**两者区别**

- 公平锁
  - Threads acquire a fair lock in the order in which they requested it.
  - 公平锁就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。
- 非公平锁
  - a nonfair lock permits barging: threads requesting a lock can jump ahead of the queue of waiting threads if the lockhappens to be available when it is requested.
  - 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。

**关于ReentrantLock重入锁**

并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁。从源码中我们可以看到默认是非公平的。

~~~ java
 /**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }
~~~

> 如果参数设置为true,那么就是一种公平锁。
>
> 非公平锁的优点在于吞吐量比公平锁大。
>
> 对于Synchronized而言，也是一种非公平锁
>
> 可重入锁的含义就是如果某一个线程已经获取锁，那么当次线程再次来获取当前锁的时候，仍然是可以获取到的，也就是已经获取锁的线程可以多次获取同一把锁。

### 可重入锁和递归锁理论知识

- 可重入锁（也叫做递归锁）
- 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- 也即是说，**线程可以进入任何一个它已经拥有的锁所同步着的代码块**。
- ReentrantLock/synchronized就是一个典型的可重入锁。
- 可重入锁最大的作用是避免死锁。

#### java锁之可重入锁和递归锁代码验证

Synchronized可入锁演示程序

~~~ java
class Phone {

  //两个方法锁住的都是this对象
    public synchronized void sendSMS() throws Exception{
        System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS()");

        // 在同步方法中，调用另外一个同步方法
        sendEmail();
    }


    public synchronized void sendEmail() throws Exception{
        System.out.println(Thread.currentThread().getId() + "\t invoked sendEmail()");
    }
}

public class SynchronizedReentrantLockDemo {

	public static void main(String[] args) {
    
    //调用方法实际锁住的是phone对象
        Phone phone = new Phone();

        // 两个线程操作资源列
        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(() -> {
            try {
                phone.sendSMS();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "t2").start();
	}

}
//输出结果
t1	 invoked sendSMS()
11	 invoked sendEmail()
t2	 invoked sendSMS()
12	 invoked sendEmail()
~~~

**ReentrantLock可重入锁演示程序**

~~~ java
class Phone2 implements Runnable{

    Lock lock = new ReentrantLock();

    /**
     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法
     */
    public void getLock() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t get Lock");
            setLock();
        } finally {
            lock.unlock();
        }
    }

    public void setLock() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t set Lock");
        } finally {
            lock.unlock();
        }
    }

    @Override
    public void run() {
        getLock();
    }
}

public class ReentrantLockDemo {


    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        /**
         * 因为Phone实现了Runnable接口
         */
        Thread t3 = new Thread(phone, "t3");
        Thread t4 = new Thread(phone, "t4");
        t3.start();
        t4.start();
    }
}
//输出结果
t3	 get Lock
t3	 set Lock
t4	 get Lock	
t4	 set Lock
~~~

> 注意：可以多次调用lock()进行加锁，但是lock()需要和unlock()成对出现。多次加锁一定需要成对出现，语法层面可以通过，运行程序也可以通过。

### 自旋锁理论

**自旋锁（Spin Lock）**

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU

~~~ java
 public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }
//while循环就是自旋操作
~~~

> 提到了互斥同步对性能最大的影响阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程 “稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。
>
> 自旋锁的好处：循环等待，不用上下文切换阻塞线程，减小开销。

自旋的本质就是while循环+cas算法。

**自己实现自旋锁**

~~~ java
public class Test {
    // 现在的泛型装的是Thread，原子引用线程
    AtomicReference<Thread>  atomicReference = new AtomicReference<>();

    public void myLock() {
        // 获取当前进来的线程
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "\t come in ");

        // 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋
        while(!atomicReference.compareAndSet(null, thread)) {
            //在这里进行自旋操作
        }
    }

    public void myUnLock() {
        // 获取当前进来的线程
        Thread thread = Thread.currentThread();

        // 自己用完了后，把atomicReference变成null
        atomicReference.compareAndSet(thread, null);

        System.out.println(Thread.currentThread().getName() + "\t invoked myUnlock()");
    }

    public static void main(String[] args) {
        Test spinLockDemo = new Test();

        // 启动t1线程，开始操作
        new Thread(() -> {

            // 开始占有锁,也就是获取锁对象
            spinLockDemo.myLock();

            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 开始释放锁
            spinLockDemo.myUnLock();

        }, "t1").start();


        // 让main线程暂停1秒，使得t1线程，先执行
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 1秒后，启动t2线程，开始占用这个锁
        new Thread(() -> {

            // 开始占有锁
            spinLockDemo.myLock();
            // 开始释放锁
            spinLockDemo.myUnLock();

        }, "t2").start();
    }
}
~~~

### 读写锁理论

- 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁

- 共享锁：指该锁可被多个线程所持有。

- 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。但是，如果有一个线程想去写共享资源来，就不应该再有其它线程可以对该资源进行读或写。

- 对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁。

- 读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

> 读-读共存
>
> 读-写不能共存
>
> 写-写不能共存

**java锁之读写锁代码验证**

~~~ java
class MyCache {

    private volatile Map<String, Object> map = new HashMap<>();

    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key);
        try {
            // 模拟网络拥堵，延迟0.3秒
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "\t 写入完成");
    }


    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + "\t 正在读取:");
        try {
            // 模拟网络拥堵，延迟0.3秒
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + value);
    }
}


public class ReadWriteWithoutLockDemo {

    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        // 线程操作资源类，5个线程写
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt +  "");
            }, String.valueOf(i)).start();
        }

        // 线程操作资源类， 5个线程读
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }

    }
}
//执行结果
4	 正在写入：4
1	 正在写入：1
0	 正在写入：0
3	 正在写入：3
2	 正在写入：2
0	 正在读取:
1	 正在读取:
2	 正在读取:
4	 正在读取:
3	 正在读取:
0	 写入完成
0	 读取完成：null
1	 写入完成
4	 读取完成：null
2	 读取完成：2
3	 读取完成：3
4	 写入完成
3	 写入完成
2	 写入完成
1	 读取完成：null
//可以看到，各个线程在写入的时候，已经被打断
~~~

- 可以使用ReentrantReadWriteLock读写锁进行改进

~~~ java
class MyCache2 {

    private volatile Map<String, Object> map = new HashMap<>();

    private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {

        // 创建一个写锁
        rwLock.writeLock().lock();

        try {

            System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key);

            try {
                // 模拟网络拥堵，延迟0.3秒
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            map.put(key, value);

            System.out.println(Thread.currentThread().getName() + "\t 写入完成");

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 写锁 释放
            rwLock.writeLock().unlock();
        }
    }

    public void get(String key) {

        // 读锁
        rwLock.readLock().lock();
        try {

            System.out.println(Thread.currentThread().getName() + "\t 正在读取:");

            try {
                // 模拟网络拥堵，延迟0.3秒
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            Object value = map.get(key);

            System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + value);

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 读锁释放
            rwLock.readLock().unlock();
        }
    }

    public void clean() {
        map.clear();
    }


}

public class ReadWriteWithLockDemo {
    public static void main(String[] args) {

        MyCache2 myCache = new MyCache2();

        // 线程操作资源类，5个线程写
        for (int i = 1; i <= 5; i++) {
            // lambda表达式内部必须是final
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt +  "");
            }, String.valueOf(i)).start();
        }

        // 线程操作资源类， 5个线程读
        for (int i = 1; i <= 5; i++) {
            // lambda表达式内部必须是final
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }
    }
}
//执行结果
1	 正在写入：1
1	 写入完成
2	 正在写入：2
2	 写入完成
3	 正在写入：3
3	 写入完成
5	 正在写入：5
5	 写入完成
4	 正在写入：4
4	 写入完成
2	 正在读取:
3	 正在读取:
1	 正在读取:
5	 正在读取:
4	 正在读取:
3	 读取完成：3
2	 读取完成：2
1	 读取完成：1
5	 读取完成：5
4	 读取完成：4
//可以看到。线程中间的写操作没有被打断，多个读取操作可以并行执行，达到读写分离的思想
~~~

## CountDownLatch

让一线程阻塞直到另一些线程完成一系列操作才被唤醒。，类似于join操作。

CountDownLatch主要有两个方法（await()，countDown()）。

当一个或多个线程调用await()时，调用线程会被阻塞。其它线程调用countDown()会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。

假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的

~~~ java
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {

        // 计数器
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 上完自习，离开教室");
                countDownLatch.countDown();
            }, String.valueOf(i)).start();
        }

//        当countDownLatch的值减到0的时候，才会解除await阻塞
        countDownLatch.await();

        System.out.println(Thread.currentThread().getName() + "\t 班长最后关门");
    }

}

~~~

**CountDownLatch类**

~~~ java
public class CountDownLatch {}
~~~

枚举 + CountDownLatch

**程序演示秦国统一六国**

~~~ java
public enum CountryEnum {

    ONE(1, "齐"), TWO(2, "楚"), THREE(3, "燕"), FOUR(4, "赵"), FIVE(5, "魏"), SIX(6, "韩");

    private Integer retcode;
    private String retMessage;

//    构造方法
    CountryEnum(Integer retcode, String retMessage) {
        this.retcode = retcode;
        this.retMessage = retMessage;
    }

    public static CountryEnum forEach_countryEnum(int index) {
        CountryEnum[] myArray = CountryEnum.values();
        for(CountryEnum ce : myArray) {
            if(Objects.equals(index, ce.getRetcode())) {
                return ce;
            }
        }
        return null;
    }

    public Integer getRetcode() {
        return retcode;
    }

    public void setRetcode(Integer retcode) {
        this.retcode = retcode;
    }

    public String getRetMessage() {
        return retMessage;
    }

    public void setRetMessage(String retMessage) {
        this.retMessage = retMessage;
    }
    public static void main(String[] args) throws InterruptedException {
        // 计数器
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "国被灭了！");
                countDownLatch.countDown();
            }, CountryEnum.forEach_countryEnum(i).getRetMessage()).start();
        }

        countDownLatch.await();

        System.out.println(Thread.currentThread().getName() + " 秦国统一中原。");
    }
}
~~~

## CyclicBarrierDemo

CyclicBarrier的字面意思就是可循环（Cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。

CyclicBarrier与CountDownLatch的区别：CyclicBarrier可重复多次，而CountDownLatch只能是一次

~~~ java
public class SummonTheDragonDemo {

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-> System.out.println("召唤神龙"));

        for (int i = 1; i <=7; i++) {
            int tempInt=i;
            new Thread(()->{
                System.out.println(Thread.currentThread().getName() + "\t 收集到 第" + tempInt + "颗龙珠");
                try {
                    // 先到的被阻塞，等全部线程完成后，才能执行方法
//                    等到所有线程都执行完毕，才开始执行cyclicBarrier里面的方法
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
~~~

## Semaphore

信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。

正常的锁(concurrency.locks或synchronized锁)在任何时刻都**只允许一个任务访问一项资源**，而 Semaphore允许**n个任务**同时访问这个资源。

模拟一个抢车位的场景，假设一共有6个车，3个停车位

~~~ java
public class SemaphoreDemo {

    public static void main(String[] args) {

        /**
         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位
         */
        Semaphore semaphore = new Semaphore(3, false);

        // 模拟6部车
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    // 代表一辆车，已经占用了该车位
                    semaphore.acquire(); // 抢占

                    System.out.println(Thread.currentThread().getName() + "\t 抢到车位");

                    // 每个车停3秒
                    try {
                        TimeUnit.SECONDS.sleep(3);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + "\t 离开车位");

                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放停车位
                    semaphore.release();
                }
            }, String.valueOf(i)).start();
        }
    }
}
~~~

## 阻塞队列

### 概述

**阻塞队列**，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：

![1620718329637](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/11/153211-209083.png)

- 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素。

- 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。

- 当阻塞队列是满时，往队列里添加元素的操作将会被阻塞。

- 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。

- 同样试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增

**为什么需要BlockingQueue**

- 在多线程领域：所谓阻塞，在某些情况下挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒
- 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了
- 在Concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。

### 架构介绍

![1620719126304](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/11/154526-729280.png)

**继承结构**

![1620719249966](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/11/154731-390999.png)

**说明**

- ArrayBlockingQueue：由**数组**结构组成的**有界**阻塞队列。==重点==
- LinkedBlockingQueue：由**链表**结构组成的**有界**（但大小默认值为Integer.MAX_VALUE）阻塞队列。==重点==
- PriorityBlockingQueue：支持**优先级**排序的**无界**阻塞队列。
- DelayQueue：使用优先级队列实现妁**延迟无界**阻塞队列。
- SynchronousQueue：不存储元素的阻塞队列。==重点==
- LinkedTransferQueue：由链表结构绒成的无界阻塞队列。
- LinkedBlockingDeque：由链表结构组成的双向阻塞队列。

### 核心方法

**BlockingQueue核心方法**

| 方法类型 | 抛出异常                                     | 特殊值   | 阻塞   | 超时               |
| -------- | -------------------------------------------- | -------- | ------ | ------------------ |
| 插入     | add(e)                                       | offer(e) | put(e) | offer(e,time,unit) |
| 移除     | remove()                                     | poll()   | take() | poll(time,unit)    |
| 检查     | element(),检查队列空不空，然后返回队列首元素 | peek()   | 不可用 | 不可用             |

**核心方法说明**

| 性质     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 抛出异常 | 当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full<br/>当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException |
| 特殊性   | 插入方法，成功true，失败false，移除方法：成功返回出队列元素，队列没有就返回空 |
| 一直阻塞 | 当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出。当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。 |
| 超时退出 | 当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出 |

**第一组api**

当队列满的时候，再往队列中添加元素会抛出异常

~~~ java
public class Test47 {

    public static void main(String[] args) {

//        初始的阻塞队列大小是3
        ArrayBlockingQueue<String> strings = new ArrayBlockingQueue<String>(3);
//        向阻塞队列中添加元素
        System.out.println(strings.add("a"));
        System.out.println(strings.add("b"));
        System.out.println(strings.add("c"));
        System.out.println(strings.add("x"));
    }
}
~~~

![1620720266195](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/11/160427-52167.png)

队列中如果没有元素，删除元素也会抛出异常

~~~ java
public class Test47 {

    public static void main(String[] args) {

//        初始的阻塞队列大小是3
        ArrayBlockingQueue<String> strings = new ArrayBlockingQueue<String>(3);
//        向阻塞队列中添加元素
        System.out.println(strings.add("a"));
        System.out.println(strings.add("b"));
        System.out.println(strings.add("c"));

        System.out.println(strings.remove());
        System.out.println(strings.remove());
        System.out.println(strings.remove());
        System.out.println(strings.remove());
    }
}
~~~

![1620720396029](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/11/160637-765982.png)

**第二组api**

~~~ java
public class Test47 {

    public static void main(String[] args) {

//        初始的阻塞队列大小是3
        ArrayBlockingQueue<String> strings = new ArrayBlockingQueue<String>(3);
//        向阻塞队列中添加元素
        System.out.println(strings.offer("a"));
        System.out.println(strings.offer("a"));
        System.out.println(strings.offer("a"));
//        查看队列首的元素
        System.out.println(strings.peek());

        System.out.println(strings.poll());
        System.out.println(strings.poll());
        System.out.println(strings.poll());
//        队列中没有元素就返回null
        System.out.println(strings.poll());


    }
}
~~~

**第三组api**
第三组api会发生阻塞，当队列中没有元素，如果来take()元素，会发生阻塞，直到有元素入队列，当队列满，如果put()元素的话，put()线程会发生阻塞，直到队列中有一个元素出队列为止。

**第四组api**

~~~ java
public class Test47 {

    public static void main(String[] args) throws InterruptedException {

//        初始的阻塞队列大小是3
        ArrayBlockingQueue<String> strings = new ArrayBlockingQueue<String>(3);
//        向阻塞队列中添加元素,超时时间是2，如果队列没有满，那么可以正常插入元素，如果队列满的话
//        在此插入元素，插入过程会等待两秒钟，如果两秒钟内还没有插入元素，就放弃插入元素
        System.out.println(strings.offer("a",2l, TimeUnit.SECONDS));
        System.out.println(strings.offer("a",2l, TimeUnit.SECONDS));
        System.out.println(strings.offer("a",2l, TimeUnit.SECONDS));
        System.out.println(strings.offer("a",2l, TimeUnit.SECONDS));
//        查看队列首的元素
        System.out.println(strings.peek());


    }
}
~~~

### 阻塞队列之同步SynchronousQueue队列

- SynchronousQueue没有容量。
- 与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。
- 每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。

**案例**

~~~ java
public class Test48 {

    public static void main(String[] args) {
        SynchronousQueue<String> strings = new SynchronousQueue<>();

        new Thread(()->{
//         线程t1向阻塞队列中添加元素
            try {
                System.out.println(Thread.currentThread().getName()+" put aaa");
                strings.put("aaa");
                System.out.println(Thread.currentThread().getName()+" put bbb");
                strings.put("bbb");
                System.out.println(Thread.currentThread().getName()+" put ccc");
                strings.put("ccc");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t1").start();

//        线程t2负责消费数据
        new Thread(()->{
//t2 线程每5秒消费一次数据
            try {
                Thread.sleep(5000);
                String take = strings.take();
                System.out.println(Thread.currentThread().getName()+" 线程获取数据:"+take);

                Thread.sleep(5000);
                String take1 = strings.take();
                System.out.println(Thread.currentThread().getName()+" 线程获取数据:"+take1);
                Thread.sleep(5000);
                String take2 = strings.take();
                System.out.println(Thread.currentThread().getName()+" 线程获取数据:"+take2);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"t2").start();
    }
}
~~~

### 应用

#### 生产者消费者模式

![1620880477785](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202105/13/123438-222336.png)

**生产者消费者模式**

~~~ java
public class TradConsumAndProd {

    public static void main(String[] args) {

        SharedData sharedData = new SharedData();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    sharedData.increment();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"t1").start();
        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    sharedData.decrement();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"t2").start();


    }
}


/**
 * 资源类
 *
 * 线程           操作（方法）          资源类
 * 判断           干活                  通知
 * 防止虚假唤醒机制
 */
class SharedData{

    private int data;
    private Lock lock=new ReentrantLock();
//    获取条件变量
    private Condition condition=lock.newCondition();

    public void increment()throws Exception
    {
        lock.lock();
        try {
            //        1 判断
            while (data != 0){
//            等待，不可以生产,添加到阻塞队列中
                condition.await();
            }
//        2 干活
            data++;
            System.out.println(Thread.currentThread().getName()+"  "+data);
//        3 通知唤醒消费者
            condition.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
//            释放锁操作
            lock.unlock();
        }

    }

    public void decrement()throws Exception
    {
        lock.lock();
        try {
            //        1 判断
            while (data == 0){
//            等待，不可以生产,添加到阻塞队列中
                condition.await();
            }
//        2 干活
            data--;
            System.out.println(Thread.currentThread().getName()+"  "+data);
//        3 通知唤醒消费者
            condition.signal();

        }catch (Exception e){
            e.printStackTrace();
        }finally {
//            释放锁操作
            lock.unlock();
        }

    }

}
~~~

**虚假唤醒**

当判断共享资源的数量的时候，如果使用的是if语句，那么当有两个线程的时候是不会出问题的，但是当线程数量多于两个的时候，就会发生问题，所以判断的时候需要使用while循环。

~~~ java
// 判断
while(number != 0) {
    // 等待不能生产
    condition.await();
}
//不可以使用下面的方式
// 判断
if(number != 0) {
    // 等待不能生产
    condition.await();
}
~~~

### Lock和Synchronized的区别

1. 原始构成
   1. synchronized属于JVM层面，属于java的关键字 
      1. monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）
      2. 在底层，有两个monitorexit退出的指令，所以不管是否发生异常，程序都可以解锁，不会发生死锁的情况。
   2. Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁
2. 使用方法：
   1. synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用。
   2. ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成
3. 等待是否中断
   1. synchronized：不可中断，除非抛出异常或者正常运行完成。
   2. ReentrantLock：可中断，可以设置超时方法 
      1. 设置超时方法，trylock(long timeout, TimeUnit unit)
      2. lockInterrupible() 放代码块中，调用interrupt() 方法可以中断
4. 加锁是否公平 
   1. synchronized：非公平锁
   2. ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁
5. 锁绑定多个条件Condition 
   1. synchronized：没有，要么随机，要么全部唤醒
   2. ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以**精确唤醒**，而不是像synchronized那样，要么随机，要么全部唤醒

使用3个线程打印abc循环打印

### 线程通信之生产者消费者阻塞队列版(消息中间件)

~~~ java
public class PC_Block {

    public static void main(String[] args) throws InterruptedException {

        MySource mySource = new MySource( new ArrayBlockingQueue<String>(10));

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"  启动成功");
                mySource.myProd();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"prod").start();

        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"  启动成功");
                mySource.myCon();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"con").start();


        TimeUnit.SECONDS.sleep(5);
        mySource.stop();

    }
}


class MySource{

//    默认开启生产和消费,保证此变量在多个线程之间可见
    private volatile boolean FLAG=true;

//      在多线程中，一般使用原子整数类
    private AtomicInteger atomicInteger=new AtomicInteger();

//    通用的阻塞队列
    BlockingQueue<String> blockingQueue=null;

    public MySource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
//        获取完成的类名
        System.out.println(blockingQueue.getClass().getName());
    }

    public void myProd() throws InterruptedException {
        String data=null;
//        用来判断是否插入成功
        boolean valueSet;
//        如果标记为true，就生产数据
        while (FLAG){
            data=atomicInteger.incrementAndGet()+"";
//            返回是否插入数据成功
            valueSet = blockingQueue.offer(data, 2, TimeUnit.SECONDS);
            if(valueSet){
                System.out.println(Thread.currentThread().getName()+"  向阻塞队列中插入元素成功");
            }else {
                System.out.println(Thread.currentThread().getName()+"  向阻塞队列中插入元素失败");
            }
//            一秒钟生产一个数据
            TimeUnit.SECONDS.sleep(1);
        }
        System.out.println(Thread.currentThread().getName()+"  停止生产");
    }


    public void myCon() throws InterruptedException {
        String poll=null;
        while (FLAG){
            //        取出数据，超时为2秒
            poll = blockingQueue.poll(2, TimeUnit.SECONDS);
            if(poll == null){
                FLAG=false;
                System.out.println(Thread.currentThread().getName()+"  超过两秒没取到数据，退出");
                return;
            }
            System.out.println(Thread.currentThread().getName()+"  取出数据成功  "+poll);
        }
    }

    public void stop(){
        this.FLAG=false;
    }
}
~~~





