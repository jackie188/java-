<!-- TOC -->

- [前言](#前言)
- [I/O](#io)
  - [何为 I/O?](#何为-io)
  - [同步和异步](#同步和异步)
  - [阻塞与非阻塞](#阻塞与非阻塞)
  - [异步/同步/ 阻塞/非阻塞的区别](#异步同步-阻塞非阻塞的区别)
  - [异步/同步 阻塞/非阻塞的组合方式](#异步同步-阻塞非阻塞的组合方式)
  - [缓存IO](#缓存io)
  - [有哪些常见的 IO 模型?](#有哪些常见的-io-模型)
  - [阻塞IO（BIO）](#阻塞iobio)
  - [非阻塞IO](#非阻塞io)
  - [IO多路复用（NIO）](#io多路复用nio)
  - [信号驱动IO：](#信号驱动io)
  - [异步IO（AIO）](#异步ioaio)
- [Java 中 3 种常见 IO 模型](#java-中-3-种常见-io-模型)
  - [BIO (Blocking I/O)](#bio-blocking-io)
  - [NIO (Non-blocking/New I/O)](#nio-non-blockingnew-io)
  - [AIO (Asynchronous I/O)](#aio-asynchronous-io)
- [参考](#参考)

<!-- /TOC -->
IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！

## 前言

> IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。

## I/O

### 何为 I/O?

I/O（**I**nput/**O**utpu） 即**输入／输出** 。

**我们先从计算机结构的角度来解读一下 I/O。**

根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。

![1630300951073](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132232-718017.png)

输入设备（比如键盘）和输出设备（比如鼠标）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。

输入设备向计算机输入数据，输出设备接收计算机输出的数据。

**从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。**

**我们再先从应用程序的角度来解读一下 I/O。**

根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space）** 和 **内核空间（Kernel space ）** 。

像我们平常运行的应用程序都是运行在用户空间，**只有内核空间才能进行系统态级别的资源有关的操作，比如如文件管理、进程通信、内存管理等等**。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。

并且，用户空间的程序不能直接访问内核空间。

当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。

因此，用户进程想要执行 IO 操作的话，必须通过 **系统调用** 来间接访问内核空间

我们在平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和响应）**。

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤：

1. **内核等待 I/O 设备准备好数据**
2. **内核将数据从内核空间拷贝到用户空间**。

我们可以看下面的图：

![20220103134850](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103134850.png)

### 同步和异步

同步与异步是针对**应用程序与内核**的交互而言。

也就是上图的read操做，从缓存中读取数据，若是缓存中数据没有准备好，若是同步操做，它会一直等待，直到操做完成，

若是异步操做，那么他会去作别的事情，等待数据准备好，内核通知它，它再去读取数据，同步过程当中进程触发IO操做并等待或者轮询的去查看IO操做是否完成。

异步过程当中进程触发IO操做之后，直接返回，做本身的事情，IO操做交给内核来处理，处理完后通知进程IO完成。

同步和异步是相对于操做结果来讲，会不会等待结果返回。

### 阻塞与非阻塞

应用进程请求IO操做时，若是数据未准备好，当即返回就是非阻塞，不当即返回就是阻塞。

简单来讲，就是做一件事若是不能当即得到返回，须要等待，就是阻塞，不然就是非阻塞。

阻塞与非阻塞是相对于线程是否被阻塞网络

> 阻塞和非阻塞，是函数/方法的实现方式，即在数据就绪之前是立刻返回还是等待，即发起IO请求是否会被阻塞。

### 异步/同步/ 阻塞/非阻塞的区别

二者存在本质的区别，他们的修饰对象是不一样的。阻塞和非阻塞是指进程访问的**数据**若是还没有准备就绪，进程是否须要等待，简单说：相等于函数内部的实现区别，就是未就绪时，直接返回仍是等待就绪。

同步和异步是指**访问数据的机制**，同步通常主动请求等待IO操做完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后即可以继续处理其余任务，随后等待IO完毕通知，这可使进程在数据读写时也不阻塞多线程

> 以文件IO为例,一个IO读过程是文件数据从磁盘→内核缓冲区→用户内存的过程。同步与异步的区别主要在于数据从内核缓冲区→用户内存这个过程需不需要用户进程等待，即实际的IO读写是否阻塞请求进程。(网络IO把磁盘换做网卡即可)

### 异步/同步 阻塞/非阻塞的组合方式

同步阻塞：效率最低，实际程序中，就是fd未设置O_NONBLOCK标志位的read/write操做。

> 老王用水壶烧水，而且站在那里，看着水壶，等水开。异步

异步阻塞：异步操做是能够阻塞住的，只不过它不是在处理消息是阻塞，而是在等到消息时阻塞.

> 老王用响水壶烧水，站在那里，此次不看水壶了，而是等水开了水壶自动通知发出声音，老王听见了，知道水开了socket

同步非阻塞：实际效率仍是低下的，注意fd设置O_NONBLOCK标志位

老王用水壶烧水，不在站在那里直接等，而是跑出去去干别的事情，好比打游戏，看电视，可是，老王内心不放心，每隔一段时间回来看一下，看水开了没（异步内核通知进程）

异步非阻塞：效率高效，注册一个回调函数，就能够去作别的事情.

> 老王用响水壶烧水，跑去作别的事情，等待响水壶发出声音。（异步内核通知进程）

> socket的fd是什么？
> 
> fd是(file descriptor/文件描述符) ，这种通常是BSD Socket的用法，用在Unix/linux系统上。在Unix/linux系统下，一个Socket句柄，能够看作是一个文件，在socket上收发数据，可以对一个文件进行读写，因此一个socket句柄，一般也用表示文件句柄的fd来表示。

### 缓存IO

缓存IO又被称为标准IO，大多数文件系统的默认IO都是缓存IO，在linux的缓存IO机制中，系统会将IO的数据缓存在文件系统的页缓存（page cache），也就是说，**数据会先被拷贝到操做系统内核的缓冲区中，而后才会从操做系统内核的缓冲拷贝到应用程序的地址空间**。

缓存IO的缺点：

数据在传输过程当中须要在应用程序地址空间和内核进行屡次数据拷贝操做，这些数据拷贝带来的cpu以及内存开销是很是大的。

### 有哪些常见的 IO 模型?

UNIX 系统下， IO 模型一共有 5 种： **同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

可以使用一张图说明：

![20220103140119](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103140119.png)


这也是我们经常提到的 5 种 IO 模型。

### 阻塞IO（BIO）

![20220103140227](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103140227.png)

recvfrom函数为系统调用函数，从图中能够看出，从进行系统调用到拷贝数据到应用进程缓冲区完成，整段时间都是被阻塞的。

在这个过程当中要么正确到达，要么系统调用被打断；直到数据报被拷贝到用户进程后，用户才接触阻塞状态。

这里的用户进程是本身进行阻塞，拷贝也是有用户进行完成。在等待数据待处理数据的两个阶段，整个进程都是被阻塞的，不能处理别的网络IO，调用应用程序处于一种不在消费CPU而只是简单等待响应的状态。

> 去餐馆吃饭，点一个自己最爱吃的盖浇饭，然后在原地等着一直到盖浇饭做好，自己端到餐桌就餐。这就是典型的同步阻塞。当厨师给你做饭的时候，你需要一直在那里等着。

### 非阻塞IO

![20220103140424](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103140424.png)

从图中能够看出，当用户进程发出read操做时，若是kernel中的数据尚未准备好，那么他并不会block用户进程，而是立马返回一个error，从用户角度来说，他发起一个read操做后，并不须要等待，而是立刻等到一个结果，用户进程判断是一个error时，他就知道数据换没有准备好，因而它再次发送read操做，一旦kermel中的数据准备好了，而且再次收到了用户进程的read，那么他此时就会将数据拷贝到用户内存，而后返回。

因此用户的第一个阶段不是阻塞的，须要不断的主动问kernel数据好了没；第二阶段依然整体是阻塞的。

> 接着上面的例子，你每次点完饭就在那里等着，突然有一天你发现自己真傻。于是，你点完之后，就回桌子那里坐着，然后估计差不多了，就问老板饭好了没，如果好了就去端，没好的话就等一会再去问，依次循环直到饭做好。这就是同步非阻塞。

### IO多路复用（NIO）

select/epoll的好处就在于单个**process**就能够同时处理多个网络链接的IO。

![20220103140615](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103140615.png)

**IO复用和同步阻塞本质同样**，不过利用了新的select系统调用，**由内核来负责原本是请求进程该作的轮询操做**，看似不非阻塞IO还多了一个系统调用开销，不过由于支持多路IO才算提升了效率。

> 这里是什么意思呢，是由select系统调用来负责原本属于用户进程该做的任务，这个任务就是阻塞，用户线程仍然可以发起网络的io请求任务。

也就是一个能够监听多个。

它的基本原理就是select /epoll这个function会不断的轮询所负责的全部socket，当某个socket有数据到达了，就通知用户进程。

当用户线程调用select，那么整个进程会被阻塞，而同时，kernel会“监视”全部select负责的socket，当任何一个socket中的数据准备好了，select就会返回，这个时候用户进程在调用read操做，将数据kernel拷贝到用户进程。

> 接着上面的列子，你点一份饭然后循环的去问好没好显然有点得不偿失，还不如就等在那里直到准备好，但是当你点了好几样饭菜的时候，你每次都去问一下所有饭菜的状态(未做好/已做好)肯定比你每次阻塞在那里等着好多了。当然，你问的时候是需要阻塞的，一直到有准备好的饭菜或者你等的不耐烦(超时)。这就引出了IO复用，也叫多路IO就绪通知。这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。使得一个进程能在一连串的事件上等待。

IO复用的实现方式目前主要有select、poll和epoll。

select和poll的原理基本相同：

  1. 注册待侦听的fd(这里的fd创建时最好使用非阻塞)
  2. 每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回
  3. 返回结果中包括已就绪和未就绪的fd

相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。

此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。

select和poll就类似于上面说的就餐方式。但当你每次都去询问时，老板会把所有你点的饭菜都轮询一遍再告诉你情况，当大量饭菜很长时间都不能准备好的情况下是很低效的。于是，老板有些不耐烦了，就让厨师每做好一个菜就通知他。这样每次你再去问的时候，他会直接把已经准备好的菜告诉你，你再去端。这就是事件驱动IO就绪通知的方式-epoll。

### 信号驱动IO：

![20220103141029](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103141029.png)

首先开启套接字的信号驱动式IO功能，而且经过sigaction(信号处理程序) 系统调用安装一个信号处理函数 ，该函数调用将当即返回，当前进程没有被阻塞 ，继续工做；当数据报准备好的时候，内核为该进程产生SIGIO 的信号，随后既能够在信号处理函数中调用recvfrom 读取数据报，而且通知主循环数据已经准备好等待处理；也能够直接通知主循环让它读取数据报；(其实就是一个待读取的通知和待处理的通知)，基本不会用到。

> 上文的就餐方式还是需要你每次都去问一下饭菜状况。于是，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然后就自己坐在桌子那里干自己的事情。更甚者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。

### 异步IO（AIO）

![20220103141140](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103141140.png)

多线程和多进程的模型虽然解决了并发的问题，可是系统不能无限的增长线程，因为系统的切换线程的开销恒大，因此，一旦线程数量过多，CPU的时间就花在线程的切换上，正真运行代码的时间就会减小，结果致使性能严重降低

因为咱们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一个问题的一种方法。

另外一种解决IO问题的方法是异步IO，当代码须要执行一个耗时的IO操做时，他只发出IO指令，并不等待IO结果真后就去执行其余代码，一段时间后，当IO返回结果是，在通知CPU进行处理

咱们调用aio_read函数，给内核传递描述符，缓冲区指针，缓冲区大小，和文件偏移量，而且告诉内核当整个操做完成时如何通知咱们，该函数调用后，当即返回，不会被阻塞

另外一方面：从kernel的角度，当他收到一个aio_read以后，首先它当即返回，因此不会对用户进程产生block，而后kernel会等待数据准备完成，而后将数据拷贝到用户内存（copy由内核完成），当着一切完成后，kernel会给用户进程发送一个singal或者执行下一个基于线程回调函数来完成这次IO处理过程，告诉他read操做完成

> 之前的就餐方式，到最后总是需要你自己去把饭菜端到餐桌。这下你也不耐烦了，于是就告诉老板，能不能饭好了直接端到你的面前或者送到你的家里(外卖)。这就是异步非阻塞IO了。

> 异步IO的拷贝是有内核完成， 其余几种IO都是由用户进程完成

为了便于理解，下面说一个场景：

以上五种IO模型的通俗理解

- 活动：演唱会
- 角色一：满满
- 角色二：举办方-》售票员
- 角色三：黄牛
- 角色四：送票快递员

**同步阻塞IO：**

满满从家到售票点买票，售票员告诉满满，票明天才能卖。满满直接在售票点等到明天买票，而后回家。（**等待就体现了同步并且阻塞**）

**非阻塞IO:**

满满从家到演唱会现场向售票员买票，但票还未出来，而后满满就走了，去干别的事情，过了几个小时再来询问票是否出来，还没出来继续干别的事情。重复以上操做，直到票能够买。（**每隔几小时来询问就体现了非阻塞**）

**IO复用：**

JAVA->selector / linux->select,poll,epoll满满想买演唱会的票，打电话给黄牛(select)帮留一张票，票出来后，小明不须要花费时间去售票点买票(阻塞)（**可以从黄牛哪里直接获取票，也就是找了一个中间人**）。

**信号IO:**

满满想买演唱会门票，给举办方打电话，帮我留意票，能够售票了给我打个电话(打完就返回结果，等待kernel信号通知)，我本身来买票。票出来后，满满亲自去售票点买票

**异步IO:**

满满要看演唱会，给举办方打电话，能够售票了让送票快递员帮我把票送家里，满满就不用本身去专门买票了

## Java 中 3 种常见 IO 模型

### BIO (Blocking I/O)

**BIO 属于同步阻塞 IO 模型** 。

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。

![1630300974917](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132256-145887.png)

在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的过程，步骤如下：

1. 主线程accept请求阻塞

2. 请求到达，创建新的线程来处理这个套接字，完成对客户端的响应。

3. 主线程继续accept下一个请求

这种模型有一个很大的问题是：当客户端连接增多时，服务端创建的线程也会暴涨，系统性能会急剧下降。因此，在此模型的基础上，类似于 tomcat的bio connector，采用的是线程池来避免对于每一个客户端都创建一个线程。有些地方把这种方式叫做伪异步IO(把请求抛到线程池中异步等待处理)。

### NIO (Non-blocking/New I/O)

Java 中的 NIO 于 Java **1.4** 中引入，对应 `java.nio` 包，提供了 `Channel` , `Selector`，`Buffer` 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。

跟着我的思路往下看看，相信你会得到答案！

我们先来看看 **同步非阻塞 IO 模型**。

![1630300996371](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132317-684649.png)

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

**相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进**。通过轮询操作(可以比作一种CAS锁状态，一直在做忙等)，避免了一直阻塞。

但是，这种 IO 模型同样存在问题：**应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。**

这个时候，**I/O 多路复用模型** 就上场了。

![1630301013111](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132334-185700.png)

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。

> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
>
> - **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> - **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

![1630301040571](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132401-994560.png)

### AIO (Asynchronous I/O)

> JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。其底层在windows上是通过IOCP，在Linux上是通过epoll来实现的(LinuxAsynchronousChannelProvider.java,UnixAsynchronousServerSocketChannelImpl.java)。

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是**异步 IO 模型**。

异步 IO 是基于**事件和回调机制**实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

![1630301057278](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132418-191091.png)

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。

最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。

![1630301077981](https://tprzfbucket.oss-cn-beijing.aliyuncs.com/hadoop/202108/30/132439-402018.png)

**最后我们来对比以下IO模型**

![20220103143724](https://vscodepic.oss-cn-beijing.aliyuncs.com/pic/20220103143724.png)

## 参考

- 《深入拆解 Tomcat & Jetty》
- 如何完成一次 IO：[https://llc687.top/post/如何完成一次-io/](https://llc687.top/post/如何完成一次-io/)
- 程序员应该这样理解 IO：[https://www.jianshu.com/p/fa7bdc4f3de7](https://www.jianshu.com/p/fa7bdc4f3de7)
- 10 分钟看懂， Java NIO 底层原理：https://www.cnblogs.com/crazymakercircle/p/10225159.html
- IO 模型知多少 | 理论篇：https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-io-models.html
- 《UNIX 网络编程 卷 1；套接字联网 API 》6.2 节 IO 模型
